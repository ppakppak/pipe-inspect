<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Water ì–´ë…¸í…Œì´ì…˜ ì‹œìŠ¤í…œ</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #e0e0e0;
        }

        /* í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ ì‹­ìì„  ì»¤ì„œ */
        .crosshair-cursor {
            cursor: crosshair !important;
        }

        .crosshair-cursor.hide-cursor {
            cursor: none !important;
        }

        #crosshair-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        #crosshair-lines.active {
            display: block;
        }

        .crosshair-h, .crosshair-v {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        .crosshair-h {
            height: 1px;
            width: 100%;
            left: 0;
        }

        .crosshair-v {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .crosshair-center {
            display: none;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.5);
        }
        h1 {
            color: #ffffff;
            margin-bottom: 30px;
            font-size: 28px;
        }
        h2 {
            color: #ffffff;
            margin-bottom: 20px;
            margin-top: 0;
        }
        h3 {
            color: #e0e0e0;
            margin-bottom: 15px;
            margin-top: 20px;
            font-size: 16px;
        }
        h4 {
            color: #cccccc;
            margin-bottom: 10px;
            margin-top: 15px;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #404040;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 14px;
            color: #999;
            transition: all 0.3s;
        }
        .tab:hover {
            color: #fff;
            background: #3a3a3a;
        }
        .tab.active {
            color: #4a9eff;
            border-bottom: 2px solid #4a9eff;
            margin-bottom: -2px;
        }
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        .tab-content.active {
            display: block;
        }
        .status {
            padding: 15px;
            background: #1a3a4a;
            border-radius: 4px;
            margin-top: 20px;
            border-left: 4px solid #4a9eff;
        }
        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover {
            background: #3080df;
        }
        button:active {
            transform: scale(0.98);
        }

        /* ë¡œê·¸ì¸ í™”ë©´ ìŠ¤íƒ€ì¼ */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .login-box {
            background: #2d2d2d;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.8);
            width: 100%;
            max-width: 400px;
        }

        .login-box h2 {
            margin-top: 0;
            margin-bottom: 30px;
            text-align: center;
            color: #4a9eff;
        }

        .login-form-group {
            margin-bottom: 20px;
        }

        .login-form-group label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .login-form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #404040;
            background: #1e1e1e;
            color: #e0e0e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .login-form-group input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .login-error {
            background: #4a1a1a;
            color: #ff6b6b;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #ff6b6b;
            display: none;
        }

        .login-button {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-weight: 600;
        }

        /* ì‚¬ìš©ì ì •ë³´ í‘œì‹œ */
        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #404040;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info span {
            color: #e0e0e0;
            font-size: 14px;
        }

        .user-info .user-name {
            color: #4a9eff;
            font-weight: 600;
        }

        .logout-button {
            padding: 6px 12px;
            font-size: 12px;
            background: #dc3545;
        }

        .logout-button:hover {
            background: #c82333;
        }
        input[type="text"] {
            background: #1e1e1e;
            border: 1px solid #404040;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        input[type="number"],
        select {
            background: #1e1e1e;
            border: 1px solid #404040;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        label {
            color: #cccccc;
            font-size: 14px;
        }
        input[type="range"] {
            -webkit-appearance: none;
            background: #404040;
            height: 4px;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }
        #projectList {
            border: 1px solid #404040;
            padding: 15px;
            border-radius: 4px;
            min-height: 100px;
            background: #1e1e1e;
        }
        #projectList > div {
            padding: 10px;
            margin: 5px 0;
            background: #2d2d2d;
            border-radius: 4px;
            border-left: 4px solid #4a9eff;
        }
        #projectList > div:hover {
            background: #3a3a3a;
            cursor: pointer;
        }
        code {
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4a9eff;
        }
        small {
            color: #999;
        }

        /* í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ */
        .project-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .project-settings-modal.show {
            display: flex;
        }

        .project-settings-content {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.8);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .project-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #404040;
        }

        .project-settings-header h2 {
            margin: 0;
            color: #4a9eff;
        }

        .close-modal {
            background: #dc3545;
            padding: 8px 15px;
            font-size: 14px;
        }

        .class-list {
            border: 1px solid #404040;
            border-radius: 4px;
            background: #1e1e1e;
            padding: 10px;
            margin-bottom: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .class-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #2d2d2d;
            border-radius: 4px;
            border-left: 4px solid #4a9eff;
        }

        .class-item span {
            color: #e0e0e0;
            font-size: 14px;
        }

        .class-item button {
            background: #dc3545;
            padding: 5px 10px;
            font-size: 12px;
        }

        .add-class-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .add-class-input input {
            flex: 1;
        }

        /* NAS ë¹„ë””ì˜¤ ì„ íƒ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .nas-video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .nas-video-card {
            background: #1e1e1e;
            border: 2px solid #404040;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nas-video-card:hover {
            border-color: #4a9eff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.2);
        }

        .nas-video-card.selected {
            border-color: #4a9eff;
            background: #2a3a4a;
        }

        .nas-video-thumbnail {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
            background: #0a0a0a;
        }

        .nas-video-thumbnail-wrapper {
            position: relative;
            width: 100%;
        }

        .nas-video-completed-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: rgba(40, 167, 69, 0.85);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 18px;
            pointer-events: none;
        }

        .nas-video-completed-overlay .checkmark {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .nas-video-info {
            margin-top: 8px;
            font-size: 12px;
        }

        .nas-video-name {
            color: #e0e0e0;
            font-weight: 600;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .nas-video-meta {
            color: #888;
            font-size: 11px;
            line-height: 1.4;
        }

        .nas-filter-section {
            margin-bottom: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 4px;
        }

        .nas-filter-section select {
            padding: 6px;
            margin-right: 10px;
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #404040;
            border-radius: 4px;
        }

        .nas-loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .nas-selection-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    </style>
</head>
<body>
    <!-- ë¡œê·¸ì¸ í™”ë©´ -->
    <div id="loginOverlay" class="login-overlay">
        <div class="login-box">
            <h2>ğŸ” ë¡œê·¸ì¸</h2>
            <div id="loginError" class="login-error"></div>
            <form id="loginForm" onsubmit="handleLogin(event)">
                <div class="login-form-group">
                    <label for="loginUserId">ì‚¬ìš©ì ID</label>
                    <input type="text" id="loginUserId" required autocomplete="username">
                </div>
                <div class="login-form-group">
                    <label for="loginPassword">ë¹„ë°€ë²ˆí˜¸</label>
                    <input type="password" id="loginPassword" required autocomplete="current-password">
                </div>
                <button type="submit" class="login-button">ë¡œê·¸ì¸</button>
            </form>
            <div style="margin-top: 20px; text-align: center; color: #999; font-size: 12px;">
                <p>ê¸°ë³¸ ê³„ì •: admin / admin123</p>
            </div>
        </div>
    </div>

    <!-- ì‚¬ìš©ì ì •ë³´ -->
    <div id="userInfo" class="user-info" style="display: none;">
        <button onclick="toggleLanguage()" style="padding: 6px 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; margin-right: 10px;">
            <span id="langToggleBtn2">ğŸŒ EN</span>
        </button>
        <span>ğŸ‘¤ <span class="user-name" id="userName">ì‚¬ìš©ì</span></span>
        <button class="logout-button" onclick="handleLogout()">ë¡œê·¸ì•„ì›ƒ</button>
    </div>

    <!-- í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ -->
    <div id="projectSettingsModal" class="project-settings-modal">
        <div class="project-settings-content">
            <div class="project-settings-header">
                <h2>âš™ï¸ í”„ë¡œì íŠ¸ ì„¤ì •</h2>
                <button class="close-modal" onclick="closeProjectSettings()">âœ– ë‹«ê¸°</button>
            </div>

            <div>
                <h3>í”„ë¡œì íŠ¸ ì •ë³´</h3>
                <div style="margin-bottom: 20px;">
                    <div style="color: #888; font-size: 12px; margin-bottom: 5px;">í”„ë¡œì íŠ¸ ì´ë¦„:</div>
                    <div id="settingsProjectName" style="color: #4a9eff; font-size: 16px; font-weight: 600;">-</div>
                </div>
                <div style="margin-bottom: 20px;">
                    <div style="color: #888; font-size: 12px; margin-bottom: 5px;">í”„ë¡œì íŠ¸ ID:</div>
                    <div id="settingsProjectId" style="color: #999; font-size: 14px;">-</div>
                </div>
            </div>

            <div>
                <h3>í´ë˜ìŠ¤ ê´€ë¦¬</h3>
                <div id="settingsClassList" class="class-list">
                    <p style="color: #888; font-size: 12px;">í´ë˜ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
                </div>

                <div class="add-class-input" style="display: flex; flex-direction: column; gap: 8px;">
                    <input type="text" id="newClassName" placeholder="í´ë˜ìŠ¤ ì´ë¦„ (ì˜ˆ: rust, scale)" style="width: 100%;">
                    <textarea id="newClassDescription" placeholder="í´ë˜ìŠ¤ ì„¤ëª… (ì„ íƒì‚¬í•­)" style="width: 100%; padding: 8px; resize: vertical; min-height: 60px; font-family: inherit; background: #2d2d2d; color: #ddd; border: 1px solid #404040; border-radius: 4px;" onkeypress="if(event.key==='Enter' && event.ctrlKey) addClass()"></textarea>
                    <button onclick="addClass()" style="width: 100%;">â• í´ë˜ìŠ¤ ì¶”ê°€</button>
                </div>
            </div>

            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #404040;">
                <button onclick="saveProjectSettings()" style="width: 100%; padding: 12px; font-size: 16px;">ğŸ’¾ ë³€ê²½ì‚¬í•­ ì €ì¥</button>
            </div>
        </div>
    </div>

    <!-- ì–´ë…¸í…Œì´ì…˜ ë„ì›€ë§ ëª¨ë‹¬ -->
    <div id="annotationHelpModal" class="project-settings-modal">
        <div class="project-settings-content" style="max-width: 800px;">
            <div class="project-settings-header">
                <h2>â“ <span data-i18n="annotation.help">ì–´ë…¸í…Œì´ì…˜ ë„ì›€ë§</span></h2>
                <button class="close-modal" onclick="closeAnnotationHelp()">âœ– <span data-i18n="common.close">ë‹«ê¸°</span></button>
            </div>

            <div style="overflow-y: auto; max-height: calc(80vh - 100px); padding: 10px;">
                <!-- ê¸°ë³¸ ì‚¬ìš©ë²• -->
                <div style="margin-bottom: 30px;">
                    <h3>ğŸ¯ <span data-i18n="help.basicUsage">ê¸°ë³¸ ì‚¬ìš©ë²•</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px; border-left: 4px solid #4a9eff;">
                        <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
                            <li data-i18n="help.step1">í”„ë¡œì íŠ¸ íƒ­ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ì„ íƒí•˜ì„¸ìš”.</li>
                            <li data-i18n="help.step2">ë¹„ë””ì˜¤ë¥¼ ì¶”ê°€í•˜ê³  ì–´ë…¸í…Œì´ì…˜ íƒ­ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”.</li>
                            <li data-i18n="help.step3">ì™¼ìª½ íŒ¨ë„ì—ì„œ ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”.</li>
                            <li data-i18n="help.step4">AI ì¶”ë¡  ê²°ê³¼ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ìˆ˜ë™ìœ¼ë¡œ í´ë¦¬ê³¤ì„ ê·¸ë¦¬ì„¸ìš”.</li>
                            <li data-i18n="help.step5">ì™„ë£Œí•œ í”„ë ˆì„ì€ "ğŸ’¾ í”„ë ˆì„ ì €ì¥" ë²„íŠ¼ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”.</li>
                        </ol>
                    </div>
                </div>

                <!-- ë‹¨ì¶•í‚¤ -->
                <div style="margin-bottom: 30px;">
                    <h3>âŒ¨ï¸ <span data-i18n="help.shortcuts">ë‹¨ì¶•í‚¤</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px; color: #4a9eff; font-weight: bold;" data-i18n="help.key">í‚¤</td>
                                <td style="padding: 8px; color: #4a9eff; font-weight: bold;" data-i18n="help.action">ë™ì‘</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Space</code></td>
                                <td style="padding: 8px;" data-i18n="help.playPause">ì¬ìƒ / ì¼ì‹œì •ì§€</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">â†</code></td>
                                <td style="padding: 8px;" data-i18n="help.prevFrame">ì´ì „ í”„ë ˆì„</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">â†’</code></td>
                                <td style="padding: 8px;" data-i18n="help.nextFrame">ë‹¤ìŒ í”„ë ˆì„</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Ctrl + S</code></td>
                                <td style="padding: 8px;" data-i18n="help.saveFrame">í˜„ì¬ í”„ë ˆì„ ì €ì¥</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Delete</code></td>
                                <td style="padding: 8px;" data-i18n="help.deleteAnnotation">ì„ íƒí•œ ì–´ë…¸í…Œì´ì…˜ ì‚­ì œ</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Esc</code></td>
                                <td style="padding: 8px;" data-i18n="help.cancelDrawing">í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ì·¨ì†Œ</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <!-- ê·¸ë¦¬ê¸° ëª¨ë“œ -->
                <div style="margin-bottom: 30px;">
                    <h3>ğŸ–Šï¸ <span data-i18n="help.drawingModes">ê·¸ë¦¬ê¸° ëª¨ë“œ</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                        <div style="margin-bottom: 15px;">
                            <h4 style="color: #4a9eff; margin: 0 0 8px 0;" data-i18n="help.aiMode">ğŸ¤– AI ìë™ ì¶”ë¡ </h4>
                            <p style="margin: 0; color: #ccc;" data-i18n="help.aiModeDesc">í”„ë ˆì„ ì´ë™ ì‹œ ìë™ìœ¼ë¡œ AIê°€ ì˜ì—­ì„ ê°ì§€í•˜ì—¬ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <h4 style="color: #4a9eff; margin: 0 0 8px 0;" data-i18n="help.manualMode">âœï¸ ìˆ˜ë™ í´ë¦¬ê³¤</h4>
                            <p style="margin: 0; color: #ccc;" data-i18n="help.manualModeDesc">í´ë¦­í•˜ì—¬ ì ì„ ì°ê³  í´ë¦¬ê³¤ì„ ê·¸ë¦½ë‹ˆë‹¤. ë”ë¸”í´ë¦­ ë˜ëŠ” ì²« ì  í´ë¦­ìœ¼ë¡œ ì™„ë£Œí•©ë‹ˆë‹¤.</p>
                        </div>
                        <div>
                            <h4 style="color: #4a9eff; margin: 0 0 8px 0;" data-i18n="help.crosshairMode">â• ì‹­ìì„ </h4>
                            <p style="margin: 0; color: #ccc;" data-i18n="help.crosshairModeDesc">ì •í™•í•œ ìœ„ì¹˜ íŒŒì•…ì„ ìœ„í•œ ì‹­ìì„  ê°€ì´ë“œë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                        </div>
                    </div>
                </div>

                <!-- íŒ -->
                <div>
                    <h3>ğŸ’¡ <span data-i18n="help.tips">ìœ ìš©í•œ íŒ</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                            <li data-i18n="help.tip1">AI ì¶”ë¡  ê²°ê³¼ê°€ ë¶€ì •í™•í•˜ë©´ ìˆ˜ë™ìœ¼ë¡œ ìˆ˜ì •í•˜ê±°ë‚˜ ë‹¤ì‹œ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                            <li data-i18n="help.tip2">í”„ë ˆì„ì„ ì €ì¥í•˜ì§€ ì•Šìœ¼ë©´ ì‘ì—… ë‚´ìš©ì´ ì†ì‹¤ë©ë‹ˆë‹¤.</li>
                            <li data-i18n="help.tip3">ì—¬ëŸ¬ ê°œì˜ ë¹„ë””ì˜¤ íŒŒì¼ì„ í•œ ë²ˆì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (Ctrl/Cmd í´ë¦­).</li>
                            <li data-i18n="help.tip4">í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ í´ë˜ìŠ¤(ë¼ë²¨)ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                            <li data-i18n="help.tip5">í†µê³„ íŒ¨ë„ì—ì„œ ì „ì²´ ì‘ì—… ì§„í–‰ë¥ ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- í´ë˜ìŠ¤ ì„ íƒ íŒì—… (í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° í›„ - ë“œë¡­ë‹¤ìš´ í˜•ì‹) -->
    <div id="classSelectionPopup" style="
        display: none;
        position: fixed;
        z-index: 10000;
        background: #2d2d2d;
        border: 2px solid #4a9eff;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        padding: 10px;
        min-width: 200px;
        max-width: 300px;
    ">
        <div id="classSelectionButtons" style="display: flex; flex-direction: column; gap: 8px;">
            <!-- í´ë˜ìŠ¤ ë²„íŠ¼ë“¤ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë¨ -->
        </div>
    </div>

    <!-- NAS ë¹„ë””ì˜¤ ì„ íƒ ëª¨ë‹¬ -->
    <div id="nasVideoSelectionModal" class="project-settings-modal">
        <div class="project-settings-content" style="max-width: 1200px;">
            <div class="project-settings-header">
                <h2>ğŸ“ NAS ë¹„ë””ì˜¤ ì„ íƒ</h2>
                <button class="close-modal" onclick="closeNasVideoSelection()">âœ– ë‹«ê¸°</button>
            </div>

            <!-- í•„í„° ì„¹ì…˜ -->
            <div class="nas-filter-section">
                <label style="color: #e0e0e0; margin-right: 10px;">ì¥ë¹„:</label>
                <select id="nasFolderFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ì‹œì„¤:</label>
                <select id="nasRegionFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                    <option value="ì§€ë°©">ì§€ë°©</option>
                    <option value="ê´‘ì—­">ê´‘ì—­</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ê´€ê²½:</label>
                <select id="nasPipeSizeFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                    <option value="300MM">300MM</option>
                    <option value="500MM">500MM</option>
                    <option value="800MM">800MM</option>
                    <option value="1000MM">1000MM</option>
                    <option value="1200MM">1200MM</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ê´€ì¢…:</label>
                <select id="nasMethodFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                    <option value="SP">SP</option>
                    <option value="DCIP">DCIP</option>
                    <option value="HI3P">HI3P</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ì •ë ¬:</label>
                <select id="nasSortOrder" onchange="filterNasVideos()">
                    <option value="name">ì´ë¦„</option>
                    <option value="size">í¬ê¸°</option>
                    <option value="duration">ì¬ìƒì‹œê°„</option>
                </select>
                <span id="nasVideoCount" style="color: #888; margin-left: 15px;">0ê°œì˜ ë¹„ë””ì˜¤</span>
            </div>

            <!-- ë¡œë”© í‘œì‹œ -->
            <div id="nasLoading" class="nas-loading" style="display: none;">
                <div style="font-size: 32px; margin-bottom: 10px;">â³</div>
                <div>NAS ë¹„ë””ì˜¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
            </div>

            <!-- ë¹„ë””ì˜¤ ê·¸ë¦¬ë“œ -->
            <div id="nasVideoGrid" class="nas-video-grid"></div>

            <!-- ì„ íƒ ì •ë³´ ë° ë²„íŠ¼ -->
            <div class="nas-selection-footer">
                <div>
                    <span id="nasSelectedCount" style="color: #4a9eff; font-weight: 600;">0ê°œ ì„ íƒë¨</span>
                </div>
                <div>
                    <button onclick="closeNasVideoSelection()" style="background: #6c757d; margin-right: 10px;">ì·¨ì†Œ</button>
                    <button onclick="addSelectedNasVideos()" style="background: #28a745;">âœ“ ì„ íƒí•œ ë¹„ë””ì˜¤ ì¶”ê°€</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <h1 style="margin-bottom: 20px;" data-i18n="app.title">ğŸ’§ K-Water ì–´ë…¸í…Œì´ì…˜ ì‹œìŠ¤í…œ</h1>

        <div class="tabs">
            <button class="tab active" onclick="showTab('project')" data-i18n="tab.project">ğŸ“‚ Project</button>
            <button class="tab" onclick="showTab('annotation')" data-i18n="tab.annotation">ğŸ“¹ Annotation</button>
            <button class="tab" onclick="showTab('dataset')" data-i18n="tab.dataset">ğŸ“¦ Dataset</button>
            <button class="tab" onclick="showTab('training')" data-i18n="tab.training">ğŸš€ Training</button>
            <button class="tab" onclick="showTab('inference')" data-i18n="tab.inference">ğŸ¬ Inference</button>
            <button id="adminTab" class="tab" onclick="showTab('admin')" style="display: none;" data-i18n="tab.admin">ğŸ‘¥ Admin</button>
        </div>

        <div id="project-tab" class="tab-content active">
            <h2 data-i18n="project.title">í”„ë¡œì íŠ¸ ê´€ë¦¬</h2>

            <!-- Current Project Section -->
            <div id="currentProjectSection" style="margin-bottom: 30px; display: none;">
                <h3 data-i18n="project.current">í˜„ì¬ í”„ë¡œì íŠ¸</h3>
                <div style="background: #2d2d2d; padding: 20px; border-radius: 4px; border-left: 4px solid #4a9eff;">
                    <div style="margin-bottom: 15px;">
                        <strong id="currentProjectName" style="font-size: 18px; color: #4a9eff;">í”„ë¡œì íŠ¸ ì´ë¦„</strong>
                        <button onclick="openProjectSettings()" style="float: right; background: #4a9eff; margin-left: 10px;" data-i18n="common.settings">âš™ï¸ ì„¤ì •</button>
                        <button onclick="closeProject()" style="float: right; background: #dc3545;" data-i18n="common.close">âœ– ë‹«ê¸°</button>
                    </div>
                    <div id="currentProjectStats" style="font-size: 14px; color: #999; line-height: 1.8;">
                        í†µê³„ ì •ë³´...
                    </div>
                </div>

                <!-- Videos Section -->
                <div style="margin-top: 20px;">
                    <h3><span data-i18n="project.videos">í”„ë¡œì íŠ¸ ë¹„ë””ì˜¤</span>
                        <button onclick="showAddVideoDialog()" style="font-size: 12px; padding: 5px 10px; margin-left: 10px;" data-i18n="project.addVideo">â• ë¹„ë””ì˜¤ ì¶”ê°€</button>
                    </h3>

                    <!-- Upload Progress Bar -->
                    <div id="uploadProgress" style="display: none; margin-bottom: 10px; background: #1e1e1e; border: 1px solid #404040; border-radius: 4px; padding: 10px;">
                        <div style="margin-bottom: 5px;">
                            <span id="uploadFileName" style="font-weight: bold; color: #4a9eff;"></span>
                            <span id="uploadPercent" style="float: right; color: #888;">0%</span>
                        </div>
                        <div style="width: 100%; height: 20px; background: #2a2a2a; border-radius: 10px; overflow: hidden;">
                            <div id="uploadProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4a9eff, #2e7bd4); transition: width 0.3s ease;"></div>
                        </div>
                        <div id="uploadStatus" style="margin-top: 5px; font-size: 12px; color: #888;"></div>
                    </div>

                    <div id="videosList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 150px; background: #1e1e1e;">
                        <span data-i18n="project.noVideos">ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</span>
                    </div>
                </div>
            </div>

            <!-- 2-Column Layout: Project Creation (1) + Comments Dashboard (2) -->
            <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px; margin-bottom: 30px;">

                <!-- Left Column: Project Creation Card -->
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040;">
                    <h3 data-i18n="project.createNew" style="margin-top: 0; margin-bottom: 20px; color: #4a9eff;">â• ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 13px;">í”„ë¡œì íŠ¸ ì´ë¦„ (í•„ìˆ˜)</label>
                        <input type="text" id="projectName" data-i18n-placeholder="project.namePlaceholder" placeholder="í”„ë¡œì íŠ¸ ì´ë¦„ (í•„ìˆ˜)"
                               style="padding: 10px; width: 100%; box-sizing: border-box; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 13px;">ì‘ì—…ì ì´ë¦„ (ì„ íƒ)</label>
                        <input type="text" id="projectWorker" data-i18n-placeholder="project.workerPlaceholder" placeholder="ì‘ì—…ì ì´ë¦„ (ì„ íƒ)"
                               style="padding: 10px; width: 100%; box-sizing: border-box; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                    </div>
                    <button onclick="createProject(); return false;" data-i18n="project.create"
                            style="width: 100%; padding: 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 14px;">
                        â• í”„ë¡œì íŠ¸ ìƒì„±
                    </button>
                </div>

                <!-- Right Column: Comments Dashboard Card -->
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #4a9eff;">ğŸ’¬ ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ</h3>
                        <button onclick="loadCommentsDashboard()" style="font-size: 12px; padding: 6px 12px; background: #555; border: none; border-radius: 4px; cursor: pointer; color: white;">
                            ğŸ”„ ìƒˆë¡œê³ ì¹¨
                        </button>
                    </div>

                    <!-- Filter Controls -->
                    <div style="margin-bottom: 15px; display: grid; grid-template-columns: 1fr 1fr 1fr auto auto; gap: 8px;">
                        <input type="text" id="commentFilterProject" placeholder="í”„ë¡œì íŠ¸ í•„í„°..."
                               style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;"
                               oninput="filterComments()">
                        <input type="text" id="commentFilterUser" placeholder="ì‚¬ìš©ì í•„í„°..."
                               style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;"
                               oninput="filterComments()">
                        <input type="text" id="commentFilterLabel" placeholder="ë¼ë²¨ í•„í„°..."
                               style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;"
                               oninput="filterComments()">
                        <select id="commentSortBy" onchange="filterComments()" style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="recent">ìµœì‹ ìˆœ</option>
                            <option value="project">í”„ë¡œì íŠ¸ìˆœ</option>
                            <option value="user">ì‚¬ìš©ììˆœ</option>
                        </select>
                        <button id="toggleAnnotationsBtn" onclick="toggleAnnotationsDisplay()"
                                style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; color: white; font-size: 13px; white-space: nowrap;">
                            ğŸ‘ï¸ ì–´ë…¸í…Œì´ì…˜ ìˆ¨ê¹€
                        </button>
                    </div>

                    <!-- Comments List -->
                    <div id="commentsDashboard" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 300px; max-height: 450px; overflow-y: auto; background: #1e1e1e;">
                        <span style="color: #888;">ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                    </div>
                </div>
            </div>

            <!-- Projects List Section (2-column layout) -->
            <div>
                <h3><span data-i18n="project.list">í”„ë¡œì íŠ¸ ëª©ë¡</span>
                    <button onclick="loadProjects()" style="font-size: 12px; padding: 5px 10px; margin-left: 10px;" data-i18n="common.refresh">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                </h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <!-- ë‚´ í”„ë¡œì íŠ¸ (ì™¼ìª½) -->
                    <div>
                        <h4 style="margin-bottom: 10px; color: #4a9eff;">ğŸ“ ë‚´ í”„ë¡œì íŠ¸</h4>
                        <div id="myProjectList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; max-height: 600px; overflow-y: auto;">
                            <span data-i18n="project.loading">í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                        </div>
                    </div>
                    <!-- ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ (ì˜¤ë¥¸ìª½) -->
                    <div>
                        <h4 style="margin-bottom: 10px; color: #888;">ğŸ‘¥ ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸</h4>
                        <div id="sharedProjectList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; max-height: 600px; overflow-y: auto; background: #1a1a1a;">
                            <span data-i18n="project.loading">í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="annotation-tab" class="tab-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;" data-i18n="annotation.title">Video Annotation</h2>
                <button onclick="showAnnotationHelp()" style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">
                    â“ <span data-i18n="annotation.help">ë„ì›€ë§</span>
                </button>
            </div>
            <div style="display: flex; gap: 20px; align-items: stretch;">
                <!-- Left Column: Settings & Annotations -->
                <div style="flex: 1; min-width: 300px; max-width: 400px; display: flex; flex-direction: column; gap: 20px;">
                    <!-- Unified Settings Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.project">Project</h3>

                        <!-- Current Project Info -->
                        <div style="margin-bottom: 20px;">
                            <div id="currentProjectDisplay" style="padding: 10px; background: #2d2d2d; border-radius: 4px; font-size: 12px; color: #4a9eff;">
                                <span data-i18n="annotation.noProject">No project selected</span>
                            </div>
                        </div>

                        <!-- Current Video Info -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;" data-i18n="annotation.video">Video</h4>
                            <div id="currentVideoDisplay" style="padding: 10px; background: #2d2d2d; border-radius: 4px; font-size: 12px; color: #888;">
                                <span data-i18n="annotation.noVideo">No video selected</span>
                            </div>
                        </div>

                        <!-- Drawing Mode Toggle -->
                        <div style="margin-bottom: 0;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;" data-i18n="annotation.drawingMode">Drawing Mode</h4>
                            <div style="display: flex; gap: 8px;">
                                <label style="display: flex; align-items: center; padding: 8px; background: #2d2d2d; border: 2px solid #404040; border-radius: 4px; cursor: pointer; flex: 1;">
                                    <input type="checkbox" id="autoInferenceToggle" onclick="toggleAutoInference()" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-size: 12px;" data-i18n="annotation.autoInference">ğŸ¤– AI ìë™ ì¶”ë¡ </span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 8px; background: #2d2d2d; border: 2px solid #404040; border-radius: 4px; cursor: pointer; flex: 1;">
                                    <input type="checkbox" id="crosshairToggle" onclick="toggleCrosshair()" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-size: 12px;">â• ì‹­ìì„  ë³´ê¸°</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Current Frame Annotations Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); flex-grow: 1; display: flex; flex-direction: column;">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.annotations">Annotations</h3>

                        <!-- Current Frame Annotations -->
                        <div style="margin-bottom: 0; flex-grow: 1; display: flex; flex-direction: column;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;" data-i18n="annotation.currentFrame">Current Frame</h4>
                            <div id="annotationList" style="border: 1px solid #404040; padding: 10px; border-radius: 4px; min-height: 200px; max-height: 280px; overflow-y: auto; background: #2d2d2d; font-size: 12px;">
                                <span data-i18n="annotation.noAnnotations">No annotations</span>
                            </div>
                            <div style="margin-top: 10px; display: flex; gap: 5px;">
                                <button onclick="editAnnotation()" style="flex: 1; font-size: 12px;" data-i18n="common.edit">âœï¸ Edit</button>
                                <button onclick="deleteAnnotation()" style="flex: 1; font-size: 12px;" data-i18n="common.delete">ğŸ—‘ Delete</button>
                            </div>
                            <div style="margin-top: 5px; display: flex; gap: 5px;">
                                <button onclick="saveCurrentFrame()" style="flex: 1; font-size: 12px;" data-i18n="annotation.saveFrame">ğŸ’¾ Save Frame</button>
                                <button onclick="clearFrame()" style="flex: 1; font-size: 12px;" data-i18n="annotation.clearFrame">Clear Frame</button>
                            </div>
                        </div>
                    </div>

                    <!-- Contributors Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        <h4 style="margin-top: 0; margin-bottom: 10px; color: #4a9eff; font-size: 14px;">ğŸ‘¥ í˜‘ì—…ì (Collaborators)</h4>
                        <div id="contributorsList" style="font-size: 12px; color: #ccc; min-height: 30px;">
                            <span style="color: #888;">í˜‘ì—…ì ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                        </div>
                    </div>

                    <!-- Annotation Comment Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.comment">Comment</h3>

                        <div id="commentSection">
                            <div id="noAnnotationSelected" style="color: #888; font-size: 12px; text-align: center; padding: 20px;">
                                <span data-i18n="annotation.selectAnnotationForComment">Select an annotation to add a comment</span>
                            </div>
                            <div id="commentEditor" style="display: none;">
                                <div style="margin-bottom: 10px;">
                                    <div id="selectedAnnotationInfo" style="color: #4a9eff; font-size: 12px; margin-bottom: 10px;"></div>
                                    <textarea id="annotationCommentText"
                                              placeholder="Enter your comment here..."
                                              style="width: 100%; min-height: 100px; padding: 10px; background: #2d2d2d; color: #e0e0e0; border: 1px solid #404040; border-radius: 4px; font-size: 12px; resize: vertical; font-family: inherit;"></textarea>
                                </div>
                                <button onclick="saveAnnotationComment()" style="width: 100%; font-size: 12px;" data-i18n="annotation.saveComment">ğŸ’¬ Save Comment</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Video Player & Statistics -->
                <div style="flex: 2; display: flex; flex-direction: column; gap: 20px;">
                    <!-- Video Player Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px 20px 10px 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); flex-grow: 1; display: flex; flex-direction: column;">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.videoPlayer">Video Player</h3>

                        <div style="flex-grow: 1; display: flex; flex-direction: column;">
                            <!-- Video Canvas (Hybrid: video + canvas overlay) -->
<div id="canvasContainer" style="position: relative; background: #000; border-radius: 4px; margin-bottom: 8px; flex-shrink: 0;">
                            <!-- Hidden video element for playback (not visible but renders to canvas) -->
                            <video id="videoElement" style="position: absolute; top: 0; left: 0; width: 100%; height: auto; display: none;"></video>
                            <!-- Main canvas for video display -->
                            <canvas id="videoCanvas" width="1200" height="900" style="width: 100%; height: auto; display: block;"></canvas>

                            <!-- ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ -->
                            <div id="annotationContextMenu" style="
                                position: absolute;
                                display: none;
                                background: #2d2d2d;
                                border: 1px solid #404040;
                                border-radius: 4px;
                                padding: 4px 0;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.5);
                                z-index: 1000;
                                min-width: 150px;">
                            </div>
                            <!-- Overlay canvas for annotations and preview -->
                            <canvas id="previewCanvas" width="1200" height="900" style="position: absolute; top: 0; left: 0; width: 100%; height: auto; display: block; pointer-events: none;"></canvas>
                            <!-- ì‹­ìì„  ì»¤ì„œ -->
                            <div id="crosshair-lines">
                                <div class="crosshair-h"></div>
                                <div class="crosshair-v"></div>
                                <div class="crosshair-center"></div>
                            </div>
                        </div>

                        <!-- Video Controls -->
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Playback Buttons Row -->
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <button id="playBtn" onclick="togglePlay()" disabled data-i18n="annotation.play">â–¶ Play</button>
                                <button id="prevFrameBtn" onclick="prevFrame()" disabled data-i18n="annotation.prev">â—€ Prev</button>
                                <button id="nextFrameBtn" onclick="nextFrame()" disabled data-i18n="annotation.next">Next â–¶</button>
                                <button id="skip15BackBtn" onclick="skip15SecondsBackward()" disabled data-i18n="annotation.skip15Back">âª -15s</button>
                                <button id="skip15ForwardBtn" onclick="skip15SecondsForward()" disabled data-i18n="annotation.skip15Forward">+15s â©</button>
                                <span id="frameLabel" style="margin-left: auto;">Frame: 0 / 0</span>
                                <label style="color: #e0e0e0; font-size: 14px;" data-i18n="annotation.speed">ì†ë„:</label>
                                <select id="annotationPlaybackSpeed" onchange="changeAnnotationPlaybackSpeed()" style="padding: 6px 10px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px; cursor: pointer; font-size: 13px;">
                                    <option value="0.25">0.25x</option>
                                    <option value="0.5">0.5x</option>
                                    <option value="1" selected>1x</option>
                                    <option value="1.5">1.5x</option>
                                    <option value="2">2x</option>
                                    <option value="4">4x</option>
                                    <option value="8">8x</option>
                                    <option value="16">16x</option>
                                </select>
                            </div>
                            <!-- Progress Bar Row (matches canvas width) -->
                            <div style="display: flex; width: 100%;">
                                <input type="range" id="frameSlider" min="0" max="0" value="0"
                                       style="width: 100%;" disabled oninput="onSliderChange()">
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Statistics Card -->
                    <div id="statisticsCard" style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; flex-direction: column; transition: all 0.3s ease;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px; flex-grow: 1;" data-i18n="annotation.statistics">Statistics</h3>
                            <button id="toggleStatsBtn" onclick="toggleStatistics()" style="background: none; border: none; color: #4a9eff; cursor: pointer; font-size: 20px; padding: 5px 10px; margin-left: 10px;" title="í†µê³„ ìµœì†Œí™”/ìµœëŒ€í™”">â–¼</button>
                        </div>
                        <div id="statsContent" style="display: flex; flex-direction: column; flex-grow: 1;">
                            <div id="statsInfo" style="font-size: 12px; color: #4a9eff; margin-bottom: 10px;">
                                Saved: 0 | Frames: 0
                            </div>
                            <div id="statsTable" style="border: 1px solid #404040; padding: 10px; border-radius: 4px; overflow-y: auto; max-height: 400px; background: #2d2d2d; font-size: 11px; flex-grow: 1;">
                                <span data-i18n="annotation.noSavedAnnotations">No saved annotations</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="dataset-tab" class="tab-content">
            <h2 data-i18n="dataset.title">Dataset Builder</h2>

            <!-- Admin Dashboard (ê´€ë¦¬ì ì „ìš©) -->
            <div id="adminDashboardSection" style="display: none; margin-bottom: 30px;">
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 2px solid #4a9eff;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: #4a9eff;">ğŸ“Š ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ - ì „ì²´ í”„ë¡œì íŠ¸ í˜„í™©</h3>
                        <button onclick="loadAdminDashboard()" style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold;">
                            ğŸ”„ ìƒˆë¡œê³ ì¹¨
                        </button>
                    </div>

                    <!-- ì „ì²´ í†µê³„ ìš”ì•½ -->
                    <div id="adminSummaryCards" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 15px; margin-bottom: 20px;">
                        <!-- Summary cards will be populated by JavaScript -->
                    </div>

                    <!-- í”„ë¡œì íŠ¸ ëª©ë¡ í…Œì´ë¸” -->
                    <div style="margin-bottom: 10px;">
                        <input type="text" id="adminProjectFilter" placeholder="í”„ë¡œì íŠ¸ ë˜ëŠ” ì‚¬ìš©ì ê²€ìƒ‰..."
                               style="padding: 8px; width: 300px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;"
                               oninput="filterAdminProjects()">
                    </div>
                    <div id="adminProjectsList" style="max-height: 600px; overflow-y: auto; border: 1px solid #404040; border-radius: 4px; background: #1e1e1e;">
                        <div style="padding: 20px; text-align: center; color: #999;">ëŒ€ì‹œë³´ë“œë¥¼ ë¡œë“œí•˜ë ¤ë©´ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</div>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="dataset.projectInfo">í”„ë¡œì íŠ¸ ì •ë³´</h3>
                <div id="datasetProjectInfo" style="color: #999;">
                    <span data-i18n="dataset.noProject">í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</span>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="dataset.selectVideos">ë¹„ë””ì˜¤ ì„ íƒ</h3>
                <div id="datasetVideosList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 150px; background: #1e1e1e;">
                    <span data-i18n="dataset.selectProjectFirst">í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.</span>
                </div>
                <div style="margin-top: 10px;">
                    <button onclick="selectAllVideos()" data-i18n="dataset.selectAll">ì „ì²´ ì„ íƒ</button>
                    <button onclick="deselectAllVideos()" data-i18n="dataset.deselectAll">ì „ì²´ í•´ì œ</button>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="dataset.settings">ë°ì´í„°ì…‹ ì„¤ì •</h3>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="dataset.outputDir">ì¶œë ¥ ë””ë ‰í† ë¦¬:</label>
                    <input type="text" id="datasetOutputPath" value="pipe_dataset" style="width: 300px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="dataset.splitRatio">Train/Val/Test ë¹„ìœ¨:</label>
                    <input type="text" id="datasetSplit" value="0.7,0.15,0.15" style="width: 200px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="dataset.augmentation">Augmentation ë°°ìˆ˜:</label>
                    <input type="number" id="datasetAugment" value="3" min="0" max="10" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="dataset.format">ë°ì´í„°ì…‹ í˜•ì‹:</label>
                    <select id="datasetFormat" style="margin-left: 10px;">
                        <option value="classification">Classification</option>
                        <option value="yolo">YOLO Detection</option>
                    </select>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <button onclick="buildDataset()" style="padding: 10px 20px;" data-i18n="dataset.build">ğŸš€ Build Dataset</button>
                <button onclick="exportSegFormer()" style="padding: 10px 20px; margin-left: 10px;" data-i18n="dataset.exportSegFormer">ğŸ¯ Export SegFormer</button>
                <button onclick="exportYOLO()" style="padding: 10px 20px; margin-left: 10px;" data-i18n="dataset.exportYOLO">ğŸ“¦ Export YOLO</button>
            </div>

            <div style="margin-bottom: 10px;">
                <div id="datasetProgress" style="background: #1e1e1e; height: 20px; border-radius: 4px; overflow: hidden;">
                    <div id="datasetProgressBar" style="background: #4a9eff; height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
            </div>

            <div>
                <h3 data-i18n="dataset.buildLog">ë¹Œë“œ ë¡œê·¸</h3>
                <div id="datasetLog" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; background: #1e1e1e; font-family: monospace; font-size: 12px; overflow-y: auto;">
                    <span data-i18n="dataset.ready">Ready to build dataset...</span>
                </div>
            </div>
        </div>

        <div id="training-tab" class="tab-content">
            <h2 data-i18n="training.title">Model Training</h2>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="training.modelType">ëª¨ë¸ íƒ€ì…</h3>
                <select id="trainingModelType" style="width: 300px;">
                    <option value="classification">Classification (MobileNet)</option>
                    <option value="yolo">Detection (YOLO)</option>
                </select>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="training.dataset">ë°ì´í„°ì…‹</h3>
                <input type="text" id="trainingDatasetPath" value="pipe_dataset" style="width: 400px;">
                <button onclick="browseDataset()" style="margin-left: 10px;" data-i18n="training.browse">Browse...</button>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="training.settings">í•™ìŠµ ì„¤ì •</h3>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.outputDir">ì¶œë ¥ ë””ë ‰í† ë¦¬:</label>
                    <input type="text" id="trainingOutputPath" value="models" style="width: 300px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.epochs">Epochs:</label>
                    <input type="number" id="trainingEpochs" value="20" min="1" max="200" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.batchSize">Batch Size:</label>
                    <input type="number" id="trainingBatchSize" value="32" min="1" max="128" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.learningRate">Learning Rate:</label>
                    <input type="text" id="trainingLR" value="0.001" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label>
                        <input type="checkbox" id="trainingEvaluate" checked>
                        <span data-i18n="training.evaluate">Evaluate on test set</span>
                    </label>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <button onclick="startTraining()" id="startTrainingBtn" style="padding: 10px 20px; background: #28a745;" data-i18n="training.start">â–¶ Start Training</button>
                <button onclick="stopTraining()" id="stopTrainingBtn" disabled style="padding: 10px 20px; background: #dc3545; margin-left: 10px;" data-i18n="training.stop">â¹ Stop</button>
            </div>

            <div style="margin-bottom: 10px;">
                <div id="trainingProgress" style="background: #1e1e1e; height: 30px; border-radius: 4px; overflow: hidden; position: relative;">
                    <div id="trainingProgressBar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    <div id="trainingProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold;">0%</div>
                </div>
            </div>

            <div>
                <h3 data-i18n="training.log">í•™ìŠµ ë¡œê·¸</h3>
                <div id="trainingLog" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; height: 300px; background: #1e1e1e; font-family: monospace; font-size: 12px; overflow-y: auto;">
                    <span data-i18n="training.ready">Ready to start training...</span>
                </div>
            </div>
        </div>

        <div id="inference-tab" class="tab-content">
            <h2 data-i18n="inference.title">ğŸ¬ Video Inference</h2>

            <!-- 2ë‹¨ ë ˆì´ì•„ì›ƒ: ì™¼ìª½ ì„¤ì •, ì˜¤ë¥¸ìª½ ì‹¤ì‹œê°„ ê²°ê³¼ -->
            <div style="display: grid; grid-template-columns: 400px 1fr; gap: 20px; height: calc(100vh - 180px);">

                <!-- ì™¼ìª½: ì„¤ì • íŒ¨ë„ -->
                <div style="background: #1e1e1e; padding: 20px; border-radius: 8px; overflow-y: auto;">
                    <h3 style="margin-top: 0; border-bottom: 2px solid #404040; padding-bottom: 10px;" data-i18n="inference.settings">âš™ï¸ ì¶”ë¡  ì„¤ì •</h3>

                    <!-- ëª¨ë¸ ì„ íƒ -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.modelType">ëª¨ë¸ íƒ€ì…</label>
                        <select id="inferenceModelType" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <option value="classification">Classification</option>
                            <option value="yolo">YOLO Detection</option>
                            <option value="segformer">SegFormer Segmentation</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.modelFile">ëª¨ë¸ íŒŒì¼</label>
                        <div style="display: flex; gap: 5px;">
                            <input type="text" id="inferenceModelPath" data-i18n-placeholder="inference.modelPath" placeholder="ëª¨ë¸ ê²½ë¡œ" style="flex: 1; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <button onclick="browseInferenceModel()" style="padding: 8px 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer;">ğŸ“</button>
                        </div>
                    </div>

                    <!-- ë¹„ë””ì˜¤ ì„ íƒ -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.videoFile">ë¹„ë””ì˜¤ íŒŒì¼</label>
                        <div style="display: flex; gap: 5px;">
                            <input type="text" id="inferenceVideoPath" data-i18n-placeholder="inference.videoPath" placeholder="ë¹„ë””ì˜¤ ê²½ë¡œ" style="flex: 1; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <button onclick="browseInferenceVideo()" style="padding: 8px 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer;">ğŸ“</button>
                        </div>
                    </div>

                    <!-- ì¶”ë¡  ì„¤ì • -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.outputDir">ì¶œë ¥ ë””ë ‰í† ë¦¬</label>
                        <input type="text" id="inferenceOutputPath" value="inference_results" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.confidence">Confidence ì„ê³„ê°’</label>
                        <input type="number" id="inferenceConfidence" value="0.5" min="0" max="1" step="0.1" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                    </div>

                    <!-- ì‹¤í–‰ ë²„íŠ¼ -->
                    <div style="margin-bottom: 20px;">
                        <button onclick="startInference()" id="startInferenceBtn" style="width: 100%; padding: 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;" data-i18n="inference.start">
                            â–¶ï¸ Start Inference
                        </button>
                        <button onclick="cancelInference()" id="cancelInferenceBtn" style="width: 100%; padding: 12px; background: #ff4444; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold; display: none; margin-top: 10px;" data-i18n="inference.cancel">
                            âŒ Cancel
                        </button>
                    </div>

                    <!-- ì§„í–‰ë¥  -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.progress">ì§„í–‰ ìƒí™©</label>
                        <div id="inferenceProgress" style="background: #0e0e0e; height: 40px; border-radius: 4px; overflow: hidden; position: relative; border: 1px solid #404040;">
                            <div id="inferenceProgressBar" style="background: linear-gradient(90deg, #4a9eff, #00d4ff); height: 100%; width: 0%; transition: width 0.3s;"></div>
                            <div id="inferenceProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold; font-size: 14px;">
                                <span data-i18n="inference.preparing">ì¤€ë¹„ ì¤‘...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ì˜¤ë¥¸ìª½: ì‹¤ì‹œê°„ ì¶”ë¡  ê²°ê³¼ -->
                <div style="background: #1e1e1e; padding: 20px; border-radius: 8px; overflow: hidden; display: flex; flex-direction: column;">
                    <h3 style="margin-top: 0; border-bottom: 2px solid #404040; padding-bottom: 10px;" data-i18n="inference.results">ğŸ¥ ì‹¤ì‹œê°„ ì¶”ë¡  ê²°ê³¼</h3>

                    <!-- í”Œë ˆì´ì–´ ì»¨í…Œì´ë„ˆ -->
                    <div id="inferencePreviewContainer" style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 0;">
                        <!-- ì´ˆê¸° ìƒíƒœ: ëŒ€ê¸° ë©”ì‹œì§€ -->
                        <div id="inferencePreviewPlaceholder" style="text-align: center; color: #666;">
                            <div style="font-size: 64px; margin-bottom: 20px;">ğŸ¬</div>
                            <div style="font-size: 18px; margin-bottom: 10px;">ì¶”ë¡ ì„ ì‹œì‘í•˜ë©´ ì—¬ê¸°ì— ì‹¤ì‹œê°„ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>
                            <div style="font-size: 14px; color: #888;">ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ê³  Start Inference ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</div>
                        </div>

                        <!-- ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ (ìˆ¨ê¹€ ìƒíƒœë¡œ ì‹œì‘) -->
                        <div id="inferencePreviewPlayer" style="display: none; width: 100%; height: 100%; flex-direction: column;">
                            <div style="flex: 1; border: 2px solid #404040; border-radius: 8px; overflow: hidden; background: #000; display: flex; flex-direction: column;">
                                <!-- ë¹„ë””ì˜¤ ë””ìŠ¤í”Œë ˆì´ -->
                                <div style="flex: 1; position: relative; display: flex; align-items: center; justify-content: center; background: #000;">
                                    <canvas id="inferencePreviewCanvas" style="max-width: 100%; max-height: 100%; display: block;"></canvas>
                                    <div id="inferencePreviewStatus" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #fff; padding: 8px 12px; border-radius: 4px; font-size: 14px; font-weight: bold;">
                                        í”„ë ˆì„: 0 / 0
                                    </div>
                                    <div id="inferenceBufferStatus" style="position: absolute; top: 10px; left: 10px; background: rgba(74,158,255,0.9); color: #fff; padding: 8px 12px; border-radius: 4px; font-size: 14px; font-weight: bold;">
                                        ë²„í¼: 0%
                                    </div>
                                </div>

                                <!-- ë¹„ë””ì˜¤ ì»¨íŠ¸ë¡¤ -->
                                <div style="background: #0e0e0e; padding: 15px; border-top: 1px solid #404040;">
                                    <!-- íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë” -->
                                    <div style="margin-bottom: 10px;">
                                        <input type="range" id="videoTimeline" min="0" max="100" value="0"
                                               style="width: 100%; cursor: pointer;"
                                               oninput="seekToFrame(this.value)">
                                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: #999; margin-top: 5px;">
                                            <span id="videoCurrentTime">00:00</span>
                                            <span id="videoDuration">00:00</span>
                                        </div>
                                    </div>

                                    <!-- ì¬ìƒ ì»¨íŠ¸ë¡¤ -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <button onclick="togglePlayPause()" id="playPauseBtn" style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                                            â–¶ï¸ ì¬ìƒ
                                        </button>
                                        <button onclick="stopPlayback()" style="padding: 8px 16px; background: #666; border: none; border-radius: 4px; cursor: pointer;">
                                            â¹ï¸ ì •ì§€
                                        </button>
                                        <button onclick="skipFrames(-10)" style="padding: 8px 12px; background: #666; border: none; border-radius: 4px; cursor: pointer;">
                                            âª -10
                                        </button>
                                        <button onclick="skipFrames(10)" style="padding: 8px 12px; background: #666; border: none; border-radius: 4px; cursor: pointer;">
                                            â© +10
                                        </button>

                                        <div style="flex: 1;"></div>

                                        <label style="color: #fff; font-size: 14px;">ì†ë„:</label>
                                        <select id="playbackSpeed" onchange="changePlaybackSpeed()" style="padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px; cursor: pointer;">
                                            <option value="0.25">0.25x</option>
                                            <option value="0.5">0.5x</option>
                                            <option value="1" selected>1x</option>
                                            <option value="1.5">1.5x</option>
                                            <option value="2">2x</option>
                                            <option value="4">4x</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Admin Tab (ê´€ë¦¬ì ì „ìš©) -->
        <div id="admin-tab" class="tab-content">
            <h2>ğŸ‘¥ ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ</h2>

            <!-- ì „ì²´ í”„ë¡œì íŠ¸ ëŒ€ì‹œë³´ë“œ -->
            <div style="margin-bottom: 30px;">
                <h3>ğŸ“Š ì „ì²´ í”„ë¡œì íŠ¸ í˜„í™©</h3>
                <div id="allProjectsList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 300px; background: #1e1e1e; max-height: 600px; overflow-y: auto;">
                    <p style="color: #999;">ë¡œë”© ì¤‘...</p>
                </div>
            </div>

            <!-- ì‚¬ìš©ì ëª©ë¡ -->
            <div style="margin-bottom: 30px;">
                <h3>ì‚¬ìš©ì ëª©ë¡</h3>
                <div id="usersList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; background: #1e1e1e;">
                    <p style="color: #999;">ë¡œë”© ì¤‘...</p>
                </div>
            </div>

            <!-- ìƒˆ ì‚¬ìš©ì ìƒì„± -->
            <div style="margin-bottom: 30px;">
                <h3>ìƒˆ ì‚¬ìš©ì ìƒì„±</h3>
                <div style="background: #2d2d2d; padding: 20px; border-radius: 4px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì‚¬ìš©ì ID:</label>
                        <input type="text" id="newUserId" placeholder="ì‚¬ìš©ì ID" style="width: 100%; max-width: 300px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ë¹„ë°€ë²ˆí˜¸:</label>
                        <input type="password" id="newUserPassword" placeholder="ë¹„ë°€ë²ˆí˜¸" style="width: 100%; max-width: 300px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì´ë¦„:</label>
                        <input type="text" id="newUserFullName" placeholder="Full Name" style="width: 100%; max-width: 300px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì—­í• :</label>
                        <select id="newUserRole" style="width: 100%; max-width: 300px;">
                            <option value="user">User</option>
                            <option value="admin">Admin</option>
                        </select>
                    </div>
                    <button onclick="createNewUser()" style="padding: 10px 20px;">â• ì‚¬ìš©ì ìƒì„±</button>
                </div>
            </div>

            <!-- ì‚¬ìš©ì ìˆ˜ì • ëª¨ë‹¬ -->
            <div id="editUserModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
                <div style="background: #2d2d2d; padding: 30px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <h3 style="margin-top: 0;">ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •</h3>

                    <!-- ì›ë˜ user_idë¥¼ ì €ì¥í•˜ëŠ” hidden í•„ë“œ -->
                    <input type="hidden" id="editUserOriginalId">

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">ì‚¬ìš©ì ID:</label>
                        <input type="text" id="editUserId" readonly style="width: 100%; background: #404040; color: #999; cursor: not-allowed;">
                        <small style="color: #666;">ë³´ì•ˆìƒì˜ ì´ìœ ë¡œ ì‚¬ìš©ì IDëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</small>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì´ë¦„:</label>
                        <input type="text" id="editUserFullName" placeholder="Full Name" style="width: 100%;">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì—­í• :</label>
                        <select id="editUserRole" style="width: 100%;">
                            <option value="user">User</option>
                            <option value="admin">Admin</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ìƒˆ ë¹„ë°€ë²ˆí˜¸ (ì„ íƒì‚¬í•­):</label>
                        <input type="password" id="editUserPassword" placeholder="ë³€ê²½í•˜ë ¤ë©´ ìƒˆ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" style="width: 100%;">
                        <small style="color: #999;">ë¹„ì›Œë‘ë©´ ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</small>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px;">
                        <button onclick="closeEditUserModal()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            ì·¨ì†Œ
                        </button>
                        <button onclick="updateUser()" style="padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            âœ… ì €ì¥
                        </button>
                    </div>
                </div>
            </div>

            <!-- ì‹œìŠ¤í…œ í†µê³„ -->
            <div style="margin-bottom: 30px;">
                <h3>ì‹œìŠ¤í…œ í†µê³„</h3>
                <div id="systemStats" style="background: #2d2d2d; padding: 20px; border-radius: 4px;">
                    <p style="color: #999;">ë¡œë”© ì¤‘...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('[SCRIPT START] JavaScript is loading...');

        // ============================================
        // ë‹¤êµ­ì–´ ì§€ì› ì‹œìŠ¤í…œ
        // ============================================

        // í˜„ì¬ ì–¸ì–´ (ê¸°ë³¸ê°’: í•œê¸€)
        let currentLanguage = localStorage.getItem('language') || 'ko';

        // ë‹¤êµ­ì–´ ë²ˆì—­ ë°ì´í„°
        const translations = {
            ko: {
                // ì•± íƒ€ì´í‹€ & íƒ­
                'app.title': 'ğŸ’§ K-Water ì–´ë…¸í…Œì´ì…˜ ì‹œìŠ¤í…œ',
                'tab.project': 'ğŸ“‚ í”„ë¡œì íŠ¸',
                'tab.annotation': 'ğŸ“¹ ì–´ë…¸í…Œì´ì…˜',
                'tab.dataset': 'ğŸ“¦ ë°ì´í„°ì…‹',
                'tab.training': 'ğŸš€ í•™ìŠµ',
                'tab.inference': 'ğŸ¬ ì¶”ë¡ ',
                'tab.admin': 'ğŸ‘¥ ê´€ë¦¬ì',

                // ê³µí†µ
                'common.close': 'âœ– ë‹«ê¸°',
                'common.save': 'ğŸ’¾ ì €ì¥',
                'common.delete': 'ğŸ—‘ ì‚­ì œ',
                'common.edit': 'âœï¸ í¸ì§‘',
                'common.add': 'â• ì¶”ê°€',
                'common.cancel': 'ì·¨ì†Œ',
                'common.settings': 'âš™ï¸ ì„¤ì •',
                'common.refresh': 'ğŸ”„ ìƒˆë¡œê³ ì¹¨',

                // í”„ë¡œì íŠ¸
                'project.title': 'í”„ë¡œì íŠ¸ ê´€ë¦¬',
                'project.current': 'í˜„ì¬ í”„ë¡œì íŠ¸',
                'project.createNew': 'ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±',
                'project.create': 'â• í”„ë¡œì íŠ¸ ìƒì„±',
                'project.name': 'í”„ë¡œì íŠ¸ ì´ë¦„',
                'project.worker': 'ì‘ì—…ì ì´ë¦„',
                'project.videos': 'í”„ë¡œì íŠ¸ ë¹„ë””ì˜¤',
                'project.addVideo': 'â• ë¹„ë””ì˜¤ ì¶”ê°€',
                'project.noVideos': 'ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.',
                'project.list': 'í”„ë¡œì íŠ¸ ëª©ë¡',
                'project.loading': 'í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...',
                'project.namePlaceholder': 'í”„ë¡œì íŠ¸ ì´ë¦„ (í•„ìˆ˜)',
                'project.workerPlaceholder': 'ì‘ì—…ì ì´ë¦„ (ì„ íƒ)',

                // ì–´ë…¸í…Œì´ì…˜
                'annotation.title': 'ë¹„ë””ì˜¤ ì–´ë…¸í…Œì´ì…˜',
                'annotation.help': 'ë„ì›€ë§',
                'annotation.project': 'í”„ë¡œì íŠ¸',
                'annotation.video': 'ë¹„ë””ì˜¤',
                'annotation.noProject': 'í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
                'annotation.noVideo': 'ë¹„ë””ì˜¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
                'annotation.aiStatus': 'AI ìƒíƒœ',
                'annotation.checking': 'í™•ì¸ ì¤‘...',
                'annotation.autoInference': 'ìë™ ì¶”ë¡  í™œì„±í™”',
                'annotation.labelSelection': 'ë¼ë²¨ ì„ íƒ',
                'annotation.selectProject': 'í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                'annotation.drawingMode': 'ê·¸ë¦¬ê¸° ëª¨ë“œ',
                'annotation.manualPolygon': 'ğŸ–Šï¸ ìˆ˜ë™ í´ë¦¬ê³¤ (OFF)',
                'annotation.annotations': 'ì–´ë…¸í…Œì´ì…˜',
                'annotation.videoPlayer': 'ë¹„ë””ì˜¤ í”Œë ˆì´ì–´',
                'annotation.currentFrame': 'í˜„ì¬ í”„ë ˆì„',
                'annotation.noAnnotations': 'ì–´ë…¸í…Œì´ì…˜ ì—†ìŒ',
                'annotation.saveFrame': 'ğŸ’¾ í”„ë ˆì„ ì €ì¥',
                'annotation.clearFrame': 'í”„ë ˆì„ ì§€ìš°ê¸°',
                'annotation.statistics': 'í†µê³„',
                'annotation.noSavedAnnotations': 'ì €ì¥ëœ ì–´ë…¸í…Œì´ì…˜ ì—†ìŒ',
                'annotation.comment': 'ì½”ë©˜íŠ¸',
                'annotation.selectAnnotationForComment': 'ì½”ë©˜íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ì–´ë…¸í…Œì´ì…˜ì„ ì„ íƒí•˜ì„¸ìš”',
                'annotation.saveComment': 'ğŸ’¬ ì½”ë©˜íŠ¸ ì €ì¥',
                'annotation.play': 'â–¶ ì¬ìƒ',
                'annotation.prev': 'â—€ ì´ì „',
                'annotation.next': 'ë‹¤ìŒ â–¶',
                'annotation.skip15Back': 'âª -15 Frame',
                'annotation.skip15Forward': '+15 Frame â©',
                'annotation.speed': 'ì†ë„:',

                // ë„ì›€ë§
                'help.basicUsage': 'ê¸°ë³¸ ì‚¬ìš©ë²•',
                'help.step1': 'í”„ë¡œì íŠ¸ íƒ­ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ì„ íƒí•˜ì„¸ìš”.',
                'help.step2': 'ë¹„ë””ì˜¤ë¥¼ ì¶”ê°€í•˜ê³  ì–´ë…¸í…Œì´ì…˜ íƒ­ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”.',
                'help.step3': 'ì™¼ìª½ íŒ¨ë„ì—ì„œ ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”.',
                'help.step4': 'AI ì¶”ë¡  ê²°ê³¼ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ìˆ˜ë™ìœ¼ë¡œ í´ë¦¬ê³¤ì„ ê·¸ë¦¬ì„¸ìš”.',
                'help.step5': 'ì™„ë£Œí•œ í”„ë ˆì„ì€ "ğŸ’¾ í”„ë ˆì„ ì €ì¥" ë²„íŠ¼ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”.',
                'help.shortcuts': 'ë‹¨ì¶•í‚¤',
                'help.key': 'í‚¤',
                'help.action': 'ë™ì‘',
                'help.playPause': 'ì¬ìƒ / ì¼ì‹œì •ì§€',
                'help.prevFrame': 'ì´ì „ í”„ë ˆì„',
                'help.nextFrame': 'ë‹¤ìŒ í”„ë ˆì„',
                'help.saveFrame': 'í˜„ì¬ í”„ë ˆì„ ì €ì¥',
                'help.deleteAnnotation': 'ì„ íƒí•œ ì–´ë…¸í…Œì´ì…˜ ì‚­ì œ',
                'help.cancelDrawing': 'í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ì·¨ì†Œ',
                'help.drawingModes': 'ê·¸ë¦¬ê¸° ëª¨ë“œ',
                'help.aiMode': 'ğŸ¤– AI ìë™ ì¶”ë¡ ',
                'help.aiModeDesc': 'í”„ë ˆì„ ì´ë™ ì‹œ ìë™ìœ¼ë¡œ AIê°€ ì˜ì—­ì„ ê°ì§€í•˜ì—¬ í‘œì‹œí•©ë‹ˆë‹¤.',
                'help.manualMode': 'âœï¸ ìˆ˜ë™ í´ë¦¬ê³¤',
                'help.manualModeDesc': 'í´ë¦­í•˜ì—¬ ì ì„ ì°ê³  í´ë¦¬ê³¤ì„ ê·¸ë¦½ë‹ˆë‹¤. ë”ë¸”í´ë¦­ ë˜ëŠ” ì²« ì  í´ë¦­ìœ¼ë¡œ ì™„ë£Œí•©ë‹ˆë‹¤.',
                'help.crosshairMode': 'â• ì‹­ìì„ ',
                'help.crosshairModeDesc': 'ì •í™•í•œ ìœ„ì¹˜ íŒŒì•…ì„ ìœ„í•œ ì‹­ìì„  ê°€ì´ë“œë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.',
                'help.tips': 'ìœ ìš©í•œ íŒ',
                'help.tip1': 'AI ì¶”ë¡  ê²°ê³¼ê°€ ë¶€ì •í™•í•˜ë©´ ìˆ˜ë™ìœ¼ë¡œ ìˆ˜ì •í•˜ê±°ë‚˜ ë‹¤ì‹œ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'help.tip2': 'í”„ë ˆì„ì„ ì €ì¥í•˜ì§€ ì•Šìœ¼ë©´ ì‘ì—… ë‚´ìš©ì´ ì†ì‹¤ë©ë‹ˆë‹¤.',
                'help.tip3': 'ì—¬ëŸ¬ ê°œì˜ ë¹„ë””ì˜¤ íŒŒì¼ì„ í•œ ë²ˆì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (Ctrl/Cmd í´ë¦­).',
                'help.tip4': 'í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ í´ë˜ìŠ¤(ë¼ë²¨)ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'help.tip5': 'í†µê³„ íŒ¨ë„ì—ì„œ ì „ì²´ ì‘ì—… ì§„í–‰ë¥ ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',

                // ë°ì´í„°ì…‹
                'dataset.title': 'ë°ì´í„°ì…‹ ë¹Œë”',
                'dataset.projectInfo': 'í”„ë¡œì íŠ¸ ì •ë³´',
                'dataset.noProject': 'í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
                'dataset.selectVideos': 'ë¹„ë””ì˜¤ ì„ íƒ',
                'dataset.selectProjectFirst': 'í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.',
                'dataset.selectAll': 'ì „ì²´ ì„ íƒ',
                'dataset.deselectAll': 'ì „ì²´ í•´ì œ',
                'dataset.settings': 'ë°ì´í„°ì…‹ ì„¤ì •',
                'dataset.outputDir': 'ì¶œë ¥ ë””ë ‰í† ë¦¬:',
                'dataset.splitRatio': 'Train/Val/Test ë¹„ìœ¨:',
                'dataset.augmentation': 'Augmentation ë°°ìˆ˜:',
                'dataset.format': 'ë°ì´í„°ì…‹ í˜•ì‹:',
                'dataset.build': 'ğŸš€ ë°ì´í„°ì…‹ ë¹Œë“œ',
                'dataset.exportSegFormer': 'ğŸ¯ SegFormer ë‚´ë³´ë‚´ê¸°',
                'dataset.exportYOLO': 'ğŸ“¦ YOLO ë‚´ë³´ë‚´ê¸°',
                'dataset.buildLog': 'ë¹Œë“œ ë¡œê·¸',
                'dataset.ready': 'ë°ì´í„°ì…‹ ë¹Œë“œ ì¤€ë¹„ ì™„ë£Œ...',

                // í•™ìŠµ
                'training.title': 'ëª¨ë¸ í•™ìŠµ',
                'training.modelType': 'ëª¨ë¸ íƒ€ì…',
                'training.dataset': 'ë°ì´í„°ì…‹',
                'training.browse': 'ì°¾ì•„ë³´ê¸°...',
                'training.settings': 'í•™ìŠµ ì„¤ì •',
                'training.outputDir': 'ì¶œë ¥ ë””ë ‰í† ë¦¬:',
                'training.epochs': 'Epochs:',
                'training.batchSize': 'Batch Size:',
                'training.learningRate': 'Learning Rate:',
                'training.evaluate': 'Test setì—ì„œ í‰ê°€',
                'training.start': 'â–¶ í•™ìŠµ ì‹œì‘',
                'training.stop': 'â¹ ì¤‘ì§€',
                'training.log': 'í•™ìŠµ ë¡œê·¸',
                'training.ready': 'í•™ìŠµ ì‹œì‘ ì¤€ë¹„ ì™„ë£Œ...',

                // ì¶”ë¡ 
                'inference.title': 'ë¹„ë””ì˜¤ ì¶”ë¡ ',
                'inference.settings': 'ì¶”ë¡  ì„¤ì •',
                'inference.modelType': 'ëª¨ë¸ íƒ€ì…',
                'inference.modelFile': 'ëª¨ë¸ íŒŒì¼',
                'inference.modelPath': 'ëª¨ë¸ ê²½ë¡œ',
                'inference.videoFile': 'ë¹„ë””ì˜¤ íŒŒì¼',
                'inference.videoPath': 'ë¹„ë””ì˜¤ ê²½ë¡œ',
                'inference.outputDir': 'ì¶œë ¥ ë””ë ‰í† ë¦¬',
                'inference.confidence': 'Confidence ì„ê³„ê°’',
                'inference.start': 'â–¶ï¸ ì¶”ë¡  ì‹œì‘',
                'inference.cancel': 'âŒ ì·¨ì†Œ',
                'inference.results': 'ğŸ¥ ì‹¤ì‹œê°„ ì¶”ë¡  ê²°ê³¼',
                'inference.progress': 'ì§„í–‰ ìƒí™©',
                'inference.preparing': 'ì¤€ë¹„ ì¤‘...'
            },
            en: {
                // App Title & Tabs
                'app.title': 'ğŸ’§ K-Water Annotation System',
                'tab.project': 'ğŸ“‚ Project',
                'tab.annotation': 'ğŸ“¹ Annotation',
                'tab.dataset': 'ğŸ“¦ Dataset',
                'tab.training': 'ğŸš€ Training',
                'tab.inference': 'ğŸ¬ Inference',
                'tab.admin': 'ğŸ‘¥ Admin',

                // Common
                'common.close': 'âœ– Close',
                'common.save': 'ğŸ’¾ Save',
                'common.delete': 'ğŸ—‘ Delete',
                'common.edit': 'âœï¸ Edit',
                'common.add': 'â• Add',
                'common.cancel': 'Cancel',
                'common.settings': 'âš™ï¸ Settings',
                'common.refresh': 'ğŸ”„ Refresh',

                // Project
                'project.title': 'Project Management',
                'project.current': 'Current Project',
                'project.createNew': 'Create New Project',
                'project.create': 'â• Create Project',
                'project.name': 'Project Name',
                'project.worker': 'Worker Name',
                'project.videos': 'Project Videos',
                'project.addVideo': 'â• Add Video',
                'project.noVideos': 'No videos available.',
                'project.list': 'Project List',
                'project.loading': 'Loading project list...',
                'project.namePlaceholder': 'Project Name (Required)',
                'project.workerPlaceholder': 'Worker Name (Optional)',

                // Annotation
                'annotation.title': 'Video Annotation',
                'annotation.help': 'Help',
                'annotation.project': 'Project',
                'annotation.video': 'Video',
                'annotation.noProject': 'No project selected',
                'annotation.noVideo': 'No video selected',
                'annotation.aiStatus': 'AI Status',
                'annotation.checking': 'Checking...',
                'annotation.autoInference': 'Auto-inference enabled',
                'annotation.labelSelection': 'Label Selection',
                'annotation.selectProject': 'Select a project',
                'annotation.drawingMode': 'Drawing Mode',
                'annotation.manualPolygon': 'ğŸ–Šï¸ Manual Polygon (OFF)',
                'annotation.annotations': 'Annotations',
                'annotation.videoPlayer': 'Video Player',
                'annotation.currentFrame': 'Current Frame',
                'annotation.noAnnotations': 'No annotations',
                'annotation.saveFrame': 'ğŸ’¾ Save Frame',
                'annotation.clearFrame': 'Clear Frame',
                'annotation.statistics': 'Statistics',
                'annotation.noSavedAnnotations': 'No saved annotations',
                'annotation.comment': 'Comment',
                'annotation.selectAnnotationForComment': 'Select an annotation to add a comment',
                'annotation.saveComment': 'ğŸ’¬ Save Comment',
                'annotation.play': 'â–¶ Play',
                'annotation.prev': 'â—€ Prev',
                'annotation.next': 'Next â–¶',
                'annotation.skip15Back': 'âª -15s',
                'annotation.skip15Forward': '+15s â©',
                'annotation.speed': 'Speed:',

                // Help
                'help.basicUsage': 'Basic Usage',
                'help.step1': 'Create or select a project from the Project tab.',
                'help.step2': 'Add videos and navigate to the Annotation tab.',
                'help.step3': 'Select a label from the left panel.',
                'help.step4': 'Review AI inference results or manually draw polygons.',
                'help.step5': 'Save completed frames using the "ğŸ’¾ Save Frame" button.',
                'help.shortcuts': 'Keyboard Shortcuts',
                'help.key': 'Key',
                'help.action': 'Action',
                'help.playPause': 'Play / Pause',
                'help.prevFrame': 'Previous Frame',
                'help.nextFrame': 'Next Frame',
                'help.saveFrame': 'Save Current Frame',
                'help.deleteAnnotation': 'Delete Selected Annotation',
                'help.cancelDrawing': 'Cancel Polygon Drawing',
                'help.drawingModes': 'Drawing Modes',
                'help.aiMode': 'ğŸ¤– AI Auto-Inference',
                'help.aiModeDesc': 'AI automatically detects and displays regions when navigating frames.',
                'help.manualMode': 'âœï¸ Manual Polygon',
                'help.manualModeDesc': 'Click to place points and draw polygons. Double-click or click first point to complete.',
                'help.crosshairMode': 'â• Crosshair',
                'help.crosshairModeDesc': 'Display crosshair guide for precise positioning.',
                'help.tips': 'Useful Tips',
                'help.tip1': 'If AI inference results are inaccurate, you can manually correct or redraw.',
                'help.tip2': 'Unsaved frames will lose their annotation data.',
                'help.tip3': 'You can add multiple video files at once (Ctrl/Cmd + Click).',
                'help.tip4': 'Add or modify classes (labels) in Project Settings.',
                'help.tip5': 'Check overall progress in the Statistics panel.',

                // Dataset
                'dataset.title': 'Dataset Builder',
                'dataset.projectInfo': 'Project Information',
                'dataset.noProject': 'No project selected.',
                'dataset.selectVideos': 'Select Videos',
                'dataset.selectProjectFirst': 'Please select a project first.',
                'dataset.selectAll': 'Select All',
                'dataset.deselectAll': 'Deselect All',
                'dataset.settings': 'Dataset Settings',
                'dataset.outputDir': 'Output Directory:',
                'dataset.splitRatio': 'Train/Val/Test Ratio:',
                'dataset.augmentation': 'Augmentation Multiplier:',
                'dataset.format': 'Dataset Format:',
                'dataset.build': 'ğŸš€ Build Dataset',
                'dataset.exportSegFormer': 'ğŸ¯ Export SegFormer',
                'dataset.exportYOLO': 'ğŸ“¦ Export YOLO',
                'dataset.buildLog': 'Build Log',
                'dataset.ready': 'Ready to build dataset...',

                // Training
                'training.title': 'Model Training',
                'training.modelType': 'Model Type',
                'training.dataset': 'Dataset',
                'training.browse': 'Browse...',
                'training.settings': 'Training Settings',
                'training.outputDir': 'Output Directory:',
                'training.epochs': 'Epochs:',
                'training.batchSize': 'Batch Size:',
                'training.learningRate': 'Learning Rate:',
                'training.evaluate': 'Evaluate on test set',
                'training.start': 'â–¶ Start Training',
                'training.stop': 'â¹ Stop',
                'training.log': 'Training Log',
                'training.ready': 'Ready to start training...',

                // Inference
                'inference.title': 'Video Inference',
                'inference.settings': 'Inference Settings',
                'inference.modelType': 'Model Type',
                'inference.modelFile': 'Model File',
                'inference.modelPath': 'Model Path',
                'inference.videoFile': 'Video File',
                'inference.videoPath': 'Video Path',
                'inference.outputDir': 'Output Directory',
                'inference.confidence': 'Confidence Threshold',
                'inference.start': 'â–¶ï¸ Start Inference',
                'inference.cancel': 'âŒ Cancel',
                'inference.results': 'ğŸ¥ Real-time Inference Results',
                'inference.progress': 'Progress',
                'inference.preparing': 'Preparing...'
            }
        };

        // ì–¸ì–´ í† ê¸€ í•¨ìˆ˜
        function toggleLanguage() {
            const oldLang = currentLanguage;
            currentLanguage = currentLanguage === 'ko' ? 'en' : 'ko';
            localStorage.setItem('language', currentLanguage);
            console.log('[LANG] Language toggled:', oldLang, '->', currentLanguage);

            applyLanguage();

            // í† ê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
            const btn2 = document.getElementById('langToggleBtn2');
            if (btn2) {
                btn2.textContent = currentLanguage === 'ko' ? 'ğŸŒ EN' : 'ğŸŒ í•œê¸€';
            }

            // í´ë˜ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸ (í˜„ì¬ í”„ë¡œì íŠ¸ê°€ ìˆëŠ” ê²½ìš°)
            if (currentProject && currentProject.classes) {
                console.log('[LANG] Updating class displays for project:', currentProject.name);

                // ì„¤ì • ëª¨ë‹¬ í´ë˜ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸
                if (typeof updateSettingsClassList === 'function') {
                    updateSettingsClassList();
                }

                // ì–´ë…¸í…Œì´ì…˜ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                if (typeof updateAnnotationList === 'function') {
                    updateAnnotationList();
                }

                // Statistics í…Œì´ë¸” ì—…ë°ì´íŠ¸
                if (typeof updateStatistics === 'function') {
                    updateStatistics();
                }

                // ìº”ë²„ìŠ¤ì˜ ì–´ë…¸í…Œì´ì…˜ ë¼ë²¨ë„ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                if (typeof drawFrameWithMasks === 'function' && currentFrame !== null) {
                    drawFrameWithMasks();
                }
            } else {
                console.log('[LANG] No current project or classes');
            }
        }

        // ì–¸ì–´ ì ìš© í•¨ìˆ˜
        function applyLanguage() {
            // í…ìŠ¤íŠ¸ ë²ˆì—­
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = translations[currentLanguage][key];
                if (translation) {
                    element.textContent = translation;
                }
            });

            // Placeholder ë²ˆì—­
            const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
            placeholderElements.forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                const translation = translations[currentLanguage][key];
                if (translation) {
                    element.placeholder = translation;
                }
            });

            console.log('[I18N] Language applied:', currentLanguage);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì–¸ì–´ ì ìš©
        document.addEventListener('DOMContentLoaded', function() {
            applyLanguage();
            const btn2 = document.getElementById('langToggleBtn2');
            if (btn2) {
                btn2.textContent = currentLanguage === 'ko' ? 'ğŸŒ EN' : 'ğŸŒ í•œê¸€';
            }

            // í´ë¦¬ê³¤ ëª¨ë“œê°€ ê¸°ë³¸ê°’ì´ë¯€ë¡œ ì»¤ì„œ ìŠ¤íƒ€ì¼ ì ìš©
            const canvas = document.getElementById('videoCanvas');
            if (canvas) {
                canvas.classList.add('crosshair-cursor');
            }
        });

        // í´ë˜ìŠ¤ ì´ë¦„ í‘œì‹œìš© helper í•¨ìˆ˜ (ì–¸ì–´ì— ë”°ë¼ name/description ì„ íƒ)
        function getClassDisplayName(classObj) {
            if (currentLanguage === 'ko') {
                return classObj.description || classObj.name;
            } else {
                return classObj.name;
            }
        }

        // ìº”ë²„ìŠ¤ ë¼ë²¨ í‘œì‹œìš© helper í•¨ìˆ˜ (category nameì„ í˜„ì¬ ì–¸ì–´ì˜ í‘œì‹œëª…ìœ¼ë¡œ ë³€í™˜)
        function getDisplayLabel(categoryName) {
            if (!currentProject || !currentProject.classes) return categoryName;

            // í´ë˜ìŠ¤ ì°¾ê¸° (ë¬¸ìì—´ ë°°ì—´ì¼ ìˆ˜ë„ ìˆê³ , ê°ì²´ ë°°ì—´ì¼ ìˆ˜ë„ ìˆìŒ)
            const classObj = currentProject.classes.find(c => {
                if (typeof c === 'string') return c === categoryName;
                return c.name === categoryName;
            });

            if (!classObj) return categoryName;

            // ë¬¸ìì—´ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
            if (typeof classObj === 'string') return classObj;

            // ê°ì²´ë©´ ì–¸ì–´ì— ë”°ë¼ í‘œì‹œ
            return getClassDisplayName(classObj);
        }

        // ============================================
        // ì¸ì¦ ê´€ë¦¬
        // ============================================

        // ì„¸ì…˜ ID ì €ì¥/ê°€ì ¸ì˜¤ê¸°
        function getSessionId() {
            return localStorage.getItem('session_id');
        }

        function setSessionId(sessionId) {
            localStorage.setItem('session_id', sessionId);
            // Also set as cookie for video element authentication
            document.cookie = `session_id=${sessionId}; path=/; SameSite=Strict`;
        }

        function clearSessionId() {
            localStorage.removeItem('session_id');
            // Also clear cookie
            document.cookie = 'session_id=; path=/; expires=Thu, 01 Jan 1970 00:00:00 UTC; SameSite=Strict';
        }

        // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì €ì¥/ê°€ì ¸ì˜¤ê¸°
        function getCurrentUser() {
            const userJson = localStorage.getItem('current_user');
            return userJson ? JSON.parse(userJson) : null;
        }

        function setCurrentUser(user) {
            localStorage.setItem('current_user', JSON.stringify(user));
        }

        function clearCurrentUser() {
            localStorage.removeItem('current_user');
        }

        // ë¡œê·¸ì¸ ì²˜ë¦¬
        async function handleLogin(event) {
            event.preventDefault();

            const userId = document.getElementById('loginUserId').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            try {
                const response = await fetch(API_BASE_URL + '/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        password: password
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // ì„¸ì…˜ IDì™€ ì‚¬ìš©ì ì •ë³´ ì €ì¥
                    setSessionId(data.session_id);
                    setCurrentUser(data.user);

                    // ë¡œê·¸ì¸ ì„±ê³µ
                    console.log('[AUTH] Login successful:', data.user);
                    showLoginSuccess();
                } else {
                    // ë¡œê·¸ì¸ ì‹¤íŒ¨
                    errorDiv.textContent = data.error || 'ë¡œê·¸ì¸ ì‹¤íŒ¨';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('[AUTH] Login error:', error);
                errorDiv.textContent = 'ì„œë²„ ì—°ê²° ì˜¤ë¥˜: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
        async function handleLogout() {
            const sessionId = getSessionId();

            if (sessionId) {
                try {
                    await fetch(API_BASE_URL + '/api/auth/logout', {
                        method: 'POST',
                        headers: {
                            'X-Session-ID': sessionId
                        }
                    });
                } catch (error) {
                    console.error('[AUTH] Logout error:', error);
                }
            }

            // ë¡œì»¬ ë°ì´í„° ì •ë¦¬
            clearSessionId();
            clearCurrentUser();

            // ë¡œê·¸ì¸ í™”ë©´ í‘œì‹œ
            showLoginScreen();
        }

        // ë¡œê·¸ì¸ ì„±ê³µ í›„ UI ì—…ë°ì´íŠ¸
        function showLoginSuccess() {
            const user = getCurrentUser();
            console.log('[LOGIN SUCCESS] Current user:', user);
            console.log('[LOGIN SUCCESS] User role:', user ? user.role : 'undefined');

            if (!user) {
                console.error('[LOGIN SUCCESS] No user data found!');
                return;
            }

            // ë¡œê·¸ì¸ í™”ë©´ ìˆ¨ê¸°ê¸°
            document.getElementById('loginOverlay').style.display = 'none';

            // ì‚¬ìš©ì ì •ë³´ í‘œì‹œ
            document.getElementById('userName').textContent = user.full_name || user.user_id;
            document.getElementById('userInfo').style.display = 'flex';

            // ê´€ë¦¬ì íƒ­ í‘œì‹œ (ê´€ë¦¬ìë§Œ)
            const adminTab = document.getElementById('adminTab');
            console.log('[LOGIN SUCCESS] Admin tab element:', adminTab);

            if (user.role === 'admin') {
                console.log('[LOGIN SUCCESS] User is admin - showing admin tab');
                adminTab.style.display = 'block';
            } else {
                console.log('[LOGIN SUCCESS] User is NOT admin - hiding admin tab');
                adminTab.style.display = 'none';
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì´ˆê¸°í™” (ìƒˆë¡œìš´ ì‚¬ìš©ìì´ë¯€ë¡œ)
            currentProject = null;

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            const currentProjectSection = document.getElementById('currentProjectSection');
            if (currentProjectSection) {
                currentProjectSection.style.display = 'none';
            }

            const currentProjectDiv = document.getElementById('currentProject');
            if (currentProjectDiv) {
                currentProjectDiv.innerHTML = '<p style="color: #999;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
            }

            // í”„ë¡œì íŠ¸ íƒ­ìœ¼ë¡œ ì´ë™
            console.log('[LOGIN SUCCESS] Switching to project tab');
            showTab('project');

            // ê´€ë¦¬ìì™€ ì¼ë°˜ ì‚¬ìš©ì ëª¨ë‘ í”„ë¡œì íŠ¸ ëª©ë¡ í‘œì‹œ
            console.log('[LOGIN SUCCESS] Loading projects for user:', user.user_id);
            loadProjects();  // í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ (ê´€ë¦¬ìëŠ” ëª¨ë“  í”„ë¡œì íŠ¸, ì¼ë°˜ ì‚¬ìš©ìëŠ” ìì‹ ì˜ í”„ë¡œì íŠ¸)
        }

        // ë¡œê·¸ì¸ í™”ë©´ í‘œì‹œ
        function showLoginScreen() {
            document.getElementById('loginOverlay').style.display = 'flex';
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('loginError').style.display = 'none';
            document.getElementById('loginForm').reset();

            // ë¡œê·¸ì•„ì›ƒ ì‹œ ê´€ë¦¬ì íƒ­ ìˆ¨ê¸°ê¸°
            document.getElementById('adminTab').style.display = 'none';

            // í”„ë¡œì íŠ¸ ëª©ë¡ í´ë¦¬ì–´
            const myProjectList = document.getElementById('myProjectList');
            const sharedProjectList = document.getElementById('sharedProjectList');
            if (myProjectList) {
                myProjectList.innerHTML = '<p style="color: #999;">ë¡œê·¸ì¸ í›„ í™•ì¸í•˜ì„¸ìš”.</p>';
            }
            if (sharedProjectList) {
                sharedProjectList.innerHTML = '<p style="color: #999;">ë¡œê·¸ì¸ í›„ í™•ì¸í•˜ì„¸ìš”.</p>';
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ í´ë¦¬ì–´
            currentProject = null;

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            const currentProjectSection = document.getElementById('currentProjectSection');
            if (currentProjectSection) {
                currentProjectSection.style.display = 'none';
            }

            const currentProjectDiv = document.getElementById('currentProject');
            if (currentProjectDiv) {
                currentProjectDiv.innerHTML = '<p style="color: #999;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
            }

            // í”„ë¡œì íŠ¸ íƒ­ìœ¼ë¡œ ì „í™˜ (ê¸°ë³¸ íƒ­)
            showTab('project');
        }

        // ì„¸ì…˜ ê²€ì¦
        async function validateSession() {
            const sessionId = getSessionId();

            if (!sessionId) {
                showLoginScreen();
                return false;
            }

            try {
                const response = await fetch(API_BASE_URL + '/api/auth/me', {
                    headers: {
                        'X-Session-ID': sessionId
                    }
                });

                const data = await response.json();

                if (data.success) {
                    // ì„¸ì…˜ ìœ íš¨ - ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
                    setCurrentUser(data.user);
                    showLoginSuccess();
                    return true;
                } else {
                    // ì„¸ì…˜ ë¬´íš¨
                    clearSessionId();
                    clearCurrentUser();
                    showLoginScreen();
                    return false;
                }
            } catch (error) {
                console.error('[AUTH] Session validation error:', error);
                showLoginScreen();
                return false;
            }
        }

        // API ìš”ì²­ í—¬í¼ (ìë™ìœ¼ë¡œ ì„¸ì…˜ ID í¬í•¨)
        async function authFetch(url, options = {}) {
            console.log('[authFetch] Starting request to:', url);
            const sessionId = getSessionId();

            if (!sessionId) {
                console.error('[authFetch] No session ID found');
                showLoginScreen();
                throw new Error('Not authenticated');
            }

            options.headers = {
                ...options.headers,
                'X-Session-ID': sessionId
            };

            console.log('[authFetch] Fetching:', API_BASE_URL + url);
            const response = await fetch(API_BASE_URL + url, options);
            console.log('[authFetch] Response received:', response.status, response.statusText);

            // 401 Unauthorized ì²˜ë¦¬
            if (response.status === 401) {
                console.warn('[AUTH] Session expired or invalid');
                clearSessionId();
                clearCurrentUser();
                showLoginScreen();
                throw new Error('Session expired');
            }

            return response;
        }

        function showTab(tabName) {
            // ëª¨ë“  íƒ­ ì»¨í…ì¸  ë¹„í™œì„±í™”
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');

            // ì„ íƒëœ íƒ­ ì»¨í…ì¸  í™œì„±í™”
            document.getElementById(tabName + '-tab').style.display = 'block';

            // íƒ­ ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

            // í´ë¦­ ì´ë²¤íŠ¸ë¡œ í˜¸ì¶œëœ ê²½ìš°
            if (window.event && window.event.target) {
                window.event.target.classList.add('active');
            } else {
                // í”„ë¡œê·¸ë¨ì ìœ¼ë¡œ í˜¸ì¶œëœ ê²½ìš° - íƒ­ ì´ë¦„ìœ¼ë¡œ ë²„íŠ¼ ì°¾ê¸°
                const tabButtons = document.querySelectorAll('.tab');
                const tabIndex = {'project': 0, 'annotation': 1, 'dataset': 2, 'training': 3, 'inference': 4, 'admin': 5};
                if (tabIndex[tabName] !== undefined) {
                    tabButtons[tabIndex[tabName]].classList.add('active');
                }
            }

            // ê´€ë¦¬ì íƒ­ í´ë¦­ ì‹œ ë°ì´í„° ë¡œë“œ
            if (tabName === 'admin') {
                loadUsers();
                loadSystemStats();
            }

            // í”„ë¡œì íŠ¸ íƒ­ í´ë¦­ ì‹œ ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ ìë™ ë¡œë“œ
            if (tabName === 'project') {
                loadCommentsDashboard();
            }

            // ê´€ë¦¬ì ì‚¬ìš©ìê°€ í”„ë¡œì íŠ¸/ì–´ë…¸í…Œì´ì…˜ íƒ­ í´ë¦­ ì‹œ ê´€ë¦¬ììš© ë°ì´í„° ë¡œë“œ
            const user = getCurrentUser();
            if (user && user.role === 'admin') {
                if (tabName === 'project') {
                    loadAdminCompletedVideos();
                } else if (tabName === 'annotation') {
                    loadAdminAnnotationStats();
                }
            }
        }

        // API Base URL ì„¤ì •
        // Electron (file://): localhost:5003 ì‚¬ìš©
        // ì›¹ ë¸Œë¼ìš°ì €: í˜„ì¬ ì„œë²„ ì£¼ì†Œ ì‚¬ìš© (ìë™ìœ¼ë¡œ localhost ë˜ëŠ” ì™¸ë¶€ IP)
        const isElectron = (window.location.protocol === 'file:');
        const API_BASE_URL = isElectron
            ? 'http://localhost:5003'
            : `${window.location.protocol}//${window.location.host}`;

        console.log('[DEBUG] API_BASE_URL:', API_BASE_URL);
        console.log('[DEBUG] Location:', window.location.protocol, window.location.host);

        async function testPython() {
            try {
                const response = await fetch(API_BASE_URL + '/api/test');
                const data = await response.json();
                document.getElementById('status').innerHTML =
                    '<strong>[OK] Python Backend Connected!</strong><br>' +
                    'Message: ' + data.message + '<br>' +
                    'Python Version: ' + data.python_version;
            } catch (error) {
                document.getElementById('status').innerHTML =
                    '<strong>[ERROR] Error:</strong> ' + error.message + '<br>' +
                    'Check if backend server is running (python backend.py)';
            }
        }

        // ì „ì—­ ë³€ìˆ˜
        let currentProject = null;
        let selectedStatsFrame = null;  // í†µê³„ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì„ íƒëœ í”„ë ˆì„
        let currentJobId = null;  // í˜„ì¬ ì¶”ë¡  ì‘ì—… ID
        let progressInterval = null;  // ì§„í–‰ ìƒí™© í´ë§ ì¸í„°ë²Œ
        let previewInterval = null;  // ë¯¸ë¦¬ë³´ê¸° í”„ë ˆì„ í´ë§ ì¸í„°ë²Œ
        let inferencePreviewCanvas = null;  // ì¶”ë¡  ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤
        let inferencePreviewCtx = null;  // ì¶”ë¡  ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸

        // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ìƒíƒœ
        let playerState = {
            isPlaying: false,
            currentFrameIndex: 0,
            totalFrames: 0,
            processedFrames: 0,
            fps: 30,
            playbackSpeed: 1.0,
            playbackInterval: null,
            frameCache: new Map()  // í”„ë ˆì„ ì´ë¯¸ì§€ ìºì‹œ
        };

        // ============================================
        // ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ ê¸°ëŠ¥
        // ============================================

        // ë‹µê¸€ ë°ì´í„° ì €ì¥ (comment_id -> replies ë°°ì—´)
        const repliesData = new Map();

        // ì „ì—­ ë³€ìˆ˜ë¡œ ëª¨ë“  ì½”ë©˜íŠ¸ ì €ì¥
        let allComments = [];

        // ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ ìƒíƒœ (true: ë³´ì„, false: ìˆ¨ê¹€)
        let showAnnotations = true;

        // ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ ë¶ˆëŸ¬ì˜¤ê¸°
        async function loadCommentsDashboard() {
            const dashboard = document.getElementById('commentsDashboard');

            try {
                dashboard.innerHTML = '<span style="color: #888;">ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>';

                const response = await fetch(`${API_BASE_URL}/api/comments/all`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    allComments = data.comments || [];
                    filterComments(); // í•„í„° ì ìš© í›„ í‘œì‹œ
                } else {
                    dashboard.innerHTML = '<span style="color: #f44;">ì˜¤ë¥˜: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜') + '</span>';
                }
            } catch (error) {
                console.error('ì½”ë©˜íŠ¸ ë¡œë“œ ì˜¤ë¥˜:', error);
                dashboard.innerHTML = '<span style="color: #f44;">ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message + '</span>';
            }
        }

        // ì½”ë©˜íŠ¸ í•„í„°ë§ ë° í‘œì‹œ
        function filterComments() {
            const dashboard = document.getElementById('commentsDashboard');
            const projectFilter = document.getElementById('commentFilterProject')?.value.toLowerCase() || '';
            const userFilter = document.getElementById('commentFilterUser')?.value.toLowerCase() || '';
            const labelFilter = document.getElementById('commentFilterLabel')?.value.toLowerCase() || '';
            const sortBy = document.getElementById('commentSortBy')?.value || 'recent';

            // í•„í„° ì ìš©
            let filtered = allComments.filter(comment => {
                const matchProject = !projectFilter || comment.project_name.toLowerCase().includes(projectFilter);
                const matchUser = !userFilter || comment.created_by.toLowerCase().includes(userFilter);
                const matchLabel = !labelFilter || comment.label.toLowerCase().includes(labelFilter);
                return matchProject && matchUser && matchLabel;
            });

            // ì •ë ¬
            if (sortBy === 'recent') {
                // ëŒ“ê¸€ ìˆ˜ì • ì‹œê°„(modified_at) ìš°ì„ , ì—†ìœ¼ë©´ ì–´ë…¸í…Œì´ì…˜ ìƒì„± ì‹œê°„(created_at) ì‚¬ìš©
                filtered.sort((a, b) => {
                    const timeA = a.modified_at || a.created_at || '';
                    const timeB = b.modified_at || b.created_at || '';
                    return timeB.localeCompare(timeA);
                });
            } else if (sortBy === 'project') {
                filtered.sort((a, b) => a.project_name.localeCompare(b.project_name));
            } else if (sortBy === 'user') {
                filtered.sort((a, b) => a.created_by.localeCompare(b.created_by));
            }

            // í‘œì‹œ
            if (filtered.length === 0) {
                dashboard.innerHTML = '<span style="color: #888;">í‘œì‹œí•  ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</span>';
                return;
            }

            // ì–´ë…¸í…Œì´ì…˜ì„ ê·¸ë¦¬ê¸° ìœ„í•œ íƒ€ì´ë¨¸
            const annotationDrawTimer = setTimeout(() => {
                filtered.forEach((comment, displayIndex) => {
                    // ì›ë³¸ allComments ë°°ì—´ì—ì„œì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ì°¾ê¸°
                    const actualIndex = allComments.findIndex(c => c.comment_id === comment.comment_id);
                    drawAnnotationOnCanvas(comment, actualIndex);
                });
            }, 100);

            dashboard.innerHTML = filtered.map((comment, displayIndex) => {
                // ì›ë³¸ allComments ë°°ì—´ì—ì„œì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ì°¾ê¸°
                const actualIndex = allComments.findIndex(c => c.comment_id === comment.comment_id);
                const index = actualIndex; // ì´í›„ ì½”ë“œì—ì„œ index ì‚¬ìš©

                const statusColors = {
                    'open': '#4a9eff',
                    'resolved': '#28a745',
                    'pending': '#ffa500'
                };
                const statusLabels = {
                    'open': 'ì§„í–‰ì¤‘',
                    'resolved': 'í•´ê²°ë¨',
                    'pending': 'ë³´ë¥˜'
                };
                const statusColor = statusColors[comment.discussion_status || 'open'];
                const statusLabel = statusLabels[comment.discussion_status || 'open'];

                return `
                <div id="comment-card-${index}" style="background: #2a2a2a; border-left: 3px solid ${statusColor}; padding: 12px; margin-bottom: 10px; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <div>
                            <span style="color: #4a9eff; font-weight: bold;">${comment.project_name}</span>
                            <span style="color: #888; margin-left: 10px;">í”„ë ˆì„: ${comment.frame}</span>
                            <span style="background: ${statusColor}; color: white; padding: 2px 6px; margin-left: 10px; border-radius: 3px; font-size: 11px;">${statusLabel}</span>
                        </div>
                        <div style="font-size: 11px; color: #888;">
                            ${comment.created_at ? new Date(comment.created_at).toLocaleString() : ''}
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <span style="background: #1a1a1a; padding: 2px 8px; border-radius: 3px; font-size: 12px; color: #ffa500;">${comment.label}</span>
                        <span style="color: #888; margin-left: 10px; font-size: 12px;">ì‘ì„±ì: ${comment.created_by}</span>
                    </div>
                    <div style="background: #1a1a1a; padding: 8px; border-radius: 3px; margin-bottom: 8px; white-space: pre-wrap;">
                        ${comment.comment}
                    </div>

                    <!-- ì´ë¯¸ì§€ì™€ ì»¨íŠ¸ë¡¤ì„ ë‚˜ë€íˆ ë°°ì¹˜ -->
                    <div style="display: flex; gap: 15px; margin-bottom: 8px; align-items: flex-start;">
                        <!-- ì™¼ìª½: í”„ë ˆì„ ì´ë¯¸ì§€ ë° ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ -->
                        <div style="flex-shrink: 0;">
                            <div style="position: relative; display: inline-block; max-width: 400px; background: #000; border-radius: 4px; overflow: hidden;">
                                <img
                                    src="${API_BASE_URL}${comment.frame_url}?token=${encodeURIComponent(localStorage.getItem('session_id'))}"
                                    alt="Frame ${comment.frame}"
                                    style="width: 100%; height: auto; display: block;"
                                    onerror="this.onerror=null; this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22300%22><rect width=%22100%25%22 height=%22100%25%22 fill=%22%23333%22/><text x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23888%22>ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨</text></svg>';"
                                />
                                ${comment.polygon || comment.box ? `
                                    <canvas
                                        id="annotation-canvas-${index}"
                                        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"
                                    ></canvas>
                                ` : ''}
                            </div>
                            <div style="font-size: 12px; color: #888; margin-top: 8px;">
                                ë¹„ë””ì˜¤: ${comment.video_id} | í”„ë¡œì íŠ¸ ì†Œìœ ì: ${comment.project_owner}
                            </div>
                        </div>

                        <!-- ì˜¤ë¥¸ìª½: ë‹µê¸€ ë²„íŠ¼, ìƒíƒœ ë³€ê²½ ë° ë‹µê¸€ ë¦¬ìŠ¤íŠ¸ -->
                        <div style="display: flex; flex-direction: column; gap: 8px; flex: 1; min-width: 0;">
                            <!-- ë²„íŠ¼ ì˜ì—­ -->
                            <div style="display: flex; gap: 8px;">
                                <button id="reply-btn-${comment.comment_id}" onclick="toggleReplies('${comment.comment_id}')" style="background: #1a1a1a; color: #4a9eff; border: 1px solid #4a9eff; padding: 8px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                    ğŸ’¬ ë‹µê¸€ (${comment.replies_count || 0})
                                </button>
                                <select onchange="updateDiscussionStatus('${comment.comment_id}', this.value)" style="background: #1a1a1a; color: white; border: 1px solid #555; padding: 8px; border-radius: 3px; font-size: 12px;">
                                    <option value="open" ${comment.discussion_status === 'open' ? 'selected' : ''}>ì§„í–‰ì¤‘</option>
                                    <option value="pending" ${comment.discussion_status === 'pending' ? 'selected' : ''}>ë³´ë¥˜</option>
                                    <option value="resolved" ${comment.discussion_status === 'resolved' ? 'selected' : ''}>í•´ê²°ë¨</option>
                                </select>
                            </div>

                            <!-- ë‹µê¸€ ì„¹ì…˜ (ìˆ¨ê¹€ ìƒíƒœë¡œ ì‹œì‘) -->
                            <div id="replies-section-${comment.comment_id}" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 4px;">
                                <div id="replies-list-${comment.comment_id}" style="margin-bottom: 10px; max-height: 300px; overflow-y: auto;">
                                    <span style="color: #888;">ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                                </div>

                                <!-- ë‹µê¸€ ì‘ì„± í¼ -->
                                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
                                    <textarea id="reply-input-${comment.comment_id}" placeholder="ë‹µê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..." style="width: 100%; min-height: 60px; background: #2a2a2a; color: white; border: 1px solid #555; padding: 8px; border-radius: 3px; resize: vertical; font-family: inherit; box-sizing: border-box;"></textarea>
                                    <button onclick="submitReply('${comment.comment_id}')" style="margin-top: 8px; background: #4a9eff; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                                        ë‹µê¸€ ì‘ì„±
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `}).join('');
        }

        // ============================================
        // í† ë¡  ê¸°ëŠ¥ í•¨ìˆ˜ë“¤
        // ============================================

        // ë‹µê¸€ ì„¹ì…˜ í† ê¸€
        function toggleReplies(commentId) {
            const repliesSection = document.getElementById(`replies-section-${commentId}`);
            const currentDisplay = repliesSection.style.display;

            if (currentDisplay === 'none') {
                repliesSection.style.display = 'block';
                loadReplies(commentId);
            } else {
                repliesSection.style.display = 'none';
            }
        }

        // ë‹µê¸€ ë¡œë“œ
        async function loadReplies(commentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }
            const repliesList = document.getElementById(`replies-list-${commentId}`);

            try {
                repliesList.innerHTML = '<span style="color: #888;">ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>';

                const response = await fetch(
                    `${API_BASE_URL}/api/discussions/${comment.comment_id}?project_owner=${encodeURIComponent(comment.project_owner)}&project_name=${encodeURIComponent(comment.project_name_full)}`,
                    {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success && data.thread && data.thread.replies && data.thread.replies.length > 0) {
                    // ë‹µê¸€ ë°ì´í„° ì €ì¥
                    repliesData.set(commentId, data.thread.replies);

                    const currentUser = getCurrentUser();
                    const currentUserId = currentUser ? currentUser.user_id : null;

                    repliesList.innerHTML = data.thread.replies.map((reply, replyIndex) => {
                        const isOwnReply = currentUserId && reply.user_id === currentUserId;

                        return `
                        <div id="reply-${commentId}-${replyIndex}" style="background: #2a2a2a; padding: 10px; margin-bottom: 8px; border-left: 2px solid ${isOwnReply ? '#4a9eff' : '#555'}; border-radius: 3px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div>
                                    <span style="color: #4a9eff; font-size: 12px; font-weight: bold;">${reply.user_id}</span>
                                    ${isOwnReply ? '<span style="color: #4a9eff; font-size: 10px; margin-left: 5px;">(ë‚˜)</span>' : ''}
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="color: #888; font-size: 11px;">${new Date(reply.created_at).toLocaleString()}</span>
                                    ${isOwnReply ? `
                                        <button onclick="editReply('${commentId}', ${replyIndex}, '${comment.comment_id}')" style="background: #555; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">âœï¸ í¸ì§‘</button>
                                        <button onclick="deleteReply('${commentId}', ${replyIndex}, '${comment.comment_id}')" style="background: #dc3545; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">ğŸ—‘ï¸ ì‚­ì œ</button>
                                    ` : ''}
                                </div>
                            </div>
                            <div id="reply-content-${commentId}-${replyIndex}" style="color: #ddd; font-size: 13px; white-space: pre-wrap;">${reply.comment}</div>
                        </div>
                    `}).join('');

                    // ë‹µê¸€ ê°œìˆ˜ ì—…ë°ì´íŠ¸
                    const replyCount = data.thread.replies.length;
                    comment.replies_count = replyCount;
                    const btn = document.getElementById(`reply-btn-${commentId}`);
                    if (btn) {
                        btn.textContent = `ğŸ’¬ ë‹µê¸€ (${replyCount})`;
                    }
                } else {
                    // ë‹µê¸€ ë°ì´í„° ì´ˆê¸°í™”
                    repliesData.set(commentId, []);

                    repliesList.innerHTML = '<span style="color: #888;">ì•„ì§ ë‹µê¸€ì´ ì—†ìŠµë‹ˆë‹¤.</span>';

                    // ë‹µê¸€ì´ ì—†ìœ¼ë©´ ê°œìˆ˜ë¥¼ 0ìœ¼ë¡œ ì—…ë°ì´íŠ¸
                    comment.replies_count = 0;
                    const btn = document.getElementById(`reply-btn-${commentId}`);
                    if (btn) {
                        btn.textContent = `ğŸ’¬ ë‹µê¸€ (0)`;
                    }
                }
            } catch (error) {
                console.error('ë‹µê¸€ ë¡œë“œ ì˜¤ë¥˜:', error);
                repliesList.innerHTML = '<span style="color: #f44;">ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</span>';
            }
        }

        // ë‹µê¸€ ì œì¶œ
        async function submitReply(commentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }
            const replyInput = document.getElementById(`reply-input-${commentId}`);
            const replyText = replyInput.value.trim();

            if (!replyText) {
                alert('ë‹µê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/reply`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        comment_id: comment.comment_id,
                        reply: replyText,
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full,
                        original_comment: {
                            project_id: comment.project_id,
                            video_id: comment.video_id,
                            frame: comment.frame,
                            label: comment.label,
                            comment: comment.comment,
                            created_by: comment.created_by
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    // ì…ë ¥ì°½ ì´ˆê¸°í™”
                    replyInput.value = '';

                    // ë‹µê¸€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await loadReplies(commentId);

                    // ë‹µê¸€ ìˆ˜ ì—…ë°ì´íŠ¸
                    comment.replies_count = data.total_replies;

                    // ë‹µê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    const btn = document.getElementById(`reply-btn-${commentId}`);
                    if (btn) {
                        btn.textContent = `ğŸ’¬ ë‹µê¸€ (${data.total_replies})`;
                    }

                    alert('ë‹µê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    throw new Error(data.error || 'ë‹µê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ë‹µê¸€ ì‘ì„± ì˜¤ë¥˜:', error);
                alert('ë‹µê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // í† ë¡  ìƒíƒœ ì—…ë°ì´íŠ¸
        async function updateDiscussionStatus(commentId, newStatus) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/${comment.comment_id}/status`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full,
                        status: newStatus
                    })
                });

                if (!response.ok) {
                    throw new Error('ìƒíƒœ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    // ìƒíƒœ ì—…ë°ì´íŠ¸
                    comment.discussion_status = newStatus;

                    // UI ìƒˆë¡œê³ ì¹¨
                    filterComments();
                } else {
                    throw new Error(data.error || 'ìƒíƒœ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
                alert('ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);

                // ì˜¤ë¥˜ ë°œìƒ ì‹œ select ë˜ëŒë¦¬ê¸°
                filterComments();
            }
        }

        // ë‹µê¸€ ì‚­ì œ
        async function deleteReply(commentId, replyIndex, originalCommentId) {
            if (!confirm('ì •ë§ë¡œ ì´ ë‹µê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            const replies = repliesData.get(commentId);
            if (!replies || !replies[replyIndex]) {
                console.error('Reply not found');
                return;
            }

            const reply = replies[replyIndex];

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/reply`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        comment_id: originalCommentId,
                        reply_index: replyIndex,
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full
                    })
                });

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    alert('ë‹µê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ë‹µê¸€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await loadReplies(commentId);
                } else {
                    throw new Error(data.error || 'ë‹µê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ë‹µê¸€ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert('ë‹µê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ë‹µê¸€ í¸ì§‘
        async function editReply(commentId, replyIndex, originalCommentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            const replies = repliesData.get(commentId);
            if (!replies || !replies[replyIndex]) {
                console.error('Reply not found');
                return;
            }

            const reply = replies[replyIndex];
            const contentDiv = document.getElementById(`reply-content-${commentId}-${replyIndex}`);
            if (!contentDiv) return;

            // í˜„ì¬ ë‚´ìš© ì €ì¥
            const originalContent = reply.comment;

            // í¸ì§‘ ëª¨ë“œë¡œ ì „í™˜
            contentDiv.innerHTML = `
                <textarea id="edit-reply-input-${commentId}-${replyIndex}"
                          style="width: 100%; min-height: 60px; background: #1a1a1a; color: white; border: 1px solid #555; padding: 8px; border-radius: 3px; resize: vertical; font-family: inherit; box-sizing: border-box;">${originalContent}</textarea>
                <div style="margin-top: 8px; display: flex; gap: 8px;">
                    <button onclick="saveEditedReply('${commentId}', ${replyIndex}, '${originalCommentId}')" style="background: #4a9eff; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">ğŸ’¾ ì €ì¥</button>
                    <button onclick="cancelEditReply('${commentId}', ${replyIndex}, \`${originalContent.replace(/`/g, '\\`')}\`)" style="background: #555; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">âœ– ì·¨ì†Œ</button>
                </div>
            `;

            // í¸ì§‘ ì¤‘ì—ëŠ” í¸ì§‘/ì‚­ì œ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
            const replyDiv = document.getElementById(`reply-${commentId}-${replyIndex}`);
            const buttons = replyDiv.querySelectorAll('button[onclick^="editReply"], button[onclick^="deleteReply"]');
            buttons.forEach(btn => btn.style.display = 'none');
        }

        // í¸ì§‘ ì·¨ì†Œ
        function cancelEditReply(commentId, replyIndex, originalContent) {
            const contentDiv = document.getElementById(`reply-content-${commentId}-${replyIndex}`);
            if (!contentDiv) return;

            // ì›ë˜ ë‚´ìš©ìœ¼ë¡œ ë³µì›
            contentDiv.innerHTML = originalContent;

            // í¸ì§‘/ì‚­ì œ ë²„íŠ¼ ë‹¤ì‹œ í‘œì‹œ
            const replyDiv = document.getElementById(`reply-${commentId}-${replyIndex}`);
            const buttons = replyDiv.querySelectorAll('button[onclick^="editReply"], button[onclick^="deleteReply"]');
            buttons.forEach(btn => btn.style.display = '');
        }

        // í¸ì§‘ëœ ë‹µê¸€ ì €ì¥
        async function saveEditedReply(commentId, replyIndex, originalCommentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            const textarea = document.getElementById(`edit-reply-input-${commentId}-${replyIndex}`);
            if (!textarea) return;

            const newContent = textarea.value.trim();

            if (!newContent) {
                alert('ë‹µê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/reply`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        comment_id: originalCommentId,
                        reply_index: replyIndex,
                        new_comment: newContent,
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full
                    })
                });

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    alert('ë‹µê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ë‹µê¸€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await loadReplies(commentId);
                } else {
                    throw new Error(data.error || 'ë‹µê¸€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ë‹µê¸€ ìˆ˜ì • ì˜¤ë¥˜:', error);
                alert('ë‹µê¸€ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
        function drawAnnotationOnCanvas(comment, index) {
            const canvas = document.getElementById(`annotation-canvas-${index}`);
            if (!canvas) return;

            const card = document.getElementById(`comment-card-${index}`);
            if (!card) return;

            const img = card.querySelector('img');
            if (!img) return;

            // ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
            const drawOnLoad = () => {
                const ctx = canvas.getContext('2d');

                // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì´ë¯¸ì§€ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                // ìº”ë²„ìŠ¤ë¥¼ ì´ˆê¸°í™”
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ì–´ë…¸í…Œì´ì…˜ì´ ìˆ¨ê¹€ ìƒíƒœë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (!showAnnotations) {
                    return;
                }

                // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
                if (comment.polygon && Array.isArray(comment.polygon) && comment.polygon.length > 0) {
                    ctx.strokeStyle = '#00ff00';  // ì´ˆë¡ìƒ‰
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';  // ë°˜íˆ¬ëª… ì´ˆë¡ìƒ‰

                    ctx.beginPath();
                    ctx.moveTo(comment.polygon[0].x, comment.polygon[0].y);

                    for (let i = 1; i < comment.polygon.length; i++) {
                        ctx.lineTo(comment.polygon[i].x, comment.polygon[i].y);
                    }

                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                // ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸° (í´ë¦¬ê³¤ì´ ì—†ì„ ë•Œë§Œ)
                else if (comment.box) {
                    ctx.strokeStyle = '#ffff00';  // ë…¸ë€ìƒ‰
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';  // ë°˜íˆ¬ëª… ë…¸ë€ìƒ‰

                    const { x, y, width, height } = comment.box;
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeRect(x, y, width, height);
                }
            };

            // ì´ë¯¸ì§€ê°€ ì´ë¯¸ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (img.complete && img.naturalWidth > 0) {
                drawOnLoad();
            } else {
                // ì´ë¯¸ì§€ ë¡œë“œ ëŒ€ê¸°
                img.addEventListener('load', drawOnLoad, { once: true });
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ/ìˆ¨ê¹€ í† ê¸€
        function toggleAnnotationsDisplay() {
            showAnnotations = !showAnnotations;

            const btn = document.getElementById('toggleAnnotationsBtn');
            if (showAnnotations) {
                btn.innerHTML = 'ğŸ‘ï¸ ì–´ë…¸í…Œì´ì…˜ ìˆ¨ê¹€';
                btn.style.background = '#4a9eff';
            } else {
                btn.innerHTML = 'ğŸ‘ï¸â€ğŸ—¨ï¸ ì–´ë…¸í…Œì´ì…˜ ë³´ê¸°';
                btn.style.background = '#555';
            }

            // ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            allComments.forEach((comment, index) => {
                drawAnnotationOnCanvas(comment, index);
            });
        }

        // í”„ë¡œì íŠ¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (2ì—´ êµ¬ì¡°)
        async function loadProjects() {
            const myProjectList = document.getElementById('myProjectList');
            const sharedProjectList = document.getElementById('sharedProjectList');

            myProjectList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';
            sharedProjectList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                // 1. ë‚´ í”„ë¡œì íŠ¸ ë¡œë“œ
                const myResponse = await authFetch('/api/projects');
                const myData = await myResponse.json();

                console.log('My projects data:', myData);

                if (myData.success && myData.projects && myData.projects.length > 0) {
                    myProjectList.innerHTML = myData.projects.map(p => {
                        return '<div style="position: relative; padding: 10px; margin-bottom: 10px; border: 1px solid #007bff; border-radius: 4px; padding-right: 50px; background: #1e1e1e;">' +
                            '<div onclick="openProject(\'' + p.id + '\')" style="cursor: pointer;">' +
                                '<strong style="color: #fff;">' + p.name + '</strong><br>' +
                                '<small style="color: #888;">ID: ' + p.id + '</small><br>' +
                                '<small style="color: #888;">Path: ' + p.path + '</small>' +
                            '</div>' +
                            '<button onclick="event.stopPropagation(); deleteProject(\'' + p.id + '\', \'' + p.name.replace(/'/g, "\\'") + '\')" ' +
                                'style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; ' +
                                'border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">' +
                                'ğŸ—‘ï¸ ì‚­ì œ' +
                            '</button>' +
                        '</div>';
                    }).join('');
                } else {
                    myProjectList.innerHTML = '<p style="color: #999;">ë‚´ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }

                // 2. ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ ë¡œë“œ
                const sharedResponse = await authFetch('/api/projects/shared');
                const sharedData = await sharedResponse.json();

                console.log('Shared projects data:', sharedData);

                if (sharedData.success && sharedData.projects && sharedData.projects.length > 0) {
                    sharedProjectList.innerHTML = sharedData.projects.map(p => {
                        return '<div style="position: relative; padding: 10px; margin-bottom: 10px; border: 1px solid #555; border-radius: 4px; background: #252525;">' +
                            '<div onclick="openProject(\'' + p.id + '\')" style="cursor: pointer;">' +
                                '<strong style="color: #ddd;">' + p.name + '</strong><br>' +
                                '<small style="color: #4a9eff;">ğŸ‘¤ ' + p.owner_name + ' (' + p.owner_id + ')</small><br>' +
                                '<small style="color: #888;">ID: ' + p.id + '</small><br>' +
                                '<small style="color: #888;">Path: ' + p.path + '</small>' +
                            '</div>' +
                            '<div style="position: absolute; top: 10px; right: 10px; font-size: 12px; color: #ffa500;">ğŸ‘ï¸ ì½ê¸° ì „ìš©</div>' +
                        '</div>';
                    }).join('');
                } else {
                    sharedProjectList.innerHTML = '<p style="color: #666;">ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }

            } catch (error) {
                console.error('Load projects error:', error);
                myProjectList.innerHTML =
                    '<p style="color: red;">[ERROR] ' + error.message + '</p>';
                sharedProjectList.innerHTML =
                    '<p style="color: red;">[ERROR] ' + error.message + '</p>';
            }
        }

        // í”„ë¡œì íŠ¸ ì—´ê¸°
        async function openProject(projectId) {
            try {
                // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ í™•ì¸
                const currentUser = getCurrentUser();
                const isAdmin = currentUser && currentUser.role === 'admin';

                // ê´€ë¦¬ìëŠ” /api/admin/projects, ì¼ë°˜ ì‚¬ìš©ìëŠ” /api/projects ì‚¬ìš©
                const endpoint = isAdmin
                    ? '/api/admin/projects/' + projectId
                    : '/api/projects/' + projectId;

                const response = await authFetch(endpoint);
                const data = await response.json();

                if (data.success) {
                    currentProject = data.project;
                    displayCurrentProject();

                    // í´ë˜ìŠ¤ ë¼ë””ì˜¤ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                    updateClassRadioButtons();
                    selectedClassIndex = 0;  // ì²« ë²ˆì§¸ í´ë˜ìŠ¤ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ

                    // í”„ë ˆì„-í´ë˜ìŠ¤ ì½”ë©˜íŠ¸ ë¡œë“œ
                    loadFrameClassComments();
                } else {
                    alert('[ERROR] Error: ' + data.error);
                }
            } catch (error) {
                console.error('Open project error:', error);
                alert('[ERROR] Error: ' + error.message);
            }
        }

        // í”„ë¡œì íŠ¸ ì‚­ì œ
        async function deleteProject(projectId, projectName) {
            // ì‚­ì œ í™•ì¸
            if (!confirm('í”„ë¡œì íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\ní”„ë¡œì íŠ¸: ' + projectName + '\nID: ' + projectId + '\n\nâš ï¸ ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!')) {
                return;
            }

            try {
                // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ í™•ì¸
                const currentUser = getCurrentUser();
                const isAdmin = currentUser && currentUser.role === 'admin';

                // ê´€ë¦¬ìëŠ” /api/admin/projects, ì¼ë°˜ ì‚¬ìš©ìëŠ” /api/projects ì‚¬ìš©
                const endpoint = isAdmin
                    ? '/api/admin/projects/' + projectId
                    : '/api/projects/' + projectId;

                const response = await authFetch(endpoint, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.success) {
                    alert('âœ… í”„ë¡œì íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!\n\ní”„ë¡œì íŠ¸: ' + projectName);

                    // í˜„ì¬ ì—´ë¦° í”„ë¡œì íŠ¸ê°€ ì‚­ì œëœ í”„ë¡œì íŠ¸ì¸ ê²½ìš° ì´ˆê¸°í™”
                    if (currentProject && currentProject.id === projectId) {
                        currentProject = null;
                        displayCurrentProject();
                    }

                    // í”„ë¡œì íŠ¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    loadProjects();
                } else {
                    alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('Delete project error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ê´€ë¦¬ììš©: ì „ì²´ í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
        async function loadAllProjects() {
            const allProjectsList = document.getElementById('allProjectsList');
            allProjectsList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                // ëª¨ë“  ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ ì¡°íšŒ
                const response = await authFetch('/api/admin/projects');
                const data = await response.json();

                console.log('[ADMIN] All projects data:', data);

                if (data.success && data.projects && data.projects.length > 0) {
                    // í”„ë¡œì íŠ¸ë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ í‘œì‹œ
                    const projectsHtml = data.projects.map(p => {
                        const createdDate = p.created_at ? new Date(p.created_at).toLocaleString('ko-KR') : 'N/A';
                        const videoCount = p.video_count || 0;
                        const annotationCount = p.annotation_count || 0;

                        return `
                            <div style="background: #2d2d2d; padding: 15px; margin-bottom: 10px; border-radius: 4px; border-left: 4px solid #007bff;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <h4 style="margin: 0 0 10px 0; color: #58a6ff;">ğŸ“ ${p.name}</h4>
                                        <div style="display: grid; grid-template-columns: 150px 1fr; gap: 5px; font-size: 13px;">
                                            <span style="color: #8b949e;">í”„ë¡œì íŠ¸ ID:</span><span>${p.id}</span>
                                            <span style="color: #8b949e;">ì†Œìœ ì:</span><span>${p.owner_id} (${p.owner_name || 'N/A'})</span>
                                            <span style="color: #8b949e;">ê²½ë¡œ:</span><span style="font-family: monospace; color: #a5d6ff;">${p.path}</span>
                                            <span style="color: #8b949e;">ìƒì„±ì¼:</span><span>${createdDate}</span>
                                            <span style="color: #8b949e;">ë¹„ë””ì˜¤:</span><span style="color: #79c0ff; font-weight: bold;">${videoCount}ê°œ</span>
                                            <span style="color: #8b949e;">ì–´ë…¸í…Œì´ì…˜:</span><span style="color: #56d364; font-weight: bold;">${annotationCount}ê°œ</span>
                                            <span style="color: #8b949e;">í´ë˜ìŠ¤:</span><span>${(p.classes || []).length}ê°œ ${p.classes && p.classes.length > 0 ? '(' + p.classes.slice(0, 3).join(', ') + (p.classes.length > 3 ? '...' : '') + ')' : ''}</span>
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 5px; flex-direction: column;">
                                        <button onclick="viewProjectDetails('${p.id}')"
                                            style="background: #238636; color: white; border: none; padding: 6px 12px;
                                            border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                            ğŸ‘ï¸ ìƒì„¸ë³´ê¸°
                                        </button>
                                        <button onclick="adminDeleteProject('${p.id}', '${p.name.replace(/'/g, "\\'")}', '${p.owner_id}')"
                                            style="background: #da3633; color: white; border: none; padding: 6px 12px;
                                            border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                            ğŸ—‘ï¸ ì‚­ì œ
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // í†µê³„ ìš”ì•½
                    const totalProjects = data.projects.length;
                    const totalVideos = data.projects.reduce((sum, p) => sum + (p.video_count || 0), 0);
                    const totalAnnotations = data.projects.reduce((sum, p) => sum + (p.annotation_count || 0), 0);
                    const uniqueUsers = [...new Set(data.projects.map(p => p.owner_id))].length;

                    const summaryHtml = `
                        <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                            padding: 20px; margin-bottom: 15px; border-radius: 8px; color: white;">
                            <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ“Š ì „ì²´ í†µê³„</h3>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; text-align: center;">
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${totalProjects}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ í”„ë¡œì íŠ¸</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${uniqueUsers}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í™œì„± ì‚¬ìš©ì</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${totalVideos}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ ë¹„ë””ì˜¤</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${totalAnnotations}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                                </div>
                            </div>
                        </div>
                    `;

                    allProjectsList.innerHTML = summaryHtml + projectsHtml;
                } else {
                    allProjectsList.innerHTML = '<p style="color: #999;">ë“±ë¡ëœ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }

            } catch (error) {
                console.error('[ADMIN] Load all projects error:', error);
                allProjectsList.innerHTML =
                    '<p style="color: red;">[ERROR] ì „ì²´ í”„ë¡œì íŠ¸ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ê´€ë¦¬ììš©: ì™„ë£Œëœ ë¹„ë””ì˜¤ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (í”„ë¡œì íŠ¸ íƒ­ì— í‘œì‹œ)
        async function loadAdminCompletedVideos() {
            console.log('[ADMIN] loadAdminCompletedVideos called');
            const projectList = document.getElementById('projectList');
            const currentProjectSection = document.getElementById('currentProjectSection');

            if (!projectList) {
                console.error('[ADMIN] projectList element not found!');
                return;
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì„¹ì…˜ê³¼ ìƒì„± ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            if (currentProjectSection) {
                currentProjectSection.style.display = 'none';
            }

            projectList.innerHTML = '<p style="color: #999;">ì „ì²´ í”„ë¡œì íŠ¸ í˜„í™© ë¡œë”© ì¤‘...</p>';

            try {
                console.log('[ADMIN] Fetching completed videos...');
                const response = await authFetch('/api/admin/completed-videos');

                console.log('[ADMIN] Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[ADMIN] Completed videos data:', data);

                if (!data.success) {
                    throw new Error(data.error || 'Unknown error from server');
                }

                if (!data.users || data.users.length === 0) {
                    console.log('[ADMIN] No completed videos found');
                    projectList.innerHTML = '<p style="color: #999;">ì™„ë£Œëœ ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }

                // ì•ˆì „í•˜ê²Œ ì´ ì–´ë…¸í…Œì´ì…˜ ìˆ˜ ê³„ì‚°
                let totalAnnotations = 0;
                try {
                    totalAnnotations = data.users.reduce((sum, u) => {
                        const userVideos = u.videos || [];
                        return sum + userVideos.reduce((vsum, v) => vsum + (v.annotations || 0), 0);
                    }, 0);
                } catch (e) {
                    console.warn('[ADMIN] Error calculating annotations:', e);
                }

                console.log('[ADMIN] Building summary HTML...');
                // ì „ì²´ í†µê³„ ìš”ì•½
                const summaryHtml = `
                    <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                        padding: 20px; margin-bottom: 15px; border-radius: 8px; color: white;">
                        <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ“Š ì™„ë£Œëœ ë¹„ë””ì˜¤ í†µê³„</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div>
                                <div style="font-size: 28px; font-weight: bold;">${data.total_users || 0}</div>
                                <div style="font-size: 12px; opacity: 0.9;">ì‘ì—… ì¤‘ì¸ ì‚¬ìš©ì</div>
                            </div>
                            <div>
                                <div style="font-size: 28px; font-weight: bold;">${data.total_completed_videos || 0}</div>
                                <div style="font-size: 12px; opacity: 0.9;">ì™„ë£Œëœ ë¹„ë””ì˜¤</div>
                            </div>
                            <div>
                                <div style="font-size: 28px; font-weight: bold;">${totalAnnotations}</div>
                                <div style="font-size: 12px; opacity: 0.9;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                            </div>
                        </div>
                    </div>
                `;

                console.log('[ADMIN] Building users HTML...');
                // ì‚¬ìš©ìë³„ ì™„ë£Œëœ ë¹„ë””ì˜¤ ëª©ë¡
                const usersHtml = data.users.map(user => {
                    const videos = user.videos || [];
                    const videosHtml = videos.map(video => `
                        <tr style="border-bottom: 1px solid #404040;">
                            <td style="padding: 8px;">${video.video_name || 'N/A'}</td>
                            <td style="padding: 8px;">${video.project_name || 'N/A'}</td>
                            <td style="padding: 8px; text-align: center;">${video.annotations || 0}</td>
                            <td style="padding: 8px; text-align: center;">${video.frame_count || 0}</td>
                            <td style="padding: 8px; text-align: center;">${video.complete ? 'âœ…' : 'â³'}</td>
                        </tr>
                    `).join('');

                    return `
                        <div style="background: #2d2d2d; padding: 15px; margin-bottom: 15px; border-radius: 4px; border-left: 4px solid #28a745;">
                            <h4 style="margin: 0 0 10px 0; color: #58a6ff;">
                                ğŸ‘¤ ${user.user_name || user.user_id} (${user.user_id}) - ${user.completed_videos_count || 0}ê°œ ì™„ë£Œ
                            </h4>
                            <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                <thead>
                                    <tr style="background: #1e1e1e; color: #8b949e;">
                                        <th style="padding: 8px; text-align: left;">ë¹„ë””ì˜¤</th>
                                        <th style="padding: 8px; text-align: left;">í”„ë¡œì íŠ¸</th>
                                        <th style="padding: 8px; text-align: center;">ì–´ë…¸í…Œì´ì…˜</th>
                                        <th style="padding: 8px; text-align: center;">í”„ë ˆì„</th>
                                        <th style="padding: 8px; text-align: center;">ì™„ë£Œ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${videosHtml}
                                </tbody>
                            </table>
                        </div>
                    `;
                }).join('');

                console.log('[ADMIN] Setting innerHTML...');
                projectList.innerHTML = summaryHtml + usersHtml;
                console.log('[ADMIN] Completed videos loaded successfully');

            } catch (error) {
                console.error('[ADMIN] Load completed videos error:', error);
                console.error('[ADMIN] Error stack:', error.stack);
                projectList.innerHTML =
                    '<p style="color: red;">[ERROR] ì™„ë£Œëœ ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ê´€ë¦¬ììš©: ì–´ë…¸í…Œì´ì…˜ í†µê³„ ë¶ˆëŸ¬ì˜¤ê¸° (ì–´ë…¸í…Œì´ì…˜ íƒ­ì— í‘œì‹œ)
        async function loadAdminAnnotationStats() {
            // ì–´ë…¸í…Œì´ì…˜ íƒ­ì˜ ê¸°ì¡´ ì»¨í…ì¸  ëŒ€ì‹  í†µê³„ í‘œì‹œ
            const annotationTab = document.getElementById('annotation-tab');

            // ì„ì‹œ ì»¨í…Œì´ë„ˆ ìƒì„± (ê¸°ì¡´ UIë¥¼ ìˆ¨ê¸°ì§€ ì•Šê³  ìƒë‹¨ì— ì¶”ê°€)
            let statsContainer = document.getElementById('admin-annotation-stats-container');
            if (!statsContainer) {
                statsContainer = document.createElement('div');
                statsContainer.id = 'admin-annotation-stats-container';
                statsContainer.style.cssText = 'padding: 20px; background: #1e1e1e; margin-bottom: 20px; border-radius: 8px;';
                annotationTab.insertBefore(statsContainer, annotationTab.firstChild);
            }

            statsContainer.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                const response = await authFetch('/api/admin/annotation-stats');
                const data = await response.json();

                console.log('[ADMIN] Annotation stats data:', data);

                if (data.success) {
                    const stats = data.total_stats;
                    const userStats = data.user_stats;

                    // ì „ì²´ í†µê³„ ìš”ì•½
                    const summaryHtml = `
                        <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                            padding: 20px; margin-bottom: 15px; border-radius: 8px; color: white;">
                            <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ“Š ì „ì²´ ì–´ë…¸í…Œì´ì…˜ í˜„í™©</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_users}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í™œì„± ì‚¬ìš©ì</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_projects}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í”„ë¡œì íŠ¸</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_videos}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ë¹„ë””ì˜¤</div>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_annotated_videos}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì™„ë£Œëœ ë¹„ë””ì˜¤</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_annotations}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_annotated_frames}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í”„ë ˆì„</div>
                                </div>
                            </div>
                        </div>
                    `;

                    // ì‚¬ìš©ìë³„ í†µê³„
                    const userStatsHtml = userStats.length > 0 ? `
                        <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                            <h4 style="margin: 0 0 10px 0; color: #58a6ff;">ğŸ“ˆ ì‚¬ìš©ìë³„ ì‘ì—… í˜„í™©</h4>
                            <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                <thead>
                                    <tr style="background: #1e1e1e; color: #8b949e;">
                                        <th style="padding: 8px; text-align: left;">ì‚¬ìš©ì</th>
                                        <th style="padding: 8px; text-align: center;">í”„ë¡œì íŠ¸</th>
                                        <th style="padding: 8px; text-align: center;">ë¹„ë””ì˜¤</th>
                                        <th style="padding: 8px; text-align: center;">ì™„ë£Œ</th>
                                        <th style="padding: 8px; text-align: center;">ì–´ë…¸í…Œì´ì…˜</th>
                                        <th style="padding: 8px; text-align: center;">í”„ë ˆì„</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${userStats.map(u => `
                                        <tr style="border-bottom: 1px solid #404040;">
                                            <td style="padding: 8px;">${u.user_name} (${u.user_id})</td>
                                            <td style="padding: 8px; text-align: center;">${u.projects}</td>
                                            <td style="padding: 8px; text-align: center;">${u.videos}</td>
                                            <td style="padding: 8px; text-align: center;">${u.annotated_videos}</td>
                                            <td style="padding: 8px; text-align: center; color: #56d364; font-weight: bold;">${u.annotations}</td>
                                            <td style="padding: 8px; text-align: center;">${u.annotated_frames}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    ` : '<p style="color: #999;">ì‚¬ìš©ì í†µê³„ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';

                    // í†µê³„ ìˆ¨ê¹€ ì²˜ë¦¬
                    statsContainer.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">í†µê³„ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.</p>';
                    // statsContainer.innerHTML = summaryHtml + userStatsHtml;
                } else {
                    statsContainer.innerHTML = '<p style="color: red;">[ERROR] í†µê³„ ë¡œë“œ ì‹¤íŒ¨</p>';
                }

            } catch (error) {
                console.error('[ADMIN] Load annotation stats error:', error);
                statsContainer.innerHTML =
                    '<p style="color: red;">[ERROR] í†µê³„ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ê´€ë¦¬ììš©: í”„ë¡œì íŠ¸ ìƒì„¸ë³´ê¸° (ëª¨ë‹¬ ë˜ëŠ” í™•ì¥)
        async function viewProjectDetails(projectId) {
            try {
                const response = await authFetch('/api/admin/projects/' + projectId);
                const data = await response.json();

                if (data.success) {
                    const project = data.project;
                    const details = `
í”„ë¡œì íŠ¸ ìƒì„¸ ì •ë³´
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ ì´ë¦„: ${project.name}
ğŸ†” ID: ${project.id}
ğŸ‘¤ ì†Œìœ ì: ${project.owner_id}
ğŸ“‚ ê²½ë¡œ: ${project.path}
ğŸ“… ìƒì„±ì¼: ${project.created_at ? new Date(project.created_at).toLocaleString('ko-KR') : 'N/A'}

ğŸ“Š í†µê³„:
  â€¢ í´ë˜ìŠ¤: ${(project.classes || []).length}ê°œ
  â€¢ ë¹„ë””ì˜¤: ${project.video_count || 0}ê°œ
  â€¢ ì–´ë…¸í…Œì´ì…˜: ${project.annotation_count || 0}ê°œ

ğŸ·ï¸ í´ë˜ìŠ¤ ëª©ë¡:
${(project.classes || []).map((c, i) => `  ${i + 1}. ${c}`).join('\n') || '  (í´ë˜ìŠ¤ ì—†ìŒ)'}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    `;
                    alert(details);
                } else {
                    alert('âŒ í”„ë¡œì íŠ¸ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] View project details error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì •ë³´ ë¡œë“œ ì˜¤ë¥˜: ' + error.message);
            }
        }

        // ê´€ë¦¬ììš©: í”„ë¡œì íŠ¸ ì‚­ì œ
        async function adminDeleteProject(projectId, projectName, ownerId) {
            if (!confirm(`âš ï¸ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ í”„ë¡œì íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\ní”„ë¡œì íŠ¸: ${projectName}\nID: ${projectId}\nì†Œìœ ì: ${ownerId}\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)) {
                return;
            }

            try {
                const response = await authFetch('/api/admin/projects/' + projectId, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.success) {
                    alert('âœ… í”„ë¡œì íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!\n\ní”„ë¡œì íŠ¸: ' + projectName);
                    loadAllProjects();  // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Delete project error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // í˜„ì¬ í”„ë¡œì íŠ¸ í‘œì‹œ
        function displayCurrentProject() {
            if (!currentProject) {
                document.getElementById('currentProjectSection').style.display = 'none';
                return;
            }

            document.getElementById('currentProjectSection').style.display = 'block';
            document.getElementById('currentProjectName').textContent = currentProject.name;

            // ê¸°ë³¸ê°’ ì„¤ì •
            const classes = currentProject.classes || [];
            const stats = currentProject.stats || {
                total_videos: 0,
                annotated_videos: 0,
                total_annotations: 0,
                annotated_frames: 0,
                datasets: 0
            };

            document.getElementById('currentProjectStats').innerHTML =
                'ID: ' + currentProject.id + '<br>' +
                'í´ë˜ìŠ¤: ' + (classes.length > 0 ? classes.map(c => c.description || c.name).join(', ') : 'ì—†ìŒ') + '<br>' +
                'ë¹„ë””ì˜¤: ' + stats.total_videos + ' (ì™„ë£Œ ' + stats.annotated_videos + ')<br>' +
                'ì´ ì–´ë…¸í…Œì´ì…˜: ' + stats.total_annotations + ' (' + stats.annotated_frames + ' í”„ë ˆì„)<br>' +
                'ë°ì´í„°ì…‹: ' + stats.datasets;

            displayVideos();
        }

        // ë¹„ë””ì˜¤ ëª©ë¡ í‘œì‹œ
        function displayVideos() {
            const videosList = document.getElementById('videosList');

            if (!currentProject || !currentProject.videos || currentProject.videos.length === 0) {
                videosList.innerHTML = '<p style="color: #999;">ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            videosList.innerHTML = currentProject.videos.map(v => {
                // ë””ë ‰í† ë¦¬ ë©”íƒ€ë°ì´í„° íŒŒì‹± (í•˜ì´í”ˆìœ¼ë¡œ êµ¬ë¶„ëœ ë¶€ë¶„ë“¤)
                let dirMetaDisplay = '';
                if (v.nas_metadata && v.nas_metadata.parent_dir) {
                    const parts = v.nas_metadata.parent_dir.split('-').map(p => p.trim()).filter(p => p);
                    dirMetaDisplay = parts.length > 0 ? parts.join(' - ') : v.nas_metadata.parent_dir;
                }

                // ë¹„ë””ì˜¤ ìƒíƒœ (ê¸°ë³¸ê°’: in_progress)
                const status = v.status || 'in_progress';
                const isCompleted = status === 'completed';

                // ìƒíƒœì— ë”°ë¥¸ ìŠ¤íƒ€ì¼
                const borderColor = isCompleted ? '#28a745' : '#ffa500';
                const statusBadge = isCompleted
                    ? '<span style="background: #28a745; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; margin-left: 10px;">âœ“ ì™„ë£Œ</span>'
                    : '<span style="background: #ffa500; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; margin-left: 10px;">â³ ì§„í–‰ì¤‘</span>';

                // ìƒíƒœ í† ê¸€ ë²„íŠ¼
                const statusToggleBtn = isCompleted
                    ? '<button onclick="toggleVideoStatus(\'' + v.video_id + '\', \'in_progress\')" style="background: #6c757d; font-size: 12px; padding: 5px 10px; margin-right: 5px;" title="ì§„í–‰ì¤‘ìœ¼ë¡œ ë³€ê²½">[ì§„í–‰ì¤‘ìœ¼ë¡œ]</button>'
                    : '<button onclick="toggleVideoStatus(\'' + v.video_id + '\', \'completed\')" style="background: #28a745; font-size: 12px; padding: 5px 10px; margin-right: 5px;" title="ì™„ë£Œë¡œ ë³€ê²½">[ì™„ë£Œë¡œ í‘œì‹œ]</button>';

                // ì½”ë©˜íŠ¸ í™•ì¸
                const commentsKey = 'frameClassComments_' + currentProject.id;
                let hasComments = false;
                try {
                    const savedComments = localStorage.getItem(commentsKey);
                    if (savedComments) {
                        const comments = JSON.parse(savedComments);
                        // ì½”ë©˜íŠ¸ê°€ í•˜ë‚˜ë¼ë„ ìˆëŠ”ì§€ í™•ì¸
                        hasComments = Object.keys(comments).length > 0;
                    }
                } catch (e) {
                    console.error('[COMMENT] Error loading comments for video', v.video_id, e);
                }

                const commentIcon = hasComments ? ' <span style="color: #ffa500;" title="ì½”ë©˜íŠ¸ ìˆìŒ">ğŸ’¬</span>' : '';

                return '<div style="padding: 10px; margin: 5px 0; background: #2d2d2d; border-radius: 4px; border-left: 4px solid ' + borderColor + ';">' +
                    '<div style="margin-bottom: 8px;">' +
                        '<strong style="color: #4a9eff; font-size: 14px;">ğŸ“¹ ' + v.filename + '</strong>' +
                        commentIcon +
                        statusBadge +
                        '<br>' +
                        (dirMetaDisplay ? '<small style="color: #4a9eff;">ğŸ“‹ ' + dirMetaDisplay + '</small>' : '') +
                    '</div>' +
                    '<div style="margin-bottom: 5px;">' +
                        '<button onclick="startAnnotation(\'' + v.video_id + '\')" style="background: #4a9eff; font-size: 12px; padding: 5px 10px; margin-right: 5px;">[Start Annotation]</button>' +
                        '<button onclick="startVideoInference(\'' + v.video_id + '\')" style="background: #ffa500; font-size: 12px; padding: 5px 10px; margin-right: 5px;">[Start Inference]</button>' +
                        statusToggleBtn +
                        '<button onclick="removeVideo(\'' + v.video_id + '\')" style="background: #dc3545; font-size: 12px; padding: 5px 10px;">[Remove]</button>' +
                    '</div>' +
                    '<small style="color: #999;">Frames: ' + (v.total_frames || v.frame_count || 0) +
                        (v.width && v.height ? ' | Resolution: ' + v.width + 'x' + v.height : '') +
                        ' | Annotations: ' + (v.annotations || 0) + '</small>' +
                '</div>';
            }).join('');
        }

        // ì–´ë…¸í…Œì´ì…˜ ì‹œì‘
        async function startAnnotation(videoId) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                // ë¹„ë””ì˜¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId);
                const data = await response.json();

                if (data.success && data.video) {
                    // annotation íƒ­ìœ¼ë¡œ ì „í™˜
                    showTab('annotation');

                    // ë¹„ë””ì˜¤ ì •ë³´ ì €ì¥
                    currentProjectId = currentProject.id;
                    currentVideoId = videoId;
                    console.log('[VIDEO STATUS] Full video data:', JSON.stringify(data.video));
                    console.log('[VIDEO STATUS] Status field:', data.video.status);
                    currentVideoStatus = data.video.status || 'in_progress';
                    console.log('[VIDEO STATUS] Current video status set to:', currentVideoStatus);
                    totalFrames = data.video.total_frames || data.video.frame_count;

                    // ì™¼ìª½ íŒ¨ë„ì— í”„ë¡œì íŠ¸ ë° ë¹„ë””ì˜¤ ì •ë³´ í‘œì‹œ
                    document.getElementById('currentProjectDisplay').innerHTML =
                        '<strong>' + currentProject.name + '</strong><br>' +
                        '<small style="color: #888;">ID: ' + currentProject.id + '</small>';

                    // ìƒìœ„ í´ë” ì •ë³´ êµ¬ì„±
                    let folderInfo = '';
                    if (data.video.nas_metadata && data.video.nas_metadata.parent_dir) {
                        const parentDir = data.video.nas_metadata.parent_dir;
                        const nasFolder = data.video.nas_metadata.nas_folder || '';

                        // ë””ë ‰í† ë¦¬ ë©”íƒ€ë°ì´í„° íŒŒì‹± (í•˜ì´í”ˆìœ¼ë¡œ êµ¬ë¶„)
                        const parts = parentDir.split('-').map(p => p.trim()).filter(p => p);
                        const dirDisplay = parts.length > 0 ? parts.join(' - ') : parentDir;

                        folderInfo = '<small style="color: #888;">ğŸ“ ' +
                            (nasFolder ? nasFolder + ' / ' : '') +
                            dirDisplay + '</small><br>';
                    }

                    document.getElementById('currentVideoDisplay').innerHTML =
                        '<strong style="color: #4a9eff;">' + data.video.filename + '</strong><br>' +
                        folderInfo +
                        '<small>Total Frames: ' + totalFrames + '</small><br>' +
                        '<small>Current: <span id="currentFrameInfo">0</span></small>';

                    // ë¹„ë””ì˜¤ ë³€ê²½ ì‹œ ì–´ë…¸í…Œì´ì…˜ ì´ˆê¸°í™”
                    frameAnnotations = {};
                    savedFrameAnnotations = {};
                    updateStatistics(); // Statistics ì´ˆê¸°í™”

                    console.log('[INFO] Video info loaded:', data.video);
                    console.log('[INFO] Total frames:', totalFrames);
                    console.log('[INFO] Annotations cleared for new video');

                    // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ì´ˆê¸°í™”
                    await initVideoPlayer();

                    // ë¹„ë””ì˜¤ ìƒíƒœì— ë”°ë¥¸ UI ì—…ë°ì´íŠ¸
                    updateAnnotationUIForStatus();

                } else {
                    alert('[ERROR] ë¹„ë””ì˜¤ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
                }
            } catch (error) {
                console.error('Start annotation error:', error);
                alert('[ERROR] ì–´ë…¸í…Œì´ì…˜ ì‹œì‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ë¡  ì‹œì‘
        async function startVideoInference(videoId) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                // ë¹„ë””ì˜¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId);
                const data = await response.json();

                if (data.success && data.video) {
                    // Inference íƒ­ìœ¼ë¡œ ì „í™˜
                    showTab('inference');

                    // ë¹„ë””ì˜¤ ì •ë³´ ì €ì¥
                    currentProjectId = currentProject.id;
                    currentVideoId = videoId;

                    // Inference íƒ­ì˜ ì„¤ì • ìë™ ì…ë ¥
                    document.getElementById('inferenceModelType').value = 'segformer';

                    // API ì‘ë‹µì—ì„œ ë°›ì€ ì ˆëŒ€ ê²½ë¡œ ì‚¬ìš© (Synology ë§ˆìš´íŠ¸ ê²½ë¡œ í¬í•¨)
                    const videoPath = data.video.path;
                    document.getElementById('inferenceVideoPath').value = videoPath;

                    // ëª¨ë¸ ê²½ë¡œëŠ” ë¹„ì›Œë‘  (ìë™ìœ¼ë¡œ í”„ë¡œì íŠ¸ ëª¨ë¸ ì‚¬ìš©)
                    document.getElementById('inferenceModelPath').value = '';

                    // ì¶œë ¥ ê²½ë¡œ ì„¤ì • (ë¹„ë””ì˜¤ì™€ ê°™ì€ ë””ë ‰í† ë¦¬ì— inference_results í´ë”)
                    const videoDir = videoPath.substring(0, videoPath.lastIndexOf('/'));
                    document.getElementById('inferenceOutputPath').value = `${videoDir}/inference_results`;

                    console.log('[INFO] Video inference setup:', {
                        videoId: videoId,
                        filename: data.video.filename,
                        videoPath: videoPath,
                        outputPath: `${videoDir}/inference_results`
                    });

                    alert('Inference íƒ­ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.\n\në¹„ë””ì˜¤: ' + data.video.filename + '\n\nì„¤ì •ì„ í™•ì¸í•˜ê³  "Start Inference" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.');
                } else {
                    alert('[ERROR] ë¹„ë””ì˜¤ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
                }
            } catch (error) {
                console.error('Start video inference error:', error);
                alert('[ERROR] Inference ì‹œì‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // í”„ë¡œì íŠ¸ ë‹«ê¸°
        function closeProject() {
            currentProject = null;
            document.getElementById('currentProjectSection').style.display = 'none';
        }

        // í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ ì—´ê¸°
        function openProjectSettings() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            // ì„ì‹œ í´ë˜ìŠ¤ ëª©ë¡ ì´ˆê¸°í™”
            let classes = currentProject.classes;
            if (typeof classes === 'string') {
                // ë¬¸ìì—´ì¸ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)
                classes = classes.split(',').map(c => c.trim()).filter(c => c.length > 0);
                tempClassList = classes.map(name => ({ name: name, description: '' }));
            } else if (Array.isArray(classes)) {
                // ë°°ì—´ì¸ ê²½ìš°
                tempClassList = classes.map(cls => {
                    if (typeof cls === 'string') {
                        // ë¬¸ìì—´ ë°°ì—´ (í•˜ìœ„ í˜¸í™˜ì„±)
                        return { name: cls, description: '' };
                    } else if (cls.name) {
                        // ê°ì²´ ë°°ì—´
                        return { name: cls.name, description: cls.description || '' };
                    }
                    return { name: '', description: '' };
                }).filter(cls => cls.name.length > 0);
            } else {
                tempClassList = [];
            }

            // ëª¨ë‹¬ ì •ë³´ ì—…ë°ì´íŠ¸
            document.getElementById('settingsProjectName').textContent = currentProject.name;
            document.getElementById('settingsProjectId').textContent = currentProject.id;

            // í´ë˜ìŠ¤ ëª©ë¡ í‘œì‹œ
            updateSettingsClassList();

            // ëª¨ë‹¬ í‘œì‹œ
            document.getElementById('projectSettingsModal').classList.add('show');
        }

        // í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ ë‹«ê¸°
        function closeProjectSettings() {
            document.getElementById('projectSettingsModal').classList.remove('show');
            document.getElementById('newClassName').value = '';
            document.getElementById('newClassDescription').value = '';
        }

        // ì–´ë…¸í…Œì´ì…˜ ë„ì›€ë§ ëª¨ë‹¬ ì—´ê¸°/ë‹«ê¸°
        function showAnnotationHelp() {
            document.getElementById('annotationHelpModal').classList.add('show');
        }

        function closeAnnotationHelp() {
            document.getElementById('annotationHelpModal').classList.remove('show');
        }

        // ì„¤ì • ëª¨ë‹¬ì˜ í´ë˜ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateSettingsClassList() {
            const container = document.getElementById('settingsClassList');

            if (tempClassList.length === 0) {
                container.innerHTML = '<p style="color: #888; font-size: 12px;">í´ë˜ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            container.innerHTML = '';

            tempClassList.forEach((classObj, index) => {
                const item = document.createElement('div');
                item.className = 'class-item';
                item.style.display = 'flex';
                item.style.flexDirection = 'column';
                item.style.gap = '5px';
                item.style.marginBottom = '10px';
                item.style.padding = '10px';
                item.style.background = '#1e1e1e';
                item.style.borderRadius = '4px';

                const headerDiv = document.createElement('div');
                headerDiv.style.display = 'flex';
                headerDiv.style.justifyContent = 'space-between';
                headerDiv.style.alignItems = 'center';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${index + 1}. ${getClassDisplayName(classObj)}`;
                nameSpan.style.fontWeight = '600';
                nameSpan.style.color = '#4a9eff';
                nameSpan.style.cursor = 'pointer';
                nameSpan.title = 'ìš°í´ë¦­í•˜ì—¬ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½';

                // ìš°í´ë¦­ìœ¼ë¡œ í´ë˜ìŠ¤ ì´ë¦„ ìˆ˜ì •
                nameSpan.oncontextmenu = function(e) {
                    e.preventDefault();
                    const newName = prompt('ìƒˆ í´ë˜ìŠ¤ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', classObj.name);
                    if (newName && newName.trim() && newName.trim() !== classObj.name) {
                        const trimmedName = newName.trim();
                        // ì¤‘ë³µ ì²´í¬
                        const exists = tempClassList.some((cls, idx) => idx !== index && cls.name === trimmedName);
                        if (exists) {
                            alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í´ë˜ìŠ¤ ì´ë¦„ì…ë‹ˆë‹¤.');
                            return;
                        }
                        tempClassList[index].name = trimmedName;
                        updateSettingsClassList();
                        console.log('[SETTINGS] Renamed class to:', trimmedName);
                    }
                };

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'ğŸ—‘ï¸ ì‚­ì œ';
                deleteBtn.style.padding = '4px 8px';
                deleteBtn.style.fontSize = '11px';
                deleteBtn.onclick = function() {
                    removeClass(index);
                };

                headerDiv.appendChild(nameSpan);
                headerDiv.appendChild(deleteBtn);

                item.appendChild(headerDiv);

                // ì„¤ëª… ì¶”ê°€ (ìˆìœ¼ë©´)
                const descDiv = document.createElement('div');
                descDiv.style.color = '#999';
                descDiv.style.fontSize = '12px';
                descDiv.style.paddingLeft = '10px';
                descDiv.style.whiteSpace = 'pre-wrap';
                descDiv.style.cursor = 'pointer';
                descDiv.title = 'ìš°í´ë¦­í•˜ì—¬ ì„¤ëª… ë³€ê²½';
                descDiv.textContent = classObj.description || '(ì„¤ëª… ì—†ìŒ - ìš°í´ë¦­í•˜ì—¬ ì¶”ê°€)';

                // ìš°í´ë¦­ìœ¼ë¡œ ì„¤ëª… ìˆ˜ì •
                descDiv.oncontextmenu = function(e) {
                    e.preventDefault();
                    const newDesc = prompt('í´ë˜ìŠ¤ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”:', classObj.description || '');
                    if (newDesc !== null) { // Cancel í´ë¦­ ì‹œ null ë°˜í™˜
                        tempClassList[index].description = newDesc.trim();
                        updateSettingsClassList();
                        console.log('[SETTINGS] Updated description for', classObj.name);
                    }
                };

                item.appendChild(descDiv);

                container.appendChild(item);
            });
        }

        // í´ë˜ìŠ¤ ì¶”ê°€
        function addClass() {
            const nameInput = document.getElementById('newClassName');
            const descInput = document.getElementById('newClassDescription');
            const className = nameInput.value.trim();
            const classDescription = descInput.value.trim();

            if (!className) {
                alert('í´ë˜ìŠ¤ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            // ì¤‘ë³µ ì²´í¬
            const exists = tempClassList.some(cls => cls.name === className);
            if (exists) {
                alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í´ë˜ìŠ¤ ì´ë¦„ì…ë‹ˆë‹¤.');
                return;
            }

            tempClassList.push({
                name: className,
                description: classDescription
            });

            nameInput.value = '';
            descInput.value = '';
            updateSettingsClassList();

            console.log('[SETTINGS] Added class:', className, 'with description:', classDescription);
        }

        // í´ë˜ìŠ¤ ì‚­ì œ
        function removeClass(index) {
            const classObj = tempClassList[index];
            if (!confirm(`'${classObj.name}' í´ë˜ìŠ¤ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            const removed = tempClassList.splice(index, 1);
            updateSettingsClassList();

            console.log('[SETTINGS] Removed class:', removed[0].name);
        }

        // í”„ë¡œì íŠ¸ ì„¤ì • ì €ì¥
        async function saveProjectSettings() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            if (tempClassList.length === 0) {
                alert('ìµœì†Œ 1ê°œ ì´ìƒì˜ í´ë˜ìŠ¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProject.id, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        classes: tempClassList
                    })
                });

                const data = await response.json();

                if (data.success) {
                    alert('í”„ë¡œì íŠ¸ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');

                    // currentProject ì—…ë°ì´íŠ¸
                    currentProject.classes = [...tempClassList];

                    // ë¼ë””ì˜¤ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                    updateClassRadioButtons();

                    // ì„ íƒëœ í´ë˜ìŠ¤ ì¸ë±ìŠ¤ ì¬ì¡°ì •
                    if (selectedClassIndex >= tempClassList.length) {
                        selectedClassIndex = 0;
                    }

                    // ëª¨ë‹¬ ë‹«ê¸°
                    closeProjectSettings();

                    console.log('[SETTINGS] Project settings saved successfully');
                } else {
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[SETTINGS] Error saving settings:', error);
                alert('ì„¤ì • ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸
        async function showAddVideoDialog() {
            // Electron í™˜ê²½ ì²´í¬
            if (window.electronAPI && window.electronAPI.openFileDialog) {
                // ì„ íƒ ë°©ë²• í™•ì¸
                const choice = confirm(
                    'ë¹„ë””ì˜¤ ì¶”ê°€ ë°©ë²•:\n\n' +
                    '[í™•ì¸] ë””ë ‰í† ë¦¬ ì„ íƒ (NAS í´ë”ì— ë§ì€ íŒŒì¼ì´ ìˆì„ ë•Œ ë¹ ë¦„)\n' +
                    '[ì·¨ì†Œ] íŒŒì¼ ì§ì ‘ ì„ íƒ (ê°œë³„ íŒŒì¼ ì„ íƒ)'
                );

                if (choice) {
                    // ë°©ë²• 1: ë””ë ‰í† ë¦¬ ì„ íƒ (ë” ë¹ ë¦„)
                    const result = await window.electronAPI.openFileDialog({
                        properties: ['openDirectory'],
                        title: 'ë¹„ë””ì˜¤ê°€ ìˆëŠ” ë””ë ‰í† ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”'
                    });

                    if (!result.canceled && result.filePaths.length > 0) {
                        const dirPath = result.filePaths[0];
                        console.log(`[VIDEO] Scanning directory: ${dirPath}`);

                        // ë°±ì—”ë“œì— ë””ë ‰í† ë¦¬ ê²½ë¡œ ì „ë‹¬í•˜ì—¬ ë¹„ë””ì˜¤ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                        try {
                            const response = await authFetch('/api/scan-videos', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ directory: dirPath })
                            });

                            const data = await response.json();

                            if (data.success && data.videos.length > 0) {
                                // ë°œê²¬ëœ ë¹„ë””ì˜¤ ëª©ë¡ í‘œì‹œ ë° ì„ íƒ
                                const videoList = data.videos.map((v, i) => `${i + 1}. ${v.name}`).join('\n');
                                const confirmAdd = confirm(
                                    `${data.videos.length}ê°œì˜ ë¹„ë””ì˜¤ íŒŒì¼ì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤:\n\n` +
                                    videoList.slice(0, 500) + (videoList.length > 500 ? '\n...' : '') +
                                    `\n\nëª¨ë‘ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
                                );

                                if (confirmAdd) {
                                    let successCount = 0;
                                    let failCount = 0;

                                    for (const video of data.videos) {
                                        const success = await addVideo(video.path);
                                        if (success) successCount++;
                                        else failCount++;
                                    }

                                    await openProject(currentProject.id);

                                    if (failCount === 0) {
                                        alert(`âœ… ${successCount}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                                    } else {
                                        alert(`âš ï¸ ì¶”ê°€ ì™„ë£Œ:\nì„±ê³µ: ${successCount}ê°œ\nì‹¤íŒ¨: ${failCount}ê°œ`);
                                    }
                                }
                            } else {
                                alert('ì„ íƒí•œ ë””ë ‰í† ë¦¬ì—ì„œ ë¹„ë””ì˜¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                            }
                        } catch (error) {
                            console.error('[VIDEO] Directory scan error:', error);
                            alert('ë””ë ‰í† ë¦¬ ìŠ¤ìº” ì˜¤ë¥˜: ' + error.message);
                        }
                    }
                } else {
                    // ë°©ë²• 2: íŒŒì¼ ì§ì ‘ ì„ íƒ (ê¸°ì¡´ ë°©ì‹)
                    const result = await window.electronAPI.openFileDialog({
                        properties: ['openFile', 'multiSelections'],
                        filters: [
                            { name: 'Videos', extensions: ['mp4', 'avi', 'mov', 'mkv'] }
                        ]
                    });

                    if (!result.canceled && result.filePaths.length > 0) {
                        console.log(`[VIDEO] Adding ${result.filePaths.length} video(s)...`);
                        let successCount = 0;
                        let failCount = 0;

                        for (const videoPath of result.filePaths) {
                            const success = await addVideo(videoPath);
                            if (success) successCount++;
                            else failCount++;
                        }

                        await openProject(currentProject.id);

                        if (failCount === 0) {
                            alert(`âœ… ${successCount}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                        } else {
                            alert(`âš ï¸ ì¶”ê°€ ì™„ë£Œ:\nì„±ê³µ: ${successCount}ê°œ\nì‹¤íŒ¨: ${failCount}ê°œ`);
                        }
                    }
                }
            } else {
                // ì›¹ ë¸Œë¼ìš°ì € í™˜ê²½: ì„ íƒ ì˜µì…˜ í‘œì‹œ
                const choice = confirm(
                    'ë¹„ë””ì˜¤ ì¶”ê°€ ë°©ë²•:\n\n' +
                    '[í™•ì¸] NAS ë¹„ë””ì˜¤ ì„ íƒ (ì„œë²„ì˜ NAS í´ë”ì—ì„œ ì„ íƒ)\n' +
                    '[ì·¨ì†Œ] íŒŒì¼ ì—…ë¡œë“œ (ë¡œì»¬ PCì—ì„œ íŒŒì¼ ì„ íƒ)'
                );

                if (choice) {
                    // NAS ë¹„ë””ì˜¤ ì„ íƒ
                    showNasVideoSelectionDialog();
                } else {
                    // íŒŒì¼ ì—…ë¡œë“œ (ê¸°ì¡´ ë°©ì‹)
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'video/mp4,video/avi,video/mov,video/x-matroska';
                    input.multiple = true; // ë‹¤ì¤‘ ì„ íƒ í™œì„±í™”
                    input.onchange = async (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length > 0) {
                            // ë¶€ëª¨ ë””ë ‰í† ë¦¬ëª… ì…ë ¥ë°›ê¸°
                            const parentDir = prompt(`${files.length}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì†í•œ ë””ë ‰í† ë¦¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­):\nì˜ˆ: 359-ì§‘ë°©-100MM-HIVP`, '');

                            console.log(`[VIDEO] Uploading ${files.length} video(s)...`);
                            let successCount = 0;
                            let failCount = 0;

                            // ì—¬ëŸ¬ íŒŒì¼ ìˆœì°¨ ì—…ë¡œë“œ
                            for (const file of files) {
                                const success = await addVideoFile(file, parentDir);
                                if (success) successCount++;
                                else failCount++;
                            }

                            // ì™„ë£Œ í›„ í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
                            await openProject(currentProject.id);

                            // ê²°ê³¼ ìš”ì•½ í‘œì‹œ
                            if (failCount === 0) {
                                alert(`âœ… ${successCount}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!`);
                            } else {
                                alert(`âš ï¸ ì—…ë¡œë“œ ì™„ë£Œ:\nì„±ê³µ: ${successCount}ê°œ\nì‹¤íŒ¨: ${failCount}ê°œ`);
                            }
                        }
                    };
                    input.click();
                }
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ê°€ (Electron í™˜ê²½ - íŒŒì¼ ê²½ë¡œ)
        async function addVideo(videoPath) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return false;
            }

            const fileName = videoPath.split('/').pop();
            console.log(`[VIDEO] Adding video: ${fileName}`);

            try {
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ video_path: videoPath })
                });

                const data = await response.json();

                if (data.success) {
                    console.log(`[VIDEO] âœ… Video added: ${fileName} (ID: ${data.video_id})`);
                    return true;
                } else {
                    console.error(`[VIDEO] âŒ Failed to add ${fileName}:`, data.error);
                    return false;
                }
            } catch (error) {
                console.error('[VIDEO] Add video error:', error);
                return false;
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ê°€ (ì›¹ ë¸Œë¼ìš°ì € í™˜ê²½ - File ê°ì²´)
        async function addVideoFile(file, parentDir) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return false;
            }

            // ì§„í–‰ ë°” í‘œì‹œ
            const progressDiv = document.getElementById('uploadProgress');
            const progressBar = document.getElementById('uploadProgressBar');
            const progressPercent = document.getElementById('uploadPercent');
            const fileName = document.getElementById('uploadFileName');
            const statusText = document.getElementById('uploadStatus');

            progressDiv.style.display = 'block';
            fileName.textContent = file.name;
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            statusText.textContent = 'ì—…ë¡œë“œ ì¤€ë¹„ ì¤‘...';

            return new Promise((resolve) => {
                const formData = new FormData();
                formData.append('video', file);
                // ë¶€ëª¨ ë””ë ‰í† ë¦¬ëª… ì¶”ê°€ (ìˆì„ ê²½ìš°)
                if (parentDir && parentDir.trim()) {
                    formData.append('parent_dir', parentDir.trim());
                }

                const xhr = new XMLHttpRequest();
                const sessionId = getSessionId();

                // ì—…ë¡œë“œ ì§„í–‰ë¥  ì¶”ì 
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percentComplete + '%';
                        progressPercent.textContent = percentComplete + '%';

                        const uploadedMB = (e.loaded / 1024 / 1024).toFixed(2);
                        const totalMB = (e.total / 1024 / 1024).toFixed(2);
                        statusText.textContent = `ì—…ë¡œë“œ ì¤‘... ${uploadedMB} MB / ${totalMB} MB`;
                    }
                });

                // ì—…ë¡œë“œ ì™„ë£Œ
                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        try {
                            const data = JSON.parse(xhr.responseText);

                            if (data.success) {
                                progressBar.style.background = 'linear-gradient(90deg, #4caf50, #45a049)';
                                statusText.textContent = 'âœ… ì—…ë¡œë“œ ì™„ë£Œ!';
                                console.log(`[VIDEO] âœ… Video uploaded: ${file.name} (ID: ${data.video_id})`);

                                setTimeout(() => {
                                    progressDiv.style.display = 'none';
                                    progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                                    resolve(true);
                                }, 1000);
                            } else {
                                progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                                statusText.textContent = 'âŒ ì˜¤ë¥˜: ' + data.error;
                                console.error(`[VIDEO] âŒ Failed to upload ${file.name}:`, data.error);
                                setTimeout(() => {
                                    progressDiv.style.display = 'none';
                                    progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                                    resolve(false);
                                }, 2000);
                            }
                        } catch (error) {
                            console.error('Parse error:', error);
                            progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                            statusText.textContent = 'âŒ ì‘ë‹µ ì²˜ë¦¬ ì˜¤ë¥˜';
                            setTimeout(() => {
                                progressDiv.style.display = 'none';
                                progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                                resolve(false);
                            }, 2000);
                        }
                    } else {
                        progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                        statusText.textContent = `âŒ ì—…ë¡œë“œ ì‹¤íŒ¨ (HTTP ${xhr.status})`;
                        console.error(`[VIDEO] âŒ Upload failed: HTTP ${xhr.status}`);
                        setTimeout(() => {
                            progressDiv.style.display = 'none';
                            progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                            resolve(false);
                        }, 2000);
                    }
                });

                // ì—…ë¡œë“œ ì—ëŸ¬
                xhr.addEventListener('error', () => {
                    progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                    statusText.textContent = 'âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜';
                    console.error(`[VIDEO] âŒ Network error while uploading ${file.name}`);
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                        progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                        resolve(false);
                    }, 2000);
                });

                // ì—…ë¡œë“œ ì·¨ì†Œ
                xhr.addEventListener('abort', () => {
                    progressBar.style.background = 'linear-gradient(90deg, #ff9800, #f57c00)';
                    statusText.textContent = 'âš ï¸ ì—…ë¡œë“œ ì·¨ì†Œë¨';
                    setTimeout(() => progressDiv.style.display = 'none', 2000);
                    reject(new Error('Upload cancelled'));
                });

                // ìš”ì²­ ì „ì†¡
                xhr.open('POST', API_BASE_URL + '/api/projects/' + currentProject.id + '/videos');
                xhr.setRequestHeader('X-Session-ID', sessionId);
                xhr.send(formData);
            });
        }

        // NAS ë¹„ë””ì˜¤ ì„ íƒ ê´€ë ¨ í•¨ìˆ˜ë“¤
        let nasVideos = [];
        let nasSelectedVideos = new Set();
        let nasCurrentPage = 1;
        let nasTotalPages = 1;
        let nasIsLoading = false;
        let nasCacheStats = null;
        let allUserCompletedVideos = new Set();  // ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ì™„ë£Œëœ ë¹„ë””ì˜¤

        // ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ì™„ë£Œëœ ë¹„ë””ì˜¤ ë¡œë“œ
        async function loadAllUserCompletedVideos() {
            console.log('[NAS] Loading all user completed videos...');
            allUserCompletedVideos.clear();

            try {
                // í˜„ì¬ ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch('/api/projects');
                const data = await response.json();

                if (data.success && data.projects) {
                    console.log(`[NAS] Found ${data.projects.length} projects`);

                    // ê° í”„ë¡œì íŠ¸ì˜ ì™„ë£Œëœ ë¹„ë””ì˜¤ ìˆ˜ì§‘
                    for (const project of data.projects) {
                        try {
                            const projectResponse = await authFetch(`/api/projects/${project.id}`);
                            const projectData = await projectResponse.json();

                            if (projectData.success && projectData.project.videos) {
                                projectData.project.videos.forEach(v => {
                                    if (v.status === 'completed') {
                                        // nas_video_pathì™€ filename ëª¨ë‘ ì €ì¥
                                        if (v.nas_video_path) {
                                            allUserCompletedVideos.add(v.nas_video_path);
                                        }
                                        if (v.filename) {
                                            allUserCompletedVideos.add(v.filename);
                                        }
                                    }
                                });
                            }
                        } catch (error) {
                            console.error(`[NAS] Error loading project ${project.id}:`, error);
                        }
                    }

                    console.log(`[NAS] Total completed videos: ${allUserCompletedVideos.size}`);
                }
            } catch (error) {
                console.error('[NAS] Error loading user projects:', error);
            }
        }

        async function showNasVideoSelectionDialog() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            console.log('[NAS] Opening NAS video selection dialog...');

            // ëª¨ë‹¬ í‘œì‹œ
            document.getElementById('nasVideoSelectionModal').classList.add('show');

            // ì´ˆê¸°í™”
            nasVideos = [];
            nasSelectedVideos.clear();
            nasCurrentPage = 1;

            // ì‚¬ìš©ìì˜ ëª¨ë“  ì™„ë£Œëœ ë¹„ë””ì˜¤ ë¡œë“œ
            await loadAllUserCompletedVideos();

            console.log('[NAS] Starting to load videos...');
            // ë¹„ë””ì˜¤ ëª©ë¡ì„ ë¨¼ì € ë¡œë“œ (ë¹ ë¦„)
            loadNasVideos(true);

            console.log('[NAS] Starting to load filter options...');
            // í•„í„° ì˜µì…˜ì€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¡œë“œ (ëŠë¦¼, ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ë¹„ë””ì˜¤ ëª©ë¡ì€ í‘œì‹œë¨)
            loadFilterOptions().catch(error => {
                console.error('[NAS] Error loading filter options:', error);
            });
        }

        async function loadFilterOptions() {
            try {
                const response = await authFetch('/api/nas-videos/filter-options');
                const data = await response.json();

                if (data.success) {
                    const options = data.options;

                    // ì§€ì—­ ì˜µì…˜ ì—…ë°ì´íŠ¸
                    const regionSelect = document.getElementById('nasRegionFilter');
                    regionSelect.innerHTML = '<option value="">ì „ì²´</option>';
                    options.regions.forEach(region => {
                        const option = document.createElement('option');
                        option.value = region;
                        option.textContent = region;
                        regionSelect.appendChild(option);
                    });

                    // í¬ê¸° ì˜µì…˜ ì—…ë°ì´íŠ¸
                    const sizeSelect = document.getElementById('nasPipeSizeFilter');
                    sizeSelect.innerHTML = '<option value="">ì „ì²´</option>';
                    options.pipe_sizes.forEach(size => {
                        const option = document.createElement('option');
                        option.value = size;
                        option.textContent = size;
                        sizeSelect.appendChild(option);
                    });

                    // ë°©ë²• ì˜µì…˜ ì—…ë°ì´íŠ¸
                    const methodSelect = document.getElementById('nasMethodFilter');
                    methodSelect.innerHTML = '<option value="">ì „ì²´</option>';
                    options.methods.forEach(method => {
                        const option = document.createElement('option');
                        option.value = method;
                        option.textContent = method;
                        methodSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('[NAS] Error loading filter options:', error);
            }
        }

        async function loadNasVideos(reset = false) {
            console.log('[NAS] loadNasVideos() called, reset:', reset, 'nasIsLoading:', nasIsLoading);
            if (nasIsLoading) {
                console.log('[NAS] Already loading, skipping...');
                return;
            }

            const loadingDiv = document.getElementById('nasLoading');
            const gridDiv = document.getElementById('nasVideoGrid');

            if (reset) {
                nasCurrentPage = 1;
                nasVideos = [];
                gridDiv.innerHTML = '';
            }

            nasIsLoading = true;
            loadingDiv.style.display = 'block';

            try {
                const folderFilter = document.getElementById('nasFolderFilter').value;
                const regionFilter = document.getElementById('nasRegionFilter').value;
                const pipeSizeFilter = document.getElementById('nasPipeSizeFilter').value;
                const methodFilter = document.getElementById('nasMethodFilter').value;

                // í˜ì´ì§€ë„¤ì´ì…˜ íŒŒë¼ë¯¸í„°
                const params = new URLSearchParams({
                    page: nasCurrentPage,
                    page_size: 50
                });

                if (folderFilter) {
                    params.append('folder', folderFilter);
                }
                if (regionFilter) {
                    params.append('region', regionFilter);
                }
                if (pipeSizeFilter) {
                    params.append('pipe_size', pipeSizeFilter);
                }
                if (methodFilter) {
                    params.append('method', methodFilter);
                }

                const url = `/api/nas-videos/list?${params}`;
                console.log('[NAS] Fetching:', url);
                const response = await authFetch(url);
                console.log('[NAS] Response received:', response.status);
                const data = await response.json();
                console.log('[NAS] Data:', data.success, data.videos?.length, 'videos');

                if (data.success) {
                    // ìƒˆ ë¹„ë””ì˜¤ ì¶”ê°€
                    nasVideos.push(...data.videos);

                    // í˜ì´ì§€ë„¤ì´ì…˜ ì •ë³´
                    const pagination = data.pagination;
                    nasTotalPages = pagination.total_pages;
                    nasCacheStats = data.cache_stats;

                    // ìºì‹œ í†µê³„ í‘œì‹œ
                    if (reset) {
                        // í´ë” í•„í„° ì˜µì…˜ ì—…ë°ì´íŠ¸
                        const folderSelect = document.getElementById('nasFolderFilter');
                        if (data.cache_stats && data.cache_stats.by_folder) {
                            // í˜„ì¬ ì„ íƒëœ ê°’ ì €ì¥
                            const currentValue = folderSelect.value;
                            const folders = Object.keys(data.cache_stats.by_folder);
                            folderSelect.innerHTML = '<option value="">ì „ì²´</option>';
                            folders.forEach(folder => {
                                const option = document.createElement('option');
                                option.value = folder;
                                option.textContent = `${folder} (${data.cache_stats.by_folder[folder]})`;
                                folderSelect.appendChild(option);
                            });
                            // ì´ì „ ì„ íƒ ê°’ ë³µì›
                            if (currentValue && folders.includes(currentValue)) {
                                folderSelect.value = currentValue;
                            }
                        }
                    }

                    // ë¹„ë””ì˜¤ ì¹´ë“œ ì¶”ê°€
                    data.videos.forEach(video => {
                        const card = createNasVideoCard(video);
                        gridDiv.appendChild(card);
                    });

                    // ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
                    const countSpan = document.getElementById('nasVideoCount');
                    countSpan.textContent = `${pagination.total_count}ê°œ ë¹„ë””ì˜¤ (${nasCurrentPage}/${pagination.total_pages} í˜ì´ì§€)`;

                    // "ë” ë³´ê¸°" ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
                    updateLoadMoreButton(pagination.has_next);

                } else {
                    throw new Error(data.error || 'Failed to load NAS videos');
                }
            } catch (error) {
                console.error('[NAS] Error loading videos:', error);
                console.error('[NAS] Error stack:', error.stack);
                alert('ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
                if (reset) {
                    gridDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #f44336;">âŒ ë¹„ë””ì˜¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + error.message + '</div>';
                }
            } finally {
                nasIsLoading = false;
                loadingDiv.style.display = 'none';
            }
        }

        function updateLoadMoreButton(hasNext) {
            let loadMoreBtn = document.getElementById('nasLoadMoreButton');

            if (!loadMoreBtn) {
                // "ë” ë³´ê¸°" ë²„íŠ¼ ìƒì„±
                loadMoreBtn = document.createElement('div');
                loadMoreBtn.id = 'nasLoadMoreButton';
                loadMoreBtn.style.cssText = 'text-align: center; padding: 20px;';
                loadMoreBtn.innerHTML = '<button onclick="loadMoreNasVideos()" style="padding: 10px 30px; background: #4a9eff;">ë” ë³´ê¸°</button>';
                document.getElementById('nasVideoGrid').insertAdjacentElement('afterend', loadMoreBtn);
            }

            loadMoreBtn.style.display = hasNext ? 'block' : 'none';
        }

        async function loadMoreNasVideos() {
            nasCurrentPage++;
            await loadNasVideos(false);
        }

        function filterNasVideos() {
            // í•„í„° ë³€ê²½ ì‹œ í˜ì´ì§€ ë¦¬ì…‹í•˜ê³  ë‹¤ì‹œ ë¡œë“œ
            loadNasVideos(true);
        }

        function createNasVideoCard(video) {
            const card = document.createElement('div');
            card.className = 'nas-video-card';
            card.dataset.videoPath = video.path;

            // ì„ íƒ ìƒíƒœ í™•ì¸
            if (nasSelectedVideos.has(video.path)) {
                card.classList.add('selected');
            }

            // ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ì™„ë£Œëœ ë¹„ë””ì˜¤ì¸ì§€ í™•ì¸
            const isCompleted = allUserCompletedVideos.has(video.path) || allUserCompletedVideos.has(video.name);

            // ì¸ë„¤ì¼ ë˜í¼ (ì™„ë£Œ ì˜¤ë²„ë ˆì´ë¥¼ ìœ„í•œ ì»¨í…Œì´ë„ˆ)
            const thumbnailWrapper = document.createElement('div');
            thumbnailWrapper.className = 'nas-video-thumbnail-wrapper';

            // ì¸ë„¤ì¼
            const thumbnail = document.createElement('img');
            thumbnail.className = 'nas-video-thumbnail';
            thumbnail.src = `${API_BASE_URL}/api/nas-videos/thumbnail?path=${encodeURIComponent(video.path)}`;
            thumbnail.alt = video.name;
            thumbnail.onerror = () => {
                thumbnail.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect fill="%23333" width="100" height="100"/><text x="50%" y="50%" text-anchor="middle" fill="%23888" font-size="12">No Preview</text></svg>';
            };

            thumbnailWrapper.appendChild(thumbnail);

            // ì™„ë£Œ ì˜¤ë²„ë ˆì´ ì¶”ê°€
            if (isCompleted) {
                const overlay = document.createElement('div');
                overlay.className = 'nas-video-completed-overlay';
                overlay.innerHTML = `
                    <div class="checkmark">âœ“</div>
                    <div>ì™„ë£Œ</div>
                `;
                thumbnailWrapper.appendChild(overlay);
            }

            // ë¹„ë””ì˜¤ ì •ë³´
            const info = document.createElement('div');
            info.className = 'nas-video-info';

            // ë””ë ‰í† ë¦¬ ë©”íƒ€ë°ì´í„° í‘œì‹œ (í•˜ì´í”ˆìœ¼ë¡œ êµ¬ë¶„ëœ ë¶€ë¶„ë“¤)
            const dirMetaParts = video.dir_metadata.parts || [];
            const dirMetaText = dirMetaParts.length > 0 ? dirMetaParts.join(' - ') : video.parent_dir;

            info.innerHTML = `
                <div class="nas-video-name" title="${video.name}">${video.name}</div>
                <div class="nas-video-meta">
                    <div>ğŸ“ ${video.nas_folder}</div>
                    ${dirMetaText ? `<div style="color: #4a9eff;">ğŸ“‹ ${dirMetaText}</div>` : ''}
                    <div>ğŸ“ ${video.size_mb} MB | â±ï¸ ${video.duration_str}</div>
                    <div>ğŸï¸ ${video.total_frames} frames | ${video.fps} fps</div>
                </div>
            `;

            card.appendChild(thumbnailWrapper);
            card.appendChild(info);

            // í´ë¦­ ì´ë²¤íŠ¸
            card.addEventListener('click', () => toggleNasVideoSelection(video.path, card));

            return card;
        }

        function toggleNasVideoSelection(videoPath, cardElement) {
            if (nasSelectedVideos.has(videoPath)) {
                nasSelectedVideos.delete(videoPath);
                cardElement.classList.remove('selected');
            } else {
                nasSelectedVideos.add(videoPath);
                cardElement.classList.add('selected');
            }

            updateNasSelectedCount();
        }

        function updateNasSelectedCount() {
            const countSpan = document.getElementById('nasSelectedCount');
            countSpan.textContent = `${nasSelectedVideos.size}ê°œ ì„ íƒë¨`;
        }

        async function addSelectedNasVideos() {
            if (nasSelectedVideos.size === 0) {
                alert('ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            // ì¤‘ë³µ ì²´í¬ - ì´ë¯¸ í”„ë¡œì íŠ¸ì— ìˆëŠ” ë¹„ë””ì˜¤ ê²½ë¡œ ìˆ˜ì§‘
            const existingPaths = new Set();
            if (currentProject.videos) {
                currentProject.videos.forEach(v => {
                    // NAS ë¹„ë””ì˜¤ ê²½ë¡œë¡œ ì²´í¬
                    if (v.nas_video_path) {
                        existingPaths.add(v.nas_video_path);
                    }
                    // íŒŒì¼ëª…ìœ¼ë¡œë„ ì²´í¬ (fallback)
                    if (v.filename) {
                        existingPaths.add(v.filename);
                    }
                });
            }

            // ì„ íƒëœ ë¹„ë””ì˜¤ë¥¼ ì‹ ê·œ/ì¤‘ë³µìœ¼ë¡œ ë¶„ë¥˜
            const videosToAdd = [];
            const duplicates = [];
            for (const videoPath of nasSelectedVideos) {
                const videoInfo = nasVideos.find(v => v.path === videoPath);
                const videoName = videoInfo?.name || videoPath.split('/').pop();

                if (existingPaths.has(videoPath) || existingPaths.has(videoName)) {
                    duplicates.push(videoName);
                } else {
                    videosToAdd.push(videoPath);
                }
            }

            // ì¤‘ë³µ ì•Œë¦¼ ë° í™•ì¸
            if (duplicates.length > 0) {
                const duplicateList = duplicates.slice(0, 5).join('\n  - ');
                const moreMsg = duplicates.length > 5 ? `\n  ... ì™¸ ${duplicates.length - 5}ê°œ` : '';

                if (videosToAdd.length === 0) {
                    alert(`ì„ íƒí•œ ëª¨ë“  ë¹„ë””ì˜¤ê°€ ì´ë¯¸ í”„ë¡œì íŠ¸ì— ìˆìŠµë‹ˆë‹¤.\n\nì¤‘ë³µëœ ë¹„ë””ì˜¤:\n  - ${duplicateList}${moreMsg}`);
                    return;
                }

                const confirmMsg = `${duplicates.length}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì´ë¯¸ í”„ë¡œì íŠ¸ì— ìˆìŠµë‹ˆë‹¤.\n\nì¤‘ë³µëœ ë¹„ë””ì˜¤:\n  - ${duplicateList}${moreMsg}\n\në‚˜ë¨¸ì§€ ${videosToAdd.length}ê°œì˜ ìƒˆ ë¹„ë””ì˜¤ë¥¼ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                if (!confirm(confirmMsg)) return;
            } else {
                const confirmAdd = confirm(`ì„ íƒí•œ ${videosToAdd.length}ê°œì˜ NAS ë¹„ë””ì˜¤ë¥¼ í”„ë¡œì íŠ¸ì— ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`);
                if (!confirmAdd) return;
            }

            console.log(`[NAS] Adding ${videosToAdd.length} NAS videos (${duplicates.length} duplicates skipped)...`);
            let successCount = 0;
            let failCount = 0;

            for (const videoPath of videosToAdd) {
                // í•´ë‹¹ ë¹„ë””ì˜¤ì˜ ë©”íƒ€ë°ì´í„° ì°¾ê¸°
                const videoInfo = nasVideos.find(v => v.path === videoPath);

                try {
                    const response = await authFetch(`/api/projects/${currentProject.id}/videos`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            nas_video_path: videoPath,
                            nas_metadata: videoInfo ? {
                                nas_folder: videoInfo.nas_folder,
                                parent_dir: videoInfo.parent_dir,
                                dir_metadata: videoInfo.dir_metadata,
                                size_mb: videoInfo.size_mb,
                                duration: videoInfo.duration,
                                fps: videoInfo.fps
                            } : {}
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        console.log(`[NAS] âœ… Added: ${videoInfo?.name || videoPath}`);
                        successCount++;
                    } else {
                        console.error(`[NAS] âŒ Failed: ${videoInfo?.name || videoPath}:`, data.error);
                        failCount++;
                    }
                } catch (error) {
                    console.error(`[NAS] âŒ Error adding ${videoInfo?.name || videoPath}:`, error);
                    failCount++;
                }
            }

            // ëª¨ë‹¬ ë‹«ê¸°
            closeNasVideoSelection();

            // í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
            await openProject(currentProject.id);

            // ê²°ê³¼ í‘œì‹œ
            let resultMsg = '';
            if (successCount > 0) {
                resultMsg = `âœ… ${successCount}ê°œì˜ NAS ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`;
            }
            if (duplicates.length > 0) {
                resultMsg += (resultMsg ? '\n' : '') + `âš ï¸ ${duplicates.length}ê°œëŠ” ì´ë¯¸ ì¡´ì¬í•˜ì—¬ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤.`;
            }
            if (failCount > 0) {
                resultMsg += (resultMsg ? '\n' : '') + `âŒ ${failCount}ê°œ ì¶”ê°€ ì‹¤íŒ¨`;
            }

            if (resultMsg) {
                alert(resultMsg);
            }
        }

        function closeNasVideoSelection() {
            document.getElementById('nasVideoSelectionModal').classList.remove('show');
            nasSelectedVideos.clear();
        }

        // ë¹„ë””ì˜¤ ìƒíƒœ í† ê¸€
        async function toggleVideoStatus(videoId, newStatus) {
            if (!currentProject) return;

            try {
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId + '/status', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status: newStatus })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[VIDEO STATUS] Status updated:', videoId, '->', newStatus);

                    // currentProjectì˜ ë¹„ë””ì˜¤ ìƒíƒœ ì—…ë°ì´íŠ¸
                    const video = currentProject.videos.find(v => v.video_id === videoId);
                    if (video) {
                        video.status = newStatus;
                    }

                    // í˜„ì¬ ì–´ë…¸í…Œì´ì…˜ ì¤‘ì¸ ë¹„ë””ì˜¤ë¼ë©´ ì „ì—­ ìƒíƒœë„ ì—…ë°ì´íŠ¸
                    if (currentVideoId === videoId) {
                        currentVideoStatus = newStatus;
                        updateAnnotationUIForStatus();
                    }

                    // UI ì—…ë°ì´íŠ¸
                    displayVideos();

                    // í”¼ë“œë°± ë©”ì‹œì§€
                    const msg = newStatus === 'completed' ? 'ë¹„ë””ì˜¤ê°€ ì™„ë£Œë¡œ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.' : 'ë¹„ë””ì˜¤ê°€ ì§„í–‰ì¤‘ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    console.log('[VIDEO STATUS]', msg);
                } else {
                    alert('ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[VIDEO STATUS] Error:', error);
                alert('ìƒíƒœ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ë¹„ë””ì˜¤ ì œê±°
        async function removeVideo(videoId) {
            if (!currentProject) return;

            if (!confirm('Are you sure you want to remove this video?\nAll video files and annotations will be deleted.')) {
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    alert('[OK] Video removed successfully.');
                    // í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
                    await openProject(currentProject.id);
                } else {
                    alert('[ERROR] Error: ' + data.error);
                }
            } catch (error) {
                console.error('Remove video error:', error);
                alert('[ERROR] Error: ' + error.message);
            }
        }

        // í”„ë¡œì íŠ¸ ìƒì„±
        async function createProject() {
            const nameInput = document.getElementById('projectName');
            const workerInput = document.getElementById('projectWorker');
            const name = nameInput.value.trim();
            const worker = workerInput.value.trim();

            console.log('Creating project:', { name, worker });  // ë””ë²„ê¹…ìš©

            if (!name) {
                alert('í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const requestBody = {
                    name,
                    classes: [
                        { name: 'normal', description: 'ì •ìƒë¶€' },
                        { name: 'deformation', description: 'ë³€í˜•' },
                        { name: 'crack', description: 'ê· ì—´' },
                        { name: 'corrosion', description: 'ë¶€ì‹' },
                        { name: 'sediment_soil', description: 'ì¹¨ì „ë¬¼(í™)' },
                        { name: 'sediment_sand', description: 'ì¹¨ì „ë¬¼(ëª¨ë˜)' },
                        { name: 'sediment_corrosion', description: 'ì¹¨ì „ë¬¼(ë¶€ì‹ ìƒì„±ë¬¼)' },
                        { name: 'sediment_coating', description: 'ì¹¨ì „ë¬¼(íƒˆë¦¬, ë„ì¥ì¬)' },
                        { name: 'sediment_other', description: 'ì¹¨ì „ë¬¼(ê¸°íƒ€)' },
                        { name: 'slime', description: 'ìŠ¬ë¼ì„(ë¬¼ë•Œ)' },
                        { name: 'vanishing_point', description: 'ì†Œì‹¤ì ' },
                        { name: 'needs_discussion', description: 'ë…¼ì˜í•„ìš”' }
                    ]  // ê¸°ë³¸ í´ë˜ìŠ¤
                };

                // ì‘ì—…ìê°€ ì…ë ¥ëœ ê²½ìš°ì—ë§Œ í¬í•¨
                if (worker) {
                    requestBody.worker = worker;
                }

                const response = await authFetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();
                console.log('Create project response:', data);  // ë””ë²„ê¹…ìš©

                if (data.success) {
                    const workerInfo = worker ? '\nì‘ì—…ì: ' + worker : '';
                    alert('[OK] í”„ë¡œì íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nID: ' + data.project.id + '\nì´ë¦„: ' + data.project.name + workerInfo + '\nê²½ë¡œ: ' + data.project.path);
                    nameInput.value = '';
                    workerInput.value = '';

                    // í”„ë¡œì íŠ¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì•½ê°„ì˜ ì§€ì—° í›„)
                    setTimeout(() => {
                        loadProjects();
                    }, 500);
                } else {
                    alert('[ERROR] Error: ' + data.error);
                }
            } catch (error) {
                console.error('Create project error:', error);
                alert('[ERROR] Error: ' + error.message);
            }
        }

        // ===== Annotation Tab Functions =====
        let videoElement = null;  // HTML5 video element for smooth playback
        let videoCanvas = null;
        let videoContext = null;
        let previewCanvas = null;
        let previewContext = null;
        let currentFrame = 0;
        let totalFrames = 0;
        let isPlaying = false;
        let renderLoopActive = false;  // Flag for video-to-canvas rendering loop
        let videoFPS = 30;  // Video FPS (will be updated on load)
        let useVideoElement = false;  // Flag to determine if video element can be used
        let frameAnnotations = {};  // {frameNum: [{box, label}, ...]} - í˜„ì¬ ì‘ì—… ì¤‘ì¸ ì–´ë…¸í…Œì´ì…˜
        let savedFrameAnnotations = {};  // Saveëœ ì–´ë…¸í…Œì´ì…˜ë§Œ (Statistics í‘œì‹œìš©)
        let annotationContributors = [];  // ì–´ë…¸í…Œì´ì…˜ ê¸°ì—¬ì ëª©ë¡
        let currentVideoPath = null;
        let currentVideoId = null;
        let currentProjectId = null;
        let currentVideoStatus = 'in_progress';  // í˜„ì¬ ë¹„ë””ì˜¤ ìƒíƒœ (in_progress, completed)
        let frameLoadAbortController = null;  // í”„ë ˆì„ ë¡œë“œ ìš”ì²­ ì·¨ì†Œìš© AbortController
        let sliderDebounceTimer = null;  // ìŠ¬ë¼ì´ë” ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸
        let lastSliderUpdate = 0;  // ë§ˆì§€ë§‰ ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸ ì‹œê°„ (throttleìš©)
        let isDrawing = false;
        let startX, startY;
        let currentBox = null;
        let currentFrameImage = null;  // í˜„ì¬ í”„ë ˆì„ ì´ë¯¸ì§€ (AI ì¶”ë¡  ê²°ê³¼ í¬í•¨)
        let originalFrameImage = null;  // ì›ë³¸ í”„ë ˆì„ ì´ë¯¸ì§€ (AI ì¶”ë¡  ì „)
        let aiInitialized = false;  // AI ì´ˆê¸°í™” ìƒíƒœ
        let aiAutoInferenceEnabled = false;  // AI ìë™ ì¶”ë¡  í™œì„±í™” ì—¬ë¶€ (ì‚¬ìš©ì ì„¤ì •)
        let selectedAnnotationIndex = -1;  // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ ì¸ë±ìŠ¤
        let isDraggingPoint = false;  // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘
        let draggingPointIndex = -1;  // ë“œë˜ê·¸ ì¤‘ì¸ í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        let editMode = 'select';  // í¸ì§‘ ëª¨ë“œ: 'select', 'draw', 'edit_polygon'

        // í´ë¦¬ê³¤ ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ëª¨ë“œ
        let isPolygonDrawMode = true;  // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ í™œì„±í™” ì—¬ë¶€ (ê¸°ë³¸ê°’: ON)
        let isCrosshairEnabled = false; // ì‹­ìì„  í‘œì‹œ ì—¬ë¶€
        let animationFrameId = null;  // requestAnimationFrame ID
        let needsRedraw = false;  // ë‹¤ì‹œ ê·¸ë ¤ì•¼ í•˜ëŠ”ì§€ í”Œë˜ê·¸
        let isDrawingPolygon = false;   // í´ë¦¬ê³¤ ë“œë˜ê·¸ ì¤‘
        let currentPolygonPoints = [];  // í˜„ì¬ ê·¸ë¦¬ê³  ìˆëŠ” í´ë¦¬ê³¤ ì ë“¤
        let selectedClassIndex = 0;     // ì„ íƒëœ í´ë˜ìŠ¤ ì¸ë±ìŠ¤ (ê¸°ë³¸ê°’: ì²« ë²ˆì§¸ í´ë˜ìŠ¤)
        let previewPolygon = null;      // ë“œë˜ê·¸ ì¤‘ í”„ë¦¬ë·° í´ë¦¬ê³¤
        let previewBox = null;          // ë°•ìŠ¤ ê·¸ë¦¬ê¸° í”„ë¦¬ë·°
        let isDraggingPolygonPoint = false;  // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘ í”„ë¦¬ë·°
        let draggedPolygon = null;      // ë“œë˜ê·¸ ì¤‘ì¸ í´ë¦¬ê³¤

        // í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ ì„ì‹œ í´ë˜ìŠ¤ ëª©ë¡
        let tempClassList = [];

        // í´ë˜ìŠ¤ë³„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (êµ¬ë¶„í•˜ê¸° ì‰¬ìš´ ë°ì€ ìƒ‰ìƒë“¤)
        const CLASS_COLORS = [
            '#FF6B6B', // ë¹¨ê°•
            '#4ECDC4', // ì²­ë¡
            '#45B7D1', // í•˜ëŠ˜ìƒ‰
            '#FFA07A', // ì—°ì–´ìƒ‰
            '#98D8C8', // ë¯¼íŠ¸
            '#F7DC6F', // ë…¸ë‘
            '#BB8FCE', // ë³´ë¼
            '#85C1E2', // íŒŒë‘
            '#F8B88B', // ì£¼í™©
            '#F06292', // í•‘í¬
            '#AED581', // ì—°ë‘
            '#FFD54F', // í™©ê¸ˆìƒ‰
            '#81C784', // ì´ˆë¡
            '#64B5F6', // ë°ì€ íŒŒë‘
            '#E57373', // ë°ì€ ë¹¨ê°•
            '#FFB74D', // í™©í† ìƒ‰
            '#BA68C8', // ë°ì€ ë³´ë¼
            '#4DB6AC', // ì²­ë¡2
            '#DCE775', // ë¼ì„
            '#A1887F'  // ê°ˆìƒ‰
        ];

        // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
        function getColorForClass(className) {
            if (!className) return '#00FF00'; // ê¸°ë³¸ ìƒ‰ìƒ

            if (!currentProject || !currentProject.classes) {
                // í´ë˜ìŠ¤ ì •ë³´ê°€ ì—†ìœ¼ë©´ í•´ì‹œë¡œ ìƒ‰ìƒ ê²°ì •
                let hash = 0;
                for (let i = 0; i < className.length; i++) {
                    hash = className.charCodeAt(i) + ((hash << 5) - hash);
                }
                return CLASS_COLORS[Math.abs(hash) % CLASS_COLORS.length];
            }

            // í´ë˜ìŠ¤ ì¸ë±ìŠ¤ ì°¾ê¸°
            const classIndex = currentProject.classes.findIndex(c => {
                const name = (typeof c === 'string') ? c : c.name;
                return name === className;
            });

            if (classIndex === -1) {
                // í´ë˜ìŠ¤ë¥¼ ì°¾ì§€ ëª»í•˜ë©´ í•´ì‹œë¡œ ìƒ‰ìƒ ê²°ì •
                let hash = 0;
                for (let i = 0; i < className.length; i++) {
                    hash = className.charCodeAt(i) + ((hash << 5) - hash);
                }
                return CLASS_COLORS[Math.abs(hash) % CLASS_COLORS.length];
            }

            return CLASS_COLORS[classIndex % CLASS_COLORS.length];
        }

        // ë¹„ë””ì˜¤ ë¡œë“œ
        async function loadAnnotationVideo() {
            const result = await window.electronAPI.openFileDialog({
                properties: ['openFile'],
                filters: [
                    { name: 'Videos', extensions: ['mp4', 'avi', 'mov', 'mkv'] }
                ]
            });

            if (!result.canceled && result.filePaths.length > 0) {
                currentVideoPath = result.filePaths[0];
                await initVideoPlayer(currentVideoPath);
            }
        }

        // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ì´ˆê¸°í™” (í•˜ì´ë¸Œë¦¬ë“œ: video + canvas)
        async function initVideoPlayer() {
            console.log('[VIDEO] Initializing hybrid video player');
            console.log('[VIDEO] Project ID:', currentProjectId);
            console.log('[VIDEO] Video ID:', currentVideoId);
            console.log('[VIDEO] Total frames:', totalFrames);

            // Get video element and canvases
            videoElement = document.getElementById('videoElement');
            videoCanvas = document.getElementById('videoCanvas');
            videoContext = videoCanvas.getContext('2d');
            previewCanvas = document.getElementById('previewCanvas');
            previewContext = previewCanvas.getContext('2d');

            currentFrame = 0;

            // Load video source from streaming endpoint
            // Add session_id as query parameter for HTML5 video tag
            const sessionId = getSessionId();
            const videoStreamUrl = `/api/projects/${currentProjectId}/videos/${currentVideoId}/stream?session_id=${sessionId}`;
            console.log('[VIDEO] Loading video from:', videoStreamUrl);

            // Set video source with session_id in URL
            videoElement.src = videoStreamUrl;

            // Wait for video metadata to load
            await new Promise((resolve, reject) => {
                videoElement.onloadedmetadata = () => {
                    console.log('[VIDEO] Video metadata loaded');
                    console.log('[VIDEO] Duration:', videoElement.duration, 'seconds');
                    console.log('[VIDEO] Video size:', videoElement.videoWidth, 'x', videoElement.videoHeight);

                    // Calculate FPS
                    videoFPS = totalFrames / videoElement.duration;
                    console.log('[VIDEO] Calculated FPS:', videoFPS);

                    // Set canvas size to match video
                    videoCanvas.width = videoElement.videoWidth;
                    videoCanvas.height = videoElement.videoHeight;
                    previewCanvas.width = videoElement.videoWidth;
                    previewCanvas.height = videoElement.videoHeight;

                    resolve();
                };

                videoElement.onerror = (error) => {
                    console.error('[VIDEO] Error loading video:', error);
                    reject(error);
                };
            });

            // Draw first frame to canvas
            videoContext.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);

            // Load first frame's precise image for annotation
            await loadFrame(0);

            // Set up video event listeners
            videoElement.ontimeupdate = () => {
                if (isPlaying) {
                    // Update current frame based on video time
                    currentFrame = Math.floor(videoElement.currentTime * videoFPS);
                    // Clamp currentFrame to valid range
                    currentFrame = Math.min(currentFrame, totalFrames - 1);
                    currentFrame = Math.max(currentFrame, 0);
                    updateFrameLabel();
                }
            };

            // Handle video end event
            videoElement.onended = () => {
                console.log('[VIDEO] Video playback ended');
                // Stop playback
                isPlaying = false;
                renderLoopActive = false;
                // Set to last frame
                currentFrame = totalFrames - 1;
                videoElement.currentTime = currentFrame / videoFPS;
                // Update button state
                document.getElementById('playBtn').textContent = 'â–¶ ì¬ìƒ';
                // Load last frame for annotation
                loadFrame(currentFrame);
                updateFrameLabel();
            };

            // ì»¨íŠ¸ë¡¤ í™œì„±í™”
            document.getElementById('playBtn').disabled = false;
            document.getElementById('prevFrameBtn').disabled = false;
            document.getElementById('nextFrameBtn').disabled = false;
            document.getElementById('skip15BackBtn').disabled = false;
            document.getElementById('skip15ForwardBtn').disabled = false;
            document.getElementById('frameSlider').disabled = false;
            document.getElementById('frameSlider').max = totalFrames - 1;

            updateFrameLabel();

            // ìº”ë²„ìŠ¤ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë“±ë¡
            setupCanvasEvents();

            // ê¸°ì¡´ ì–´ë…¸í…Œì´ì…˜ ìë™ ë¡œë“œ
            await autoLoadAnnotations();

            // AI ìƒíƒœ í™•ì¸
            await checkAIStatus();

            console.log('[VIDEO] Hybrid video player initialized');
        }

        // ë¹„ë””ì˜¤ë¥¼ ìº”ë²„ìŠ¤ë¡œ ë Œë”ë§ (ì¬ìƒ ì¤‘ ì‹¤ì‹œê°„ ë Œë”ë§)
        function renderVideoToCanvas() {
            if (!renderLoopActive) {
                return;
            }

            // Draw current video frame to canvas
            videoContext.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);

            // Draw annotations for current frame on top
            drawAnnotationsOnCanvas();

            // Continue rendering loop
            requestAnimationFrame(renderVideoToCanvas);
        }

        // ìº”ë²„ìŠ¤ì— í˜„ì¬ í”„ë ˆì„ì˜ ì–´ë…¸í…Œì´ì…˜ ê·¸ë¦¬ê¸° (ì¬ìƒ ì¤‘)
        function drawAnnotationsOnCanvas() {
            const annotations = frameAnnotations[currentFrame] || [];

            annotations.forEach((anno, index) => {
                const isSelected = index === selectedAnnotationIndex;
                const className = anno.category || anno.label || 'Unknown';
                const classColor = getColorForClass(className);

                if (anno.segmentation && anno.segmentation.length > 0) {
                    // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
                    const polygon = anno.segmentation[0];
                    videoContext.beginPath();
                    videoContext.moveTo(polygon[0], polygon[1]);
                    for (let i = 2; i < polygon.length; i += 2) {
                        videoContext.lineTo(polygon[i], polygon[i + 1]);
                    }
                    videoContext.closePath();
                    videoContext.strokeStyle = isSelected ? '#ffff00' : classColor;
                    videoContext.lineWidth = isSelected ? 3 : 2;
                    videoContext.stroke();

                    // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
                    if (isSelected) {
                        for (let i = 0; i < polygon.length; i += 2) {
                            videoContext.beginPath();
                            videoContext.arc(polygon[i], polygon[i + 1], 5, 0, 2 * Math.PI);
                            videoContext.fillStyle = '#ffff00';
                            videoContext.fill();
                        }
                    }

                    // ë ˆì´ë¸” í‘œì‹œ
                    const label = getDisplayLabel(className);
                    const minX = Math.min(...polygon.filter((_, i) => i % 2 === 0));
                    const minY = Math.min(...polygon.filter((_, i) => i % 2 === 1));

                    videoContext.fillStyle = isSelected ? '#ffff00' : classColor;
                    videoContext.fillRect(minX, minY - 40, 200, 40);
                    videoContext.fillStyle = '#000';
                    videoContext.font = '28px Arial';
                    videoContext.fillText(label, minX + 5, minY - 10);
                } else if (anno.bbox) {
                    // ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                    const box = anno.bbox;
                    const label = getDisplayLabel(className);
                    const color = isSelected ? '#ffff00' : classColor;
                    const lineWidth = isSelected ? 3 : 2;

                    videoContext.strokeStyle = color;
                    videoContext.lineWidth = lineWidth;
                    videoContext.strokeRect(box.x, box.y, box.width, box.height);

                    // ë ˆì´ë¸” í‘œì‹œ
                    videoContext.fillStyle = color;
                    videoContext.fillRect(box.x, box.y - 40, 200, 40);
                    videoContext.fillStyle = '#000';
                    videoContext.font = '28px Arial';
                    videoContext.fillText(label, box.x + 5, box.y - 10);
                }
            });
        }

        // í”„ë ˆì„ ë¡œë“œ
        async function loadFrame(frameNumber, abortSignal = null) {
            try {
                // í”„ë ˆì„ ë³€ê²½ ì‹œ ì„ íƒ í•´ì œ
                selectedAnnotationIndex = -1;

                // authFetchë¥¼ ì‚¬ìš©í•˜ì—¬ ì¸ì¦ëœ ìš”ì²­ìœ¼ë¡œ í”„ë ˆì„ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
                const frameUrl = '/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/frame/' + frameNumber;
                console.log('[FRAME] Loading frame:', frameNumber, 'using authFetch');

                // AbortSignalì„ authFetchì— ì „ë‹¬
                const fetchOptions = abortSignal ? { signal: abortSignal } : {};
                const response = await authFetch(frameUrl, fetchOptions);

                if (!response.ok) {
                    throw new Error('Failed to load frame: ' + response.status);
                }

                // ì‘ë‹µì„ Blobìœ¼ë¡œ ë³€í™˜
                const blob = await response.blob();

                // Blobì„ data URLë¡œ ë³€í™˜
                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });

                currentFrameImage = new Image();

                return new Promise((resolve, reject) => {
                    currentFrameImage.onload = async () => {
                        console.log('[FRAME] Frame loaded:', frameNumber);
                        console.log('[FRAME] Image size:', currentFrameImage.width, 'x', currentFrameImage.height);

                        // ì›ë³¸ í”„ë ˆì„ ì´ë¯¸ì§€ ì €ì¥ (AI ì¶”ë¡  ê²°ê³¼ë¥¼ ëˆ„ì í•˜ê¸° ìœ„í•´)
                        originalFrameImage = new Image();
                        originalFrameImage.src = currentFrameImage.src;

                        // ì²« í”„ë ˆì„ì—ì„œ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                        if (frameNumber === 0) {
                            videoCanvas.width = currentFrameImage.width;
                            videoCanvas.height = currentFrameImage.height;
                            previewCanvas.width = currentFrameImage.width;
                            previewCanvas.height = currentFrameImage.height;
                            console.log('[FRAME] Canvas size set to:', videoCanvas.width, 'x', videoCanvas.height);
                        }

                        // ì €ì¥ëœ ì–´ë…¸í…Œì´ì…˜ì´ ìˆê³  ë§ˆìŠ¤í¬ê°€ ìˆìœ¼ë©´ ë§ˆìŠ¤í¬ í‘œì‹œ, ì•„ë‹ˆë©´ ê¸°ë³¸ drawFrame
                        const savedAnnotations = frameAnnotations[frameNumber] || [];
                        const hasMasks = savedAnnotations.some(anno => anno.has_segmentation && anno.mask);

                        if (hasMasks) {
                            console.log('[FRAME] Drawing frame with masks');
                            await drawFrameWithMasks();
                        } else {
                            drawFrame();
                        }

                        // AI ìë™ ì¶”ë¡  ê¸°ëŠ¥ ë¹„í™œì„±í™”ë¨
                        // (ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ë¡  ì œê±°)

                        resolve();
                    };

                    currentFrameImage.onerror = (error) => {
                        console.error('[FRAME] Error loading frame:', error);
                        reject(error);
                    };

                    // data URLì„ ì´ë¯¸ì§€ srcë¡œ ì„¤ì •
                    currentFrameImage.src = dataUrl;
                });
            } catch (error) {
                // AbortErrorëŠ” ì •ìƒì ì¸ ìš”ì²­ ì·¨ì†Œì´ë¯€ë¡œ ì¡°ìš©íˆ ë¬´ì‹œ
                if (error.name === 'AbortError') {
                    console.log('[FRAME] Frame load aborted (ìŠ¬ë¼ì´ë” ì´ë™ ì¤‘):', frameNumber);
                    return;
                }
                console.error('[FRAME] Failed to load frame:', error);
                throw error;
            }
        }

        // í´ë˜ìŠ¤ ë¼ë””ì˜¤ ë²„íŠ¼ ìƒì„± (UI ì œê±°ë¨ - ë¹„í™œì„±í™”)
        function updateClassRadioButtons() {
            const container = document.getElementById('classRadioButtons');

            // UI ìš”ì†Œê°€ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ í•¨ìˆ˜ ë¹„í™œì„±í™”
            if (!container) {
                return;
            }

            if (!currentProject || !currentProject.classes) {
                container.innerHTML = '<p style="color: #888; font-size: 11px;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
                return;
            }

            // classes ë°ì´í„° ì •ê·œí™”
            let classes = currentProject.classes;
            if (typeof classes === 'string') {
                // ë¬¸ìì—´ì¸ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)
                classes = classes.split(',').map(c => c.trim()).filter(c => c.length > 0);
                classes = classes.map(name => ({ name: name, description: '' }));
                currentProject.classes = classes;
            } else if (Array.isArray(classes)) {
                // ë°°ì—´ ìš”ì†Œ ì •ê·œí™”
                classes = classes.map(cls => {
                    if (typeof cls === 'string') {
                        return { name: cls, description: '' };
                    } else if (cls.name) {
                        return { name: cls.name, description: cls.description || '' };
                    }
                    return null;
                }).filter(cls => cls !== null);
                currentProject.classes = classes;
            } else {
                classes = [];
                currentProject.classes = [];
            }

            if (classes.length === 0) {
                container.innerHTML = '<p style="color: #888; font-size: 11px;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
                return;
            }
            container.innerHTML = '';

            classes.forEach((classObj, index) => {
                const label = document.createElement('label');
                label.style.display = 'block';
                label.style.padding = '5px';
                label.style.cursor = 'pointer';
                label.style.fontSize = '12px';
                label.style.color = '#ddd';
                // Tooltip: í•œê¸€ ëª¨ë“œë©´ ì˜ë¬¸ í‘œì‹œ, ì˜ë¬¸ ëª¨ë“œë©´ í•œê¸€ í‘œì‹œ
                label.title = (currentLanguage === 'ko' ? classObj.name : classObj.description) || '';

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'classSelection';
                radio.value = index;
                radio.checked = (index === selectedClassIndex);
                radio.style.marginRight = '8px';
                radio.onchange = function() {
                    selectedClassIndex = index;
                    console.log('[CLASS] Selected class:', classObj.name, 'index:', index);
                };

                label.appendChild(radio);
                label.appendChild(document.createTextNode(getClassDisplayName(classObj)));
                container.appendChild(label);
            });

            console.log('[CLASS] Created', classes.length, 'radio buttons');
        }

        // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ í† ê¸€
        function togglePolygonDrawMode() {
            isPolygonDrawMode = !isPolygonDrawMode;
            const btn = document.getElementById('polygonDrawBtn');

            if (isPolygonDrawMode) {
                btn.textContent = 'ğŸ–Šï¸ Manual Polygon (ON)';
                btn.style.background = '#4a9eff';
                btn.style.borderColor = '#4a9eff';

                // ì»¤ì„œë§Œ ë³€ê²½ (ì‹­ìì„ ì€ ë³„ë„ í† ê¸€)
                videoCanvas.classList.add('crosshair-cursor');

                console.log('[POLYGON] Draw mode enabled');
            } else {
                btn.textContent = 'ğŸ–Šï¸ Manual Polygon (OFF)';
                btn.style.background = '#2d2d2d';
                btn.style.borderColor = '#404040';

                // ì»¤ì„œ ë³µì›
                videoCanvas.classList.remove('crosshair-cursor');

                // ê·¸ë¦¬ê¸° ì¤‘ì´ì—ˆìœ¼ë©´ ì·¨ì†Œ
                if (isDrawingPolygon) {
                    isDrawingPolygon = false;
                    currentPolygonPoints = [];
                    drawFrameWithMasks();
                }
                console.log('[POLYGON] Draw mode disabled');
            }
        }

        // ì‹­ìì„  í† ê¸€
        function toggleCrosshair() {
            const checkbox = document.getElementById('crosshairToggle');
            isCrosshairEnabled = checkbox.checked;
            const crosshairLines = document.getElementById('crosshair-lines');

            if (isCrosshairEnabled) {
                crosshairLines.classList.add('active');
                // ì‹­ìì„ ì´ ì¼œì§€ë©´ ì»¤ì„œ ìˆ¨ê¹€
                if (isPolygonDrawMode) {
                    videoCanvas.classList.add('hide-cursor');
                }
                console.log('[CROSSHAIR] Enabled');
            } else {
                crosshairLines.classList.remove('active');
                // ì‹­ìì„ ì´ êº¼ì§€ë©´ ì»¤ì„œ í‘œì‹œ
                videoCanvas.classList.remove('hide-cursor');
                console.log('[CROSSHAIR] Disabled');
            }
        }

        function toggleAutoInference() {
            const checkbox = document.getElementById('autoInferenceToggle');

            if (checkbox.checked) {
                // AI ì´ˆê¸°í™” ìƒíƒœ ì²´í¬
                if (!aiInitialized) {
                    alert('AI ëª¨ë¸ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\nGPU ì„œë²„ë¥¼ ì‹œì‘í•˜ê±°ë‚˜ AI ëª¨ë¸ì„ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                    checkbox.checked = false;
                    return;
                }

                // AI ìë™ ì¶”ë¡  í™œì„±í™” â†’ ë°•ìŠ¤ ëª¨ë“œë¡œ ì „í™˜
                aiAutoInferenceEnabled = true;
                isPolygonDrawMode = false;
                videoCanvas.classList.remove('crosshair-cursor');

                // ê·¸ë¦¬ê¸° ì¤‘ì´ì—ˆìœ¼ë©´ ì·¨ì†Œ
                if (isDrawingPolygon) {
                    isDrawingPolygon = false;
                    currentPolygonPoints = [];
                    drawFrameWithMasks();
                }

                console.log('[AI AUTO-INFERENCE] Enabled - Box mode');
            } else {
                // AI ìë™ ì¶”ë¡  ë¹„í™œì„±í™” â†’ í´ë¦¬ê³¤ ëª¨ë“œë¡œ ì „í™˜
                aiAutoInferenceEnabled = false;
                isPolygonDrawMode = true;
                videoCanvas.classList.add('crosshair-cursor');

                console.log('[AI AUTO-INFERENCE] Disabled - Polygon mode');
            }
        }

        // ì‹­ìì„  ìš”ì†Œ ìºì‹±
        let crosshairElements = null;
        let crosshairUpdateScheduled = false;
        let crosshairX = 0;
        let crosshairY = 0;

        function initCrosshairElements() {
            if (!crosshairElements) {
                const crosshairLines = document.getElementById('crosshair-lines');
                crosshairElements = {
                    hLine: crosshairLines.querySelector('.crosshair-h'),
                    vLine: crosshairLines.querySelector('.crosshair-v'),
                    container: document.getElementById('canvasContainer')
                };
            }
        }

        // ì‹­ìì„  ë§ˆìš°ìŠ¤ ì¶”ì 
        function updateCrosshair(e) {
            if (!isPolygonDrawMode || !isCrosshairEnabled) return;

            initCrosshairElements();

            const rect = crosshairElements.container.getBoundingClientRect();
            crosshairX = e.clientX - rect.left;
            crosshairY = e.clientY - rect.top;

            if (!crosshairUpdateScheduled) {
                crosshairUpdateScheduled = true;
                requestAnimationFrame(() => {
                    if (crosshairElements.hLine && crosshairElements.vLine) {
                        crosshairElements.hLine.style.top = crosshairY + 'px';
                        crosshairElements.vLine.style.left = crosshairX + 'px';
                    }
                    crosshairUpdateScheduled = false;
                });
            }
        }

        // í´ë¦¬ê³¤ ë³´ê°„ì„ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
        function getVideoScaleFactor() {
            const videoWidth = videoElement.videoWidth || 1920;
            const videoHeight = videoElement.videoHeight || 1080;
            return Math.sqrt((videoWidth * videoHeight) / (1920 * 1080));
        }

        function interpolatePolygonPoints(points, scaleFactor) {
            if (points.length < 2) return points;

            const segments = Math.max(6, Math.floor(20 * scaleFactor));
            const interpolated = [];

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];

                for (let j = 0; j < segments; j++) {
                    const t = j / segments;
                    interpolated.push({
                        x: p1.x + (p2.x - p1.x) * t,
                        y: p1.y + (p2.y - p1.y) * t
                    });
                }
            }
            return interpolated;
        }

        // requestAnimationFrameì„ ì‚¬ìš©í•œ ìµœì í™”ëœ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        function scheduleRedraw() {
            if (!needsRedraw) {
                needsRedraw = true;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                animationFrameId = requestAnimationFrame(() => {
                    // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                    previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

                    // í”„ë¦¬ë·° í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° (ë³´ê°„ ì ìš©)
                    if (previewPolygon && previewPolygon.length > 0) {
                        const scaleFactor = getVideoScaleFactor();
                        const smoothPreview = previewPolygon.length >= 3 ?
                            interpolatePolygonPoints(previewPolygon, scaleFactor) :
                            previewPolygon;

                        previewContext.strokeStyle = '#00ff00';
                        previewContext.lineWidth = 3;
                        previewContext.setLineDash([]);

                        previewContext.beginPath();
                        previewContext.moveTo(smoothPreview[0].x, smoothPreview[0].y);
                        for (let i = 1; i < smoothPreview.length; i++) {
                            previewContext.lineTo(smoothPreview[i].x, smoothPreview[i].y);
                        }
                        previewContext.stroke();

                        // ì  í‘œì‹œ
                        previewPolygon.forEach((point, idx) => {
                            previewContext.fillStyle = idx === 0 ? '#ff0000' : '#00ff00';
                            previewContext.beginPath();
                            previewContext.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                            previewContext.fill();
                        });
                    }

                    // í”„ë¦¬ë·° ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                    if (previewBox) {
                        previewContext.strokeStyle = '#ff0000';
                        previewContext.lineWidth = 2;
                        previewContext.setLineDash([5, 5]);
                        previewContext.strokeRect(previewBox.x, previewBox.y, previewBox.width, previewBox.height);
                        previewContext.setLineDash([]);
                    }

                    // ë“œë˜ê·¸ ì¤‘ì¸ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° (í¬ì¸íŠ¸ í¸ì§‘) - ë³´ê°„ ì ìš©
                    if (draggedPolygon && draggedPolygon.length > 0) {
                        const scaleFactor = getVideoScaleFactor();
                        const smoothDragged = draggedPolygon.length >= 3 ?
                            interpolatePolygonPoints(draggedPolygon, scaleFactor) :
                            draggedPolygon;

                        previewContext.strokeStyle = '#ffff00';  // ë…¸ë€ìƒ‰ìœ¼ë¡œ êµ¬ë¶„
                        previewContext.lineWidth = 3;
                        previewContext.setLineDash([]);

                        previewContext.beginPath();
                        previewContext.moveTo(smoothDragged[0].x, smoothDragged[0].y);
                        for (let i = 1; i < smoothDragged.length; i++) {
                            previewContext.lineTo(smoothDragged[i].x, smoothDragged[i].y);
                        }
                        previewContext.closePath();
                        previewContext.stroke();

                        // ì  í‘œì‹œ
                        draggedPolygon.forEach((point, idx) => {
                            previewContext.fillStyle = '#ffff00';
                            previewContext.beginPath();
                            previewContext.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                            previewContext.fill();
                        });
                    }

                    needsRedraw = false;
                    animationFrameId = null;
                });
            }
        }

        // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ì„¤ì •
        function setupCanvasEvents() {
            videoCanvas.addEventListener('mousedown', onCanvasMouseDown);
            videoCanvas.addEventListener('mousemove', onCanvasMouseMove);
            videoCanvas.addEventListener('mouseup', onCanvasMouseUp);
            videoCanvas.addEventListener('contextmenu', onCanvasRightClick);

            // ì‹­ìì„  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì´ë²¤íŠ¸
            const canvasContainer = document.getElementById('canvasContainer');
            canvasContainer.addEventListener('mousemove', updateCrosshair);

            // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
            document.addEventListener('click', hideContextMenu);
        }

        // í¬ì¸íŠ¸ê°€ ë°•ìŠ¤ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
        function isPointInBox(x, y, box) {
            return x >= box.x && x <= box.x + box.width &&
                   y >= box.y && y <= box.y + box.height;
        }

        // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ê·¼ì²˜ì¸ì§€ í™•ì¸ (10px ë°˜ê²½)
        function findNearbyPolygonPoint(x, y, polygon, threshold = 10) {
            if (!polygon || polygon.length === 0) return -1;

            for (let i = 0; i < polygon.length; i++) {
                const dx = x - polygon[i].x;
                const dy = y - polygon[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= threshold) {
                    return i;
                }
            }
            return -1;
        }

        // í¬ì¸íŠ¸ê°€ í´ë¦¬ê³¤ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
        function isPointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;

            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // ë§ˆìš°ìŠ¤ ë‹¤ìš´
        function onCanvasMouseDown(e) {
            // ìš°í´ë¦­ì€ ë¬´ì‹œ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ìš©)
            if (e.button === 2) {
                console.log('[MOUSE] Right-click mousedown ignored');
                return;
            }

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                console.log('[VIDEO STATUS] Cannot draw on completed video');
                return;
            }

            const rect = videoCanvas.getBoundingClientRect();
            const scaleX = videoCanvas.width / rect.width;
            const scaleY = videoCanvas.height / rect.height;

            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ: ë“œë˜ê·¸ ì‹œì‘
            if (isPolygonDrawMode) {
                isDrawingPolygon = true;
                currentPolygonPoints = [{x: clickX, y: clickY}];
                console.log('[POLYGON] Start drawing polygon');
                return;
            }

            // ê¸°ì¡´ ì–´ë…¸í…Œì´ì…˜ í´ë¦­ í™•ì¸
            const annotations = frameAnnotations[currentFrame] || [];
            let clickedIndex = -1;

            // ë¨¼ì € ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì˜ í´ë¦¬ê³¤ í¬ì¸íŠ¸ í´ë¦­ í™•ì¸
            if (selectedAnnotationIndex !== -1 && selectedAnnotationIndex < annotations.length) {
                const selectedAnno = annotations[selectedAnnotationIndex];
                if (selectedAnno.polygon && selectedAnno.polygon.length > 0) {
                    const pointIndex = findNearbyPolygonPoint(clickX, clickY, selectedAnno.polygon);
                    if (pointIndex !== -1) {
                        // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì‹œì‘
                        isDraggingPoint = true;
                        draggingPointIndex = pointIndex;
                        console.log('[POLYGON] Start dragging point', pointIndex);
                        return;
                    }
                }
            }

            // ì—­ìˆœìœ¼ë¡œ ê²€ìƒ‰ (ë‚˜ì¤‘ì— ê·¸ë ¤ì§„ ê²ƒì´ ìœ„ì— ìˆìœ¼ë¯€ë¡œ)
            for (let i = annotations.length - 1; i >= 0; i--) {
                const anno = annotations[i];

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ í´ë¦¬ê³¤ ë‚´ë¶€ ì²´í¬
                if (anno.polygon && anno.polygon.length > 0) {
                    if (isPointInPolygon(clickX, clickY, anno.polygon)) {
                        clickedIndex = i;
                        break;
                    }
                } else if (isPointInBox(clickX, clickY, anno.box)) {
                    // í´ë¦¬ê³¤ì´ ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ ì²´í¬
                    clickedIndex = i;
                    break;
                }
            }

            if (clickedIndex !== -1) {
                // ì–´ë…¸í…Œì´ì…˜ ì„ íƒ
                selectedAnnotationIndex = clickedIndex;
                drawFrameWithMasks();
                updateAnnotationList();
                console.log('[ANNOTATION] Selected annotation', clickedIndex);
                return;
            }

            // ìƒˆ ë°•ìŠ¤ ê·¸ë¦¬ê¸° ì‹œì‘
            selectedAnnotationIndex = -1;
            startX = clickX;
            startY = clickY;
            isDrawing = true;
        }

        // ë§ˆìš°ìŠ¤ ì´ë™
        function onCanvasMouseMove(e) {
            const rect = videoCanvas.getBoundingClientRect();
            const scaleX = videoCanvas.width / rect.width;
            const scaleY = videoCanvas.height / rect.height;

            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;

            // í´ë¦¬ê³¤ ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ì¤‘
            if (isDrawingPolygon) {
                // ë§ˆì§€ë§‰ ì ê³¼ì˜ ê±°ë¦¬ê°€ ì¼ì • ì´ìƒì´ë©´ ìƒˆ ì  ì¶”ê°€ (ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
                const lastPoint = currentPolygonPoints[currentPolygonPoints.length - 1];
                const dx = currentX - lastPoint.x;
                const dy = currentY - lastPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 20í”½ì…€ ì´ìƒ ì›€ì§ì´ë©´ ìƒˆ ì  ì¶”ê°€ (ì  ê°œìˆ˜ 25%ë¡œ ê°ì†Œ)
                if (distance > 20) {
                    currentPolygonPoints.push({x: currentX, y: currentY});

                    // í”„ë¦¬ë·° í´ë¦¬ê³¤ ì—…ë°ì´íŠ¸
                    previewPolygon = [...currentPolygonPoints];
                    scheduleRedraw();
                }
                return;
            }

            // ì»¤ì„œ ìŠ¤íƒ€ì¼ ë³€ê²½ (í´ë¦¬ê³¤ í¬ì¸íŠ¸ ìœ„ì— ìˆì„ ë•Œ)
            if (!isDraggingPoint && !isDrawing && !isPolygonDrawMode) {
                const annotations = frameAnnotations[currentFrame] || [];
                if (selectedAnnotationIndex !== -1 && selectedAnnotationIndex < annotations.length) {
                    const selectedAnno = annotations[selectedAnnotationIndex];
                    if (selectedAnno.polygon && selectedAnno.polygon.length > 0) {
                        const nearbyPoint = findNearbyPolygonPoint(currentX, currentY, selectedAnno.polygon);
                        videoCanvas.style.cursor = nearbyPoint !== -1 ? 'move' : 'default';
                    } else {
                        videoCanvas.style.cursor = 'default';
                    }
                } else {
                    videoCanvas.style.cursor = 'crosshair';
                }
            }

            // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘
            if (isDraggingPoint) {
                const annotations = frameAnnotations[currentFrame] || [];
                if (selectedAnnotationIndex !== -1 && selectedAnnotationIndex < annotations.length) {
                    const anno = annotations[selectedAnnotationIndex];
                    if (anno.polygon && draggingPointIndex !== -1) {
                        // ë“œë˜ê·¸ ì¤‘ì¸ í´ë¦¬ê³¤ ë³µì‚¬ ë° í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸
                        draggedPolygon = anno.polygon.map((p, i) => ({
                            x: i === draggingPointIndex ? currentX : p.x,
                            y: i === draggingPointIndex ? currentY : p.y
                        }));

                        // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ì—ë§Œ ê·¸ë¦¬ê¸°
                        scheduleRedraw();
                    }
                }
                return;
            }

            // ë°•ìŠ¤ ê·¸ë¦¬ê¸° ì¤‘
            if (!isDrawing) return;

            // ë°•ìŠ¤ ê·¸ë¦¬ê¸° ë¯¸ë¦¬ë³´ê¸°
            previewBox = {
                x: startX,
                y: startY,
                width: currentX - startX,
                height: currentY - startY
            };
            scheduleRedraw();
        }

        // í´ë¦¬ê³¤ì—ì„œ ë°”ìš´ë”© ë°•ìŠ¤ ì¬ê³„ì‚°
        function updateBoundingBoxFromPolygon(annotation) {
            if (!annotation.polygon || annotation.polygon.length === 0) return;

            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            annotation.polygon.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });

            annotation.box = {
                x: Math.floor(minX),
                y: Math.floor(minY),
                width: Math.ceil(maxX - minX),
                height: Math.ceil(maxY - minY)
            };

            console.log('[POLYGON] Updated bounding box:', annotation.box);
        }

        // í´ë¦¬ê³¤ì—ì„œ ë§ˆìŠ¤í¬ ì¬ìƒì„±
        async function regenerateMaskFromPolygon(annotation) {
            if (!annotation.polygon || annotation.polygon.length < 3) {
                console.warn('[MASK] Cannot regenerate mask: invalid polygon');
                return false;
            }

            try {
                console.log('[MASK] Regenerating mask from edited polygon...');

                // ë°”ìš´ë”© ë°•ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
                const box = annotation.box;
                const relativePolygon = annotation.polygon.map(p => ({
                    x: p.x - box.x,
                    y: p.y - box.y
                }));

                const response = await fetch(API_BASE_URL + '/api/polygon/generate_mask', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        polygon: relativePolygon,
                        width: box.width,
                        height: box.height,
                        class_id: annotation.class_id || 1
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // ìƒˆ ë§ˆìŠ¤í¬ë¡œ ì—…ë°ì´íŠ¸
                    annotation.mask = data.mask;
                    console.log('[MASK] Mask regenerated successfully');
                    return true;
                } else {
                    console.error('[MASK] Failed to regenerate mask:', data.error);
                    return false;
                }
            } catch (error) {
                console.error('[MASK] Error regenerating mask:', error);
                return false;
            }
        }

        // í´ë˜ìŠ¤ ì„ íƒ íŒì—… ê´€ë ¨ í•¨ìˆ˜
        // í´ë˜ìŠ¤ ì„ íƒ íŒì—… ê´€ë ¨ ë³€ìˆ˜
        let classSelectionResolve = null;
        let popupEscHandler = null;
        let popupOutsideClickHandler = null;

        function showClassSelectionPopup(classes, mouseX, mouseY) {
            return new Promise((resolve) => {
                classSelectionResolve = resolve;

                const popup = document.getElementById('classSelectionPopup');
                const buttonsContainer = document.getElementById('classSelectionButtons');

                // ë²„íŠ¼ ìƒì„±
                buttonsContainer.innerHTML = '';
                classes.forEach((classObj, index) => {
                    const className = (typeof classObj === 'string') ? classObj : classObj.name;
                    const classDesc = (typeof classObj === 'string') ? '' : (classObj.description || '');

                    // ì–¸ì–´ì— ë”°ë¼ ì£¼ ì´ë¦„ê³¼ ë¶€ì œëª© ê²°ì •
                    const displayName = (typeof classObj === 'string') ? classObj : getClassDisplayName(classObj);
                    const displaySubtitle = (typeof classObj === 'string') ? '' :
                        (currentLanguage === 'ko' ? classObj.name : classObj.description) || '';

                    const button = document.createElement('button');
                    button.style.padding = '10px 15px';
                    button.style.fontSize = '13px';
                    button.style.textAlign = 'left';
                    button.style.background = '#2d2d2d';
                    button.style.border = '1px solid #404040';
                    button.style.borderRadius = '4px';
                    button.style.cursor = 'pointer';
                    button.style.transition = 'all 0.2s';
                    button.style.width = '100%';
                    button.style.color = '#ddd';

                    button.innerHTML = `
                        <div style="font-weight: 600; color: #4a9eff;">${displayName}</div>
                        ${displaySubtitle ? `<div style="font-size: 11px; color: #888; margin-top: 2px;">${displaySubtitle}</div>` : ''}
                    `;

                    button.onmouseover = () => {
                        button.style.background = '#4a9eff';
                        button.style.borderColor = '#4a9eff';
                        // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½í•˜ì—¬ ê°€ë…ì„± í–¥ìƒ
                        const titleDiv = button.querySelector('div:first-child');
                        const subtitleDiv = button.querySelector('div:nth-child(2)');
                        if (titleDiv) titleDiv.style.color = '#ffffff';
                        if (subtitleDiv) subtitleDiv.style.color = '#e0e0e0';
                    };

                    button.onmouseout = () => {
                        button.style.background = '#2d2d2d';
                        button.style.borderColor = '#404040';
                        // ì›ë˜ í…ìŠ¤íŠ¸ ìƒ‰ìƒìœ¼ë¡œ ë³µì›
                        const titleDiv = button.querySelector('div:first-child');
                        const subtitleDiv = button.querySelector('div:nth-child(2)');
                        if (titleDiv) titleDiv.style.color = '#4a9eff';
                        if (subtitleDiv) subtitleDiv.style.color = '#888';
                    };

                    button.onclick = () => {
                        popup.style.display = 'none';
                        classSelectionResolve({ name: className, index: index });
                        classSelectionResolve = null;
                    };

                    buttonsContainer.appendChild(button);
                });

                // íŒì—…ì„ ì¼ë‹¨ í‘œì‹œí•˜ì—¬ í¬ê¸° ê³„ì‚°
                popup.style.display = 'block';
                popup.style.visibility = 'hidden';

                // ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ìœ„ì¹˜ ê³„ì‚° (ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
                requestAnimationFrame(() => {
                    const popupWidth = popup.offsetWidth;
                    const popupHeight = popup.offsetHeight;

                    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ì¡°ì •
                    let x = mouseX;
                    let y = mouseY;

                    // ì˜¤ë¥¸ìª½ ê²½ê³„ ì²´í¬
                    if (x + popupWidth > window.innerWidth) {
                        x = window.innerWidth - popupWidth - 10;
                    }

                    // í•˜ë‹¨ ê²½ê³„ ì²´í¬
                    if (y + popupHeight > window.innerHeight) {
                        y = window.innerHeight - popupHeight - 10;
                    }

                    // ìµœì†Œ ìœ„ì¹˜ ë³´ì •
                    x = Math.max(10, x);
                    y = Math.max(10, y);

                    popup.style.left = x + 'px';
                    popup.style.top = y + 'px';
                    popup.style.visibility = 'visible';

                    console.log('[POPUP] Positioned at:', x, y);
                });

                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
                if (popupEscHandler) {
                    document.removeEventListener('keydown', popupEscHandler);
                }
                if (popupOutsideClickHandler) {
                    document.removeEventListener('click', popupOutsideClickHandler, true);
                }

                // ESC í‚¤ë¡œ ë‹«ê¸°
                popupEscHandler = (e) => {
                    if (e.key === 'Escape') {
                        closeClassSelectionPopup();
                    }
                };
                document.addEventListener('keydown', popupEscHandler);

                // íŒì—… ì™¸ë¶€ í´ë¦­ì‹œ ë‹«ê¸° (ìº”ë²„ìŠ¤ ì œì™¸)
                popupOutsideClickHandler = (e) => {
                    // ìº”ë²„ìŠ¤ë‚˜ íŒì—… ë‚´ë¶€ í´ë¦­ì€ ë¬´ì‹œ
                    const canvas = document.getElementById('videoCanvas');
                    if (!popup.contains(e.target) && e.target !== canvas) {
                        closeClassSelectionPopup();
                    }
                };
                // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (í˜„ì¬ í´ë¦­ ì´ë²¤íŠ¸ì™€ ì¶©ëŒ ë°©ì§€)
                setTimeout(() => {
                    document.addEventListener('click', popupOutsideClickHandler, true); // capture phaseì—ì„œ ì²˜ë¦¬
                }, 100);
            });
        }

        function closeClassSelectionPopup() {
            const popup = document.getElementById('classSelectionPopup');
            popup.style.display = 'none';
            if (classSelectionResolve) {
                classSelectionResolve(null); // ì·¨ì†Œ
                classSelectionResolve = null;
            }
        }

        // í´ë¦¬ê³¤ì— ëŒ€í•œ ë¼ë²¨ ì…ë ¥ ë°›ê¸°

        async function promptForLabel(polygon, box, mouseX, mouseY) {
            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                console.log('[VIDEO STATUS] Cannot add annotation to completed video');
                alert('ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                drawFrameWithMasks();
                return;
            }

            if (!currentProject || !currentProject.classes) {
                alert('í”„ë¡œì íŠ¸ í´ë˜ìŠ¤ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                drawFrameWithMasks();
                return;
            }

            let classes = currentProject.classes;
            if (!Array.isArray(classes)) {
                classes = [];
            }

            if (classes.length === 0) {
                alert('í”„ë¡œì íŠ¸ì— í´ë˜ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤. í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.');
                drawFrameWithMasks();
                return;
            }

            // í´ë˜ìŠ¤ ì„ íƒ íŒì—… ë„ìš°ê¸° (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì—)
            const selectedClass = await showClassSelectionPopup(classes, mouseX, mouseY);

            if (!selectedClass) {
                // ì·¨ì†Œë¨
                drawFrameWithMasks();
                return;
            }

            const label = selectedClass.name;
            const class_id = selectedClass.index + 1;

            console.log('[POLYGON] Selected label:', label, 'class_id:', class_id);

            // í´ë¦¬ê³¤ì—ì„œ ë§ˆìŠ¤í¬ ìƒì„±
            try {
                // ë°”ìš´ë”© ë°•ìŠ¤ ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
                const relativePolygon = polygon.map(p => ({
                    x: p.x - box.x,
                    y: p.y - box.y
                }));

                const response = await authFetch('/api/polygon/generate_mask', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        polygon: relativePolygon,
                        width: box.width,
                        height: box.height,
                        class_id: class_id
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const annotation = {
                        box: box,
                        label: label,
                        class_id: class_id,
                        polygon: polygon,
                        mask: data.mask,
                        has_segmentation: true,
                        manual_draw: true  // ìˆ˜ë™ìœ¼ë¡œ ê·¸ë¦° ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ
                    };

                    if (!frameAnnotations[currentFrame]) {
                        frameAnnotations[currentFrame] = [];
                    }
                    frameAnnotations[currentFrame].push(annotation);

                    console.log('[POLYGON] Added manual annotation:', label);

                    drawFrameWithMasks();
                    updateAnnotationList();
                    updateStatistics();
                } else {
                    console.error('[POLYGON] Failed to generate mask:', data.error);
                    alert('ë§ˆìŠ¤í¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + data.error);
                }
            } catch (error) {
                console.error('[POLYGON] Error generating mask:', error);
                alert('ë§ˆìŠ¤í¬ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ë§ˆìš°ìŠ¤ ì—…
        async function onCanvasMouseUp(e) {
            // ìš°í´ë¦­ì€ ë¬´ì‹œ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ìš©)
            if (e.button === 2) {
                console.log('[MOUSE] Right-click mouseup ignored');
                return;
            }

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                console.log('[VIDEO STATUS] Cannot complete drawing on completed video');
                // ê·¸ë¦¬ê¸° ìƒíƒœ ì´ˆê¸°í™”
                isDrawing = false;
                isDrawingPolygon = false;
                currentPolygonPoints = [];
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                return;
            }

            // í´ë¦¬ê³¤ ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ì™„ë£Œ
            if (isDrawingPolygon) {
                isDrawingPolygon = false;
                previewPolygon = null;  // í”„ë¦¬ë·° ì´ˆê¸°í™”
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);  // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”

                // ìµœì†Œ 3ê°œ ì  ì´ìƒ í•„ìš”
                if (currentPolygonPoints.length < 3) {
                    console.warn('[POLYGON] Not enough points, need at least 3');
                    currentPolygonPoints = [];
                    drawFrameWithMasks();
                    alert('í´ë¦¬ê³¤ì´ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤. ë” í¬ê²Œ ê·¸ë ¤ì£¼ì„¸ìš”.');
                    return;
                }

                console.log('[POLYGON] Finished drawing polygon with', currentPolygonPoints.length, 'points');

                // í´ë¦¬ê³¤ ë‹¨ìˆœí™” (Douglas-Peucker ì•Œê³ ë¦¬ì¦˜ ì ìš© ê°€ëŠ¥í•˜ì§€ë§Œ ì¼ë‹¨ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
                // ë§ˆì§€ë§‰ ì ê³¼ ì²« ì ì„ ì—°ê²°í•˜ì—¬ í´ë¦¬ê³¤ ë‹«ê¸°
                const polygon = [...currentPolygonPoints];

                // ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                polygon.forEach(point => {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                });

                const box = {
                    x: Math.floor(minX),
                    y: Math.floor(minY),
                    width: Math.ceil(maxX - minX),
                    height: Math.ceil(maxY - minY)
                };

                // ì‚¬ìš©ìì—ê²Œ ë¼ë²¨ ì„ íƒ ë°›ê¸° (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— íŒì—… í‘œì‹œ)
                await promptForLabel(polygon, box, e.clientX, e.clientY);

                currentPolygonPoints = [];
                return;
            }

            // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¢…ë£Œ
            if (isDraggingPoint) {
                isDraggingPoint = false;
                console.log('[POLYGON] Finished dragging point');

                // ë“œë˜ê·¸í•œ í´ë¦¬ê³¤ì„ ì‹¤ì œ ì–´ë…¸í…Œì´ì…˜ì— ì ìš©
                const annotations = frameAnnotations[currentFrame] || [];
                if (selectedAnnotationIndex !== -1 && draggedPolygon) {
                    const anno = annotations[selectedAnnotationIndex];
                    anno.polygon = draggedPolygon;

                    // ë°”ìš´ë”© ë°•ìŠ¤ ì¬ê³„ì‚°
                    updateBoundingBoxFromPolygon(anno);

                    // í´ë¦¬ê³¤ í¸ì§‘ í›„ ë§ˆìŠ¤í¬ ì¬ìƒì„±
                    await regenerateMaskFromPolygon(anno);
                }

                // í”„ë¦¬ë·° ì´ˆê¸°í™”
                draggedPolygon = null;
                draggingPointIndex = -1;
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

                // í™”ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                drawFrameWithMasks();

                return;
            }

            if (!isDrawing) return;
            isDrawing = false;
            previewBox = null;  // í”„ë¦¬ë·° ì´ˆê¸°í™”
            previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);  // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”

            const rect = videoCanvas.getBoundingClientRect();
            const scaleX = videoCanvas.width / rect.width;
            const scaleY = videoCanvas.height / rect.height;

            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            const box = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };

            // ë°•ìŠ¤ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ë¬´ì‹œ
            if (box.width < 10 || box.height < 10) {
                drawFrameWithMasks();
                return;
            }

            // AIê°€ ì´ˆê¸°í™”ë˜ì–´ ìˆê³  ìë™ ì¶”ë¡ ì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë°•ìŠ¤ ì˜ì—­ì— ëŒ€í•´ ì¶”ë¡  ì‹¤í–‰
            if (aiInitialized && aiAutoInferenceEnabled) {
                const annotation = { box, label: 'detecting...' };
                await runInferenceOnBox(annotation);
            } else {
                // AIê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ í´ë˜ìŠ¤ ì„ íƒ íŒì—… í‘œì‹œ
                const rect = videoCanvas.getBoundingClientRect();
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                const result = await showClassSelectionPopup(projectClasses, mouseX, mouseY);
                if (!result) {
                    drawFrame();
                    return;
                }

                const annotation = { box, label: result.name };
                if (!frameAnnotations[currentFrame]) {
                    frameAnnotations[currentFrame] = [];
                }
                frameAnnotations[currentFrame].push(annotation);
                drawFrame();
                updateAnnotationList();
                updateStatistics();
            }
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ê´€ë ¨ ë³€ìˆ˜
        let contextMenuAnnotationIndex = -1;

        // ìš°í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        function onCanvasRightClick(e) {
            e.preventDefault(); // ë¸Œë¼ìš°ì € ê¸°ë³¸ ë©”ë‰´ ì°¨ë‹¨

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                return;
            }

            // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ì¤‘ì´ê±°ë‚˜ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘ì´ë©´ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œí•˜ì§€ ì•ŠìŒ
            if (isDrawingPolygon || isDraggingPoint || isDrawing) {
                console.log('[CONTEXT MENU] Cannot show menu while drawing');
                return;
            }

            const rect = videoCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (videoCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (videoCanvas.height / rect.height);

            // í˜„ì¬ í”„ë ˆì„ì˜ ì–´ë…¸í…Œì´ì…˜ë“¤ í™•ì¸
            const annotations = frameAnnotations[currentFrame] || [];

            // í´ë¦­í•œ ìœ„ì¹˜ì˜ ì–´ë…¸í…Œì´ì…˜ ì°¾ê¸° (ë’¤ì—ì„œë¶€í„° ê²€ìƒ‰ - ìœ„ì— ìˆëŠ” ê²ƒë¶€í„°)
            let clickedAnnotationIndex = -1;
            for (let i = annotations.length - 1; i >= 0; i--) {
                const anno = annotations[i];
                if (anno.shape === 'polygon' || anno.polygon) {
                    const polygon = anno.polygon || (anno.shape === 'polygon' ? anno.points : null);
                    if (polygon && isPointInPolygon(x, y, polygon)) {
                        clickedAnnotationIndex = i;
                        break;
                    }
                } else if (anno.box) {
                    if (isPointInBox(x, y, anno.box)) {
                        clickedAnnotationIndex = i;
                        break;
                    }
                }
            }

            // ì–´ë…¸í…Œì´ì…˜ì„ ì°¾ì•˜ìœ¼ë©´ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
            if (clickedAnnotationIndex !== -1) {
                contextMenuAnnotationIndex = clickedAnnotationIndex;
                showContextMenu(e.clientX, e.clientY);
            } else {
                hideContextMenu();
            }
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
        function showContextMenu(x, y) {
            const menu = document.getElementById('annotationContextMenu');
            if (!menu) return;

            // í”„ë¡œì íŠ¸ì™€ í´ë˜ìŠ¤ ì •ë³´ í™•ì¸
            if (!currentProject || !currentProject.classes) {
                console.warn('[CONTEXT MENU] No project or classes available');
                return;
            }

            // ë©”ë‰´ ë‚´ìš© ìƒì„±
            let menuHTML = '<div style="padding: 4px 0; color: #fff; font-size: 12px; font-weight: bold; padding: 8px 12px; border-bottom: 1px solid #404040;">í´ë˜ìŠ¤ ë³€ê²½</div>';

            currentProject.classes.forEach((cls, index) => {
                const annotation = (frameAnnotations[currentFrame] || [])[contextMenuAnnotationIndex];
                const isCurrentClass = annotation && annotation.label === cls.name;

                menuHTML += `
                    <div onclick="changeAnnotationClass('${cls.name}')" style="
                        padding: 8px 12px;
                        cursor: pointer;
                        background: ${isCurrentClass ? '#404040' : 'transparent'};
                        color: ${isCurrentClass ? '#4a9eff' : '#fff'};
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#404040'" onmouseout="this.style.background='${isCurrentClass ? '#404040' : 'transparent'}'">
                        <span style="display: inline-block; width: 12px; height: 12px; background: ${cls.color || '#4a9eff'}; margin-right: 8px; vertical-align: middle;"></span>
                        ${cls.description || cls.name}
                    </div>
                `;
            });

            menu.innerHTML = menuHTML;
            menu.style.display = 'block';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ì¡°ì •
            setTimeout(() => {
                const menuRect = menu.getBoundingClientRect();
                if (menuRect.right > window.innerWidth) {
                    menu.style.left = (x - menuRect.width) + 'px';
                }
                if (menuRect.bottom > window.innerHeight) {
                    menu.style.top = (y - menuRect.height) + 'px';
                }
            }, 0);
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°
        function hideContextMenu() {
            const menu = document.getElementById('annotationContextMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            contextMenuAnnotationIndex = -1;
        }

        // ì–´ë…¸í…Œì´ì…˜ í´ë˜ìŠ¤ ë³€ê²½
        function changeAnnotationClass(newClassName) {
            if (contextMenuAnnotationIndex === -1 || !frameAnnotations[currentFrame]) {
                hideContextMenu();
                return;
            }

            const annotation = frameAnnotations[currentFrame][contextMenuAnnotationIndex];
            if (annotation) {
                annotation.label = newClassName;
                console.log(`[ANNOTATION] Changed class to: ${newClassName}`);

                // í™”ë©´ ì—…ë°ì´íŠ¸ (ë§ˆìŠ¤í¬/í´ë¦¬ê³¤ í¬í•¨)
                drawFrameWithMasks();
                updateAnnotationList();
                updateStatistics();
            }

            hideContextMenu();
        }

        // í´ë¦¬ê³¤ ë‚´ë¶€ í¬ì¸íŠ¸ í™•ì¸ (Ray Casting Algorithm)
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }


        // ì „ì²´ í”„ë ˆì„ì— ëŒ€í•´ AI ì¶”ë¡  ì‹¤í–‰
        // AI ì¶”ë¡  í•¨ìˆ˜ (ë¹„í™œì„±í™”ë¨)
        async function runFullFrameInference() {
            // ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ë¡  ê¸°ëŠ¥ ì œê±°ë¨
            console.log('[AI] runFullFrameInference is disabled');
            return;

            if (!currentProjectId || !currentVideoId || currentFrame === null) {
                return;
            }

            console.log('[AI] Running full frame inference...');

            try {
                const response = await authFetch('/api/ai/inference', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_dir: currentProject.project_dir,
                        video_id: currentVideoId,
                        frame_number: currentFrame
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[AI] Full frame inference completed');

                    // í”„ë ˆì„ ì–´ë…¸í…Œì´ì…˜ ì´ˆê¸°í™”
                    if (!frameAnnotations[currentFrame]) {
                        frameAnnotations[currentFrame] = [];
                    }

                    // ê¸°ì¡´ ìë™ ìƒì„± ì–´ë…¸í…Œì´ì…˜ ì œê±° (auto_detected í”Œë˜ê·¸)
                    frameAnnotations[currentFrame] = frameAnnotations[currentFrame].filter(anno => !anno.auto_detected);

                    // ë°”ìš´ë”© ë°•ìŠ¤ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë³€í™˜
                    if (data.bounding_boxes && data.bounding_boxes.length > 0) {
                        console.log('[AI] Found', data.bounding_boxes.length, 'objects');

                        // í•´ìƒë„ì˜ 10% ê³„ì‚° (ë©´ì  ê¸°ì¤€)
                        const frameWidth = currentFrameImage.width;
                        const frameHeight = currentFrameImage.height;
                        const frameArea = frameWidth * frameHeight;
                        const minArea = frameArea * 0.10; // 10%

                        let filteredCount = 0;
                        let addedCount = 0;

                        data.bounding_boxes.forEach(bbox => {
                            const bboxArea = bbox.width * bbox.height;

                            // ë°”ìš´ë”© ë°•ìŠ¤ ë©´ì ì´ í•´ìƒë„ì˜ 10% ì´ìƒì¸ ê²½ìš°ë§Œ ì¶”ê°€
                            if (bboxArea >= minArea) {
                                const annotation = {
                                    box: {
                                        x: bbox.x,
                                        y: bbox.y,
                                        width: bbox.width,
                                        height: bbox.height
                                    },
                                    label: bbox.label,
                                    class_id: bbox.class_id,
                                    confidence: bbox.confidence,
                                    mask: bbox.mask,  // ë°”ìš´ë”© ë°•ìŠ¤ ì˜ì—­ì˜ ë§ˆìŠ¤í¬
                                    polygon: bbox.polygon || [],  // ì„œë²„ì—ì„œ ì¶”ì¶œí•œ í´ë¦¬ê³¤
                                    has_segmentation: true,
                                    auto_detected: true  // ìë™ ê°ì§€ëœ ì–´ë…¸í…Œì´ì…˜ì„ì„ í‘œì‹œ
                                };

                                frameAnnotations[currentFrame].push(annotation);
                                addedCount++;
                            } else {
                                filteredCount++;
                                console.log('[AI] Filtered out small bbox:', bbox.label,
                                          `(${bbox.width}x${bbox.height} = ${bboxArea.toFixed(0)} < ${minArea.toFixed(0)})`);
                            }
                        });

                        console.log('[AI] Added', addedCount, 'annotations (filtered', filteredCount, 'small boxes)');
                    } else {
                        console.log('[AI] No objects detected in full frame');
                    }

                    // ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    drawFrameWithMasks();

                    updateAnnotationList();
                    updateStatistics();
                } else {
                    console.error('[AI] Full frame inference error:', data.error);
                }
            } catch (error) {
                console.error('[AI] Full frame inference failed:', error);
            }
        }

        // ë°•ìŠ¤ ì˜ì—­ì— ëŒ€í•´ AI ì¶”ë¡  ì‹¤í–‰
        async function runInferenceOnBox(annotation) {
            if (!currentProjectId || !currentVideoId || currentFrame === null) {
                return;
            }

            console.log('[AI] Running inference on box region:', annotation.box);

            try {
                const response = await authFetch('/api/ai/inference_box', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_dir: currentProject.project_dir,
                        video_id: currentVideoId,
                        frame_number: currentFrame,
                        box: annotation.box
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[AI] Box inference completed:', data.dominant_class_name, `(${(data.dominant_class_ratio*100).toFixed(1)}%)`);

                    // backgroundê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì–´ë…¸í…Œì´ì…˜ ì¶”ê°€
                    if (data.dominant_class_name !== 'background') {
                        // AIê°€ ê°ì§€í•œ í´ë˜ìŠ¤ë¥¼ ë¼ë²¨ë¡œ ì‚¬ìš©
                        annotation.label = data.dominant_class_name;
                        annotation.class_id = data.dominant_class;
                        annotation.confidence = data.dominant_class_ratio;

                        // ë§ˆìŠ¤í¬ ë°ì´í„° ì €ì¥ (Base64 PNG)
                        annotation.mask = data.mask;
                        annotation.has_segmentation = true;

                        // í´ë¦¬ê³¤ ë°ì´í„° ì €ì¥ (ìˆëŠ” ê²½ìš°)
                        if (data.polygon && data.polygon.length > 0) {
                            annotation.polygon = data.polygon;
                        }

                        // ì–´ë…¸í…Œì´ì…˜ ì¶”ê°€
                        if (!frameAnnotations[currentFrame]) {
                            frameAnnotations[currentFrame] = [];
                        }
                        frameAnnotations[currentFrame].push(annotation);

                        console.log('[AI] Added annotation:', data.dominant_class_name, 'with confidence', (data.dominant_class_ratio*100).toFixed(1) + '%');
                    } else {
                        console.log('[AI] Skipped - only background detected in the box');
                        alert('í•´ë‹¹ ì˜ì—­ì—ì„œ ë…¹(rust)ì´ë‚˜ ìŠ¤ì¼€ì¼(scale)ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n\në‹¤ë¥¸ ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    }

                    // ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ì›ë³¸ í”„ë ˆì„ ìœ„ì— ëª¨ë“  ë§ˆìŠ¤í¬ ì ìš©)
                    drawFrameWithMasks();

                    updateAnnotationList();
                    updateStatistics();
                } else {
                    console.error('[AI] Box inference error:', data.error);
                    // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ë°•ìŠ¤ëŠ” ì €ì¥
                    if (!frameAnnotations[currentFrame]) {
                        frameAnnotations[currentFrame] = [];
                    }
                    frameAnnotations[currentFrame].push(annotation);
                    drawFrame();
                    updateAnnotationList();
                    updateStatistics();
                }
            } catch (error) {
                console.error('[AI] Box inference failed:', error);
                // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ë°•ìŠ¤ëŠ” ì €ì¥
                if (!frameAnnotations[currentFrame]) {
                    frameAnnotations[currentFrame] = [];
                }
                frameAnnotations[currentFrame].push(annotation);
                drawFrame();
                updateAnnotationList();
                updateStatistics();
            }
        }

        // í”„ë ˆì„ ê·¸ë¦¬ê¸°
        function drawFrame() {
            if (!currentFrameImage || !videoContext) {
                console.warn('[VIDEO] Cannot draw frame: image or context is null');
                return;
            }

            console.log('[VIDEO] Drawing frame', currentFrame);

            videoContext.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoContext.drawImage(currentFrameImage, 0, 0, videoCanvas.width, videoCanvas.height);

            // í˜„ì¬ í”„ë ˆì„ì˜ ì£¼ì„ ê·¸ë¦¬ê¸°
            const annotations = frameAnnotations[currentFrame] || [];
            annotations.forEach((anno, idx) => {
                const className = anno.category || anno.label || 'Unknown';
                drawBox(anno.box, getDisplayLabel(anno.label), idx === selectedAnnotationIndex, className);
            });
        }

        // ì›ë³¸ í”„ë ˆì„ ìœ„ì— ëª¨ë“  ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ê·¸ë¦¬ê¸°
        async function drawFrameWithMasks() {
            if (!originalFrameImage || !videoContext) {
                console.warn('[VIDEO] Cannot draw frame with masks: image or context is null');
                drawFrame();
                return;
            }

            // ì›ë³¸ í”„ë ˆì„ ê·¸ë¦¬ê¸°
            videoContext.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoContext.drawImage(originalFrameImage, 0, 0, videoCanvas.width, videoCanvas.height);

            // ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ì˜ ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ê·¸ë¦¬ê¸°
            const annotations = frameAnnotations[currentFrame] || [];

            for (const anno of annotations) {
                if (anno.has_segmentation && anno.mask) {
                    // ë§ˆìŠ¤í¬ ì´ë¯¸ì§€ ë¡œë“œ ë° ì˜¤ë²„ë ˆì´
                    await drawMaskOverlay(anno.mask, anno.class_id, anno.box);
                }
            }

            // í´ë¦¬ê³¤ ë° ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            annotations.forEach((anno, idx) => {
                const isSelected = idx === selectedAnnotationIndex;
                const className = anno.category || anno.label || 'Unknown';

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°, ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ë§Œ
                if (anno.polygon && anno.polygon.length > 0) {
                    drawPolygon(anno.polygon, anno.class_id, getDisplayLabel(anno.label), isSelected, className);
                } else {
                    drawBox(anno.box, getDisplayLabel(anno.label), isSelected, className);
                }
            });
        }

        // ë§ˆìŠ¤í¬ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        function drawMaskOverlay(maskBase64, classId, box) {
            return new Promise((resolve, reject) => {
                const maskImg = new Image();

                maskImg.onload = function() {
                    // ì„ì‹œ Canvas ìƒì„± (ë§ˆìŠ¤í¬ ì²˜ë¦¬ìš©)
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = maskImg.width;
                    tempCanvas.height = maskImg.height;
                    const tempCtx = tempCanvas.getContext('2d');

                    // ë§ˆìŠ¤í¬ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                    tempCtx.drawImage(maskImg, 0, 0);

                    // ë§ˆìŠ¤í¬ í”½ì…€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;

                    // í´ë˜ìŠ¤ë³„ ìƒ‰ìƒ ë§¤í•‘
                    const colors = {
                        0: { r: 0, g: 0, b: 0 },       // background (í‘œì‹œ ì•ˆë¨)
                        1: { r: 255, g: 0, b: 0 },     // rust (ë¹¨ê°„ìƒ‰)
                        2: { r: 255, g: 255, b: 0 }    // scale (ë…¸ë€ìƒ‰)
                    };

                    // ë§ˆìŠ¤í¬ë¥¼ ì»¬ëŸ¬ë¡œ ë³€í™˜
                    for (let i = 0; i < data.length; i += 4) {
                        const maskValue = data[i]; // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ê°’ (í´ë˜ìŠ¤ ID ë˜ëŠ” 0/1 ë§ˆìŠ¤í¬)

                        if (maskValue > 0) {  // ë°°ê²½ì´ ì•„ë‹Œ ê²½ìš°
                            const color = colors[classId] || colors[1];
                            data[i] = color.r;
                            data[i + 1] = color.g;
                            data[i + 2] = color.b;
                            data[i + 3] = 32; // ë°˜íˆ¬ëª… (12.5% - ì›ë³¸ ì´ë¯¸ì§€ê°€ ë” ì˜ ë³´ì„)
                        } else {
                            data[i + 3] = 0; // ë°°ê²½ì€ ì™„ì „ íˆ¬ëª…
                        }
                    }

                    // ë³€í™˜ëœ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ë‹¤ì‹œ Canvasì— ì ìš©
                    tempCtx.putImageData(imageData, 0, 0);

                    // ë©”ì¸ Canvasì— ì˜¤ë²„ë ˆì´ (ë°”ìš´ë”© ë°•ìŠ¤ ìœ„ì¹˜ì— ë§ì¶°ì„œ)
                    if (box) {
                        // Cropped mask: ë°”ìš´ë”© ë°•ìŠ¤ ìœ„ì¹˜ì— ê·¸ë¦¬ê¸°
                        videoContext.drawImage(tempCanvas, box.x, box.y, box.width, box.height);
                    } else {
                        // Full frame mask: ì „ì²´ í™”ë©´ì— ê·¸ë¦¬ê¸°
                        videoContext.drawImage(tempCanvas, 0, 0, videoCanvas.width, videoCanvas.height);
                    }

                    resolve();
                };

                maskImg.onerror = function() {
                    console.error('[MASK] Failed to load mask image');
                    reject();
                };

                maskImg.src = 'data:image/png;base64,' + maskBase64;
            });
        }

        // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
        function drawPolygon(polygon, classId, label, isSelected = false, className = null) {
            if (!polygon || polygon.length < 3) {
                return;
            }

            // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
            let baseColor;
            if (className) {
                baseColor = getColorForClass(className);
            } else {
                // í•˜ìœ„ í˜¸í™˜ì„±: classIdë¡œ ìƒ‰ìƒ ê²°ì • (ë ˆê±°ì‹œ)
                const classColors = {
                    1: '#FF0000',    // rust: ë¹¨ê°•
                    2: '#FFFF00'     // scale: ë…¸ë‘
                };
                baseColor = classColors[classId] || '#00FF00';
            }

            // hexë¥¼ rgbaë¡œ ë³€í™˜
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            const colors = {
                stroke: hexToRgba(baseColor, 1),
                fill: hexToRgba(baseColor, 0.3)
            };

            const lineWidth = isSelected ? 3 : 2;

            // ë¹„ë””ì˜¤ í•´ìƒë„ ê¸°ë°˜ ìŠ¤ì¼€ì¼ ê³„ì‚° (1920x1080 ê¸°ì¤€)
            const videoWidth = videoElement.videoWidth || 1920;
            const videoHeight = videoElement.videoHeight || 1080;
            const scaleFactor = Math.sqrt((videoWidth * videoHeight) / (1920 * 1080));

            // í´ë¦¬ê³¤ ë³´ê°„ (ì  ì‚¬ì´ë¥¼ ë¶€ë“œëŸ½ê²Œ ì—°ê²°)
            const interpolatePolygon = (points, segments = Math.max(6, Math.floor(20 * scaleFactor))) => {
                const interpolated = [];
                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];

                    for (let j = 0; j < segments; j++) {
                        const t = j / segments;
                        interpolated.push({
                            x: p1.x + (p2.x - p1.x) * t,
                            y: p1.y + (p2.y - p1.y) * t
                        });
                    }
                }
                return interpolated;
            };

            // í´ë¦¬ê³¤ ë³´ê°„ ì ìš© (ë” ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
            const smoothPolygon = interpolatePolygon(polygon);

            // í´ë¦¬ê³¤ ì±„ìš°ê¸° (ë°˜íˆ¬ëª…) - ë³´ê°„ëœ í´ë¦¬ê³¤ ì‚¬ìš©
            videoContext.fillStyle = colors.fill;
            videoContext.beginPath();
            videoContext.moveTo(smoothPolygon[0].x, smoothPolygon[0].y);
            for (let i = 1; i < smoothPolygon.length; i++) {
                videoContext.lineTo(smoothPolygon[i].x, smoothPolygon[i].y);
            }
            videoContext.closePath();
            videoContext.fill();

            // í´ë¦¬ê³¤ ì™¸ê³½ì„  - ë³´ê°„ëœ í´ë¦¬ê³¤ ì‚¬ìš©
            videoContext.strokeStyle = colors.stroke;
            videoContext.lineWidth = lineWidth;
            videoContext.beginPath();
            videoContext.moveTo(smoothPolygon[0].x, smoothPolygon[0].y);
            for (let i = 1; i < smoothPolygon.length; i++) {
                videoContext.lineTo(smoothPolygon[i].x, smoothPolygon[i].y);
            }
            videoContext.closePath();
            videoContext.stroke();

            // ì„ íƒëœ ê²½ìš° ê° ì  í‘œì‹œ (ì›ë³¸ polygon í¬ì¸íŠ¸ë§Œ)
            if (isSelected) {
                polygon.forEach((point, idx) => {
                    // ë“œë˜ê·¸ ì¤‘ì¸ í¬ì¸íŠ¸ëŠ” ë” í¬ê²Œ í‘œì‹œ (í•´ìƒë„ì— ë§ì¶° ì¡°ì ˆ)
                    const baseRadius = 6 * scaleFactor;
                    const radius = (isDraggingPoint && draggingPointIndex === idx) ? baseRadius * 1.3 : baseRadius;
                    const pointLineWidth = (isDraggingPoint && draggingPointIndex === idx) ? 3 : 2;

                    videoContext.fillStyle = '#ffffff';
                    videoContext.strokeStyle = colors.stroke;
                    videoContext.lineWidth = pointLineWidth;
                    videoContext.beginPath();
                    videoContext.arc(point.x, point.y, radius, 0, Math.PI * 2);
                    videoContext.fill();
                    videoContext.stroke();

                    // í¬ì¸íŠ¸ ì¸ë±ìŠ¤ í‘œì‹œ (ë””ë²„ê¹…ìš©) - í•´ìƒë„ì— ë§ì¶° í°íŠ¸ í¬ê¸° ì¡°ì ˆ
                    if (polygon.length > 8) {  // í¬ì¸íŠ¸ê°€ ë§ìœ¼ë©´ ë²ˆí˜¸ í‘œì‹œ
                        videoContext.fillStyle = colors.stroke;
                        videoContext.font = `${Math.floor(20 * scaleFactor)}px Arial`;
                        videoContext.fillText(idx, point.x + 8 * scaleFactor, point.y - 8 * scaleFactor);
                    }
                });
            }

            // ë ˆì´ë¸” í‘œì‹œ (ì²« ë²ˆì§¸ ì  ìœ„ì—) - í•´ìƒë„ì— ë§ì¶° í¬ê¸° ì¡°ì ˆ
            const firstPoint = polygon[0];
            const labelHeight = Math.floor(40 * scaleFactor);
            const labelWidth = Math.floor(200 * scaleFactor);
            const fontSize = Math.floor(28 * scaleFactor);
            const padding = Math.floor(5 * scaleFactor);

            videoContext.fillStyle = colors.stroke;
            videoContext.fillRect(firstPoint.x, firstPoint.y - labelHeight, labelWidth, labelHeight);
            videoContext.fillStyle = '#000';
            videoContext.font = `${fontSize}px Arial`;
            videoContext.fillText(label, firstPoint.x + padding, firstPoint.y - padding * 2);
        }

        // ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
        function drawBox(box, label, isSelected = false, className = null) {
            // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
            let color;
            if (isSelected) {
                color = '#ffff00';  // ì„ íƒëœ ê²½ìš° ë…¸ë€ìƒ‰
            } else if (className) {
                color = getColorForClass(className);
            } else {
                color = '#00ff00';  // ê¸°ë³¸ ë…¹ìƒ‰
            }

            const lineWidth = isSelected ? 3 : 2;

            videoContext.strokeStyle = color;
            videoContext.lineWidth = lineWidth;
            videoContext.strokeRect(box.x, box.y, box.width, box.height);

            // ë ˆì´ë¸” í‘œì‹œ
            videoContext.fillStyle = color;
            videoContext.fillRect(box.x, box.y - 40, 200, 40);
            videoContext.fillStyle = '#000';
            videoContext.font = '28px Arial';
            videoContext.fillText(label, box.x + 5, box.y - 10);
        }

        // í”„ë ˆì„ ë¼ë²¨ ì—…ë°ì´íŠ¸
        function updateFrameLabel() {
            document.getElementById('frameLabel').textContent = `Frame: ${currentFrame} / ${totalFrames}`;
            document.getElementById('frameSlider').value = currentFrame;

            // ì¢Œì¸¡ íŒ¨ë„ì˜ í˜„ì¬ í”„ë ˆì„ ì •ë³´ë„ ì—…ë°ì´íŠ¸
            const currentFrameInfo = document.getElementById('currentFrameInfo');
            if (currentFrameInfo) {
                currentFrameInfo.textContent = currentFrame;
            }

            // ì–´ë…¸í…Œì´ì…˜ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (í˜„ì¬ í”„ë ˆì„ì˜ ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ)
            updateAnnotationList();
        }

        // Play/Pause í† ê¸€
        function togglePlay() {
            if (isPlaying) {
                // Pause playback
                videoElement.pause();
                renderLoopActive = false;
                isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ Play';

                // Sync currentFrame from video time
                currentFrame = Math.floor(videoElement.currentTime * videoFPS);
                currentFrame = Math.min(currentFrame, totalFrames - 1);
                currentFrame = Math.max(currentFrame, 0);

                // Load precise frame image for annotation
                loadFrame(currentFrame);
            } else {
                // Start playback
                isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ Pause';

                // Sync video time to current frame before playing
                videoElement.currentTime = currentFrame / videoFPS;

                // Start normal playback
                videoElement.play();
                renderLoopActive = true;
                requestAnimationFrame(renderVideoToCanvas);
            }
        }


        // ì–´ë…¸í…Œì´ì…˜ íƒ­ ì¬ìƒ ì†ë„ ë³€ê²½
        function changeAnnotationPlaybackSpeed() {
            const speed = parseFloat(document.getElementById('annotationPlaybackSpeed').value);

            if (!videoElement) {
                return;
            }

            // Set video playback speed
            videoElement.playbackRate = speed;
            console.log('[VIDEO] Playback speed changed to: ' + speed + 'x');

            // If currently playing, ensure video playback is active
            if (isPlaying) {
                renderLoopActive = true;
                videoElement.play();
                requestAnimationFrame(renderVideoToCanvas);
            }
        }

        // ì´ì „ í”„ë ˆì„
        function prevFrame() {
            if (currentFrame > 0) {
                currentFrame--;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // ë‹¤ìŒ í”„ë ˆì„
        function nextFrame() {
            if (currentFrame < totalFrames - 1) {
                currentFrame++;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // 15 í”„ë ˆì„ ë’¤ë¡œ
        function skip15SecondsBackward() {
            const framesToSkip = 15;  // 15 í”„ë ˆì„
            const newFrame = Math.max(0, currentFrame - framesToSkip);

            if (newFrame !== currentFrame) {
                currentFrame = newFrame;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // 15 í”„ë ˆì„ ì•ìœ¼ë¡œ
        function skip15SecondsForward() {
            const framesToSkip = 15;  // 15 í”„ë ˆì„
            const newFrame = Math.min(totalFrames - 1, currentFrame + framesToSkip);

            if (newFrame !== currentFrame) {
                currentFrame = newFrame;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // ìŠ¬ë¼ì´ë” ë³€ê²½ (throttle + ë””ë°”ìš´ì‹±)
        async function onSliderChange() {
            // ìƒˆë¡œìš´ í”„ë ˆì„ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
            const targetFrame = parseInt(document.getElementById('frameSlider').value);
            currentFrame = targetFrame;

            // ë¹„ë””ì˜¤ ì‹œê°„ ì¦‰ì‹œ ë™ê¸°í™”
            const targetTime = currentFrame / videoFPS;
            videoElement.currentTime = targetTime;
            updateFrameLabel();

            // í˜„ì¬ ì‹œê°„
            const now = Date.now();

            // Throttle: 50msë§ˆë‹¤ í•œ ë²ˆì”©ë§Œ ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
            if (now - lastSliderUpdate > 50) {
                lastSliderUpdate = now;

                // requestAnimationFrameì„ ì‚¬ìš©í•˜ì—¬ ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ì¦‰ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {  // ë‘ ë²ˆ í˜¸ì¶œí•˜ì—¬ ë¹„ë””ì˜¤ê°€ í”„ë ˆì„ì„ ì—…ë°ì´íŠ¸í•  ì‹œê°„ í™•ë³´
                        const canvas = document.getElementById('videoCanvas');
                        const ctx = canvas.getContext('2d');
                        if (videoElement.readyState >= 2) {  // HAVE_CURRENT_DATA ì´ìƒ
                            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        }
                    });
                });
            }

            // ì´ì „ ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸ ì·¨ì†Œ
            if (sliderDebounceTimer) {
                clearTimeout(sliderDebounceTimer);
            }

            // ì´ì „ í”„ë ˆì„ ë¡œë“œ ìš”ì²­ ì·¨ì†Œ
            if (frameLoadAbortController) {
                frameLoadAbortController.abort();
            }

            // 200ms ë””ë°”ìš´ìŠ¤ í›„ ê³ í’ˆì§ˆ í”„ë ˆì„ ë¡œë“œ (ë“œë˜ê·¸ê°€ ë©ˆì¶˜ í›„)
            sliderDebounceTimer = setTimeout(async () => {
                // ìƒˆ AbortController ìƒì„±
                frameLoadAbortController = new AbortController();

                try {
                    // Load precise frame for annotation
                    await loadFrame(currentFrame, frameLoadAbortController.signal);
                } catch (error) {
                    // AbortErrorëŠ” loadFrameì—ì„œ ì²˜ë¦¬ë¨
                    if (error.name !== 'AbortError') {
                        console.error('[SLIDER] Error loading frame:', error);
                    }
                }
            }, 200);  // 200ms ë””ë°”ìš´ìŠ¤
        }

        // AI ìƒíƒœ í™•ì¸ (UI ì œê±°ë¨ - ë¹„í™œì„±í™”)
        async function checkAIStatus() {
            const statusDiv = document.getElementById('aiStatusText');

            // UI ìš”ì†Œê°€ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ í•¨ìˆ˜ ë¹„í™œì„±í™”
            if (!statusDiv) {
                return;
            }

            statusDiv.textContent = 'ğŸ” Checking AI status...';
            statusDiv.style.color = '#ffa500';

            try {
                // Health checkë¡œ AI ìƒíƒœ í™•ì¸
                const response = await authFetch('/api/health');
                const data = await response.json();

                if (data.status === 'ok') {
                    // GPU ì„œë²„ ì—°ê²° í™•ì¸
                    const gpuStatus = data.gpu_status;
                    if (gpuStatus && gpuStatus.status === 'ok') {
                        // AI ì´ˆê¸°í™” ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ (ì´ë¯¸ ì´ˆê¸°í™”ë˜ì–´ ìˆìœ¼ë©´ ë°”ë¡œ ë°˜í™˜)
                        const initResponse = await authFetch('/api/ai/initialize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });

                        const initData = await initResponse.json();

                        if (initData.success) {
                            aiInitialized = true;
                            statusDiv.innerHTML = 'âœ… Ready <span style="color: #666;">(' + (initData.device || 'GPU') + ')</span>';
                            statusDiv.style.color = '#00ff00';
                            console.log('[AI] Model ready:', initData.message);
                        } else {
                            statusDiv.innerHTML = 'âŒ Failed to load';
                            statusDiv.style.color = '#ff0000';
                            console.error('[AI] Initialization failed:', initData.error);
                        }
                    } else {
                        statusDiv.innerHTML = 'âš ï¸ GPU server not available';
                        statusDiv.style.color = '#ffa500';
                    }
                } else {
                    statusDiv.innerHTML = 'âŒ Backend not available';
                    statusDiv.style.color = '#ff0000';
                }
            } catch (error) {
                statusDiv.innerHTML = 'âŒ Connection error';
                statusDiv.style.color = '#ff0000';
                console.error('[AI] Status check failed:', error);
            }
        }

        async function autoRunInference() {
            // AIê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì¶”ë¡ í•˜ì§€ ì•ŠìŒ
            if (!aiInitialized) {
                return;
            }

            if (!currentProjectId || !currentVideoId || currentFrame === null) {
                return;
            }

            console.log('[AI] Auto-running inference on frame', currentFrame);

            try {
                const response = await authFetch('/api/ai/inference', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_dir: currentProject.project_dir,
                        video_id: currentVideoId,
                        frame_number: currentFrame
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[AI] Inference completed:', data.num_classes, 'classes found,', data.bounding_boxes.length, 'objects detected');

                    // Display inference result as overlay
                    const img = new Image();
                    img.onload = function() {
                        // Replace current frame with inference result (shows segmentation overlay)
                        currentFrameImage = img;
                        drawFrame();
                    };
                    img.src = 'data:image/jpeg;base64,' + data.image;

                    // Convert bounding boxes to annotations
                    if (data.bounding_boxes && data.bounding_boxes.length > 0) {
                        convertInferenceToAnnotations(data.bounding_boxes);
                    }
                } else {
                    console.error('[AI] Inference error:', data.error);
                }
            } catch (error) {
                console.error('[AI] Inference failed:', error);
            }
        }

        // AI ì¶”ë¡  ê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë³€í™˜
        // AI ì¶”ë¡  ê²°ê³¼ ë³€í™˜ í•¨ìˆ˜ (ë¹„í™œì„±í™”ë¨)
        function convertInferenceToAnnotations(boundingBoxes) {
            // ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ë¡  ê¸°ëŠ¥ ì œê±°ë¨
            console.log('[AI] convertInferenceToAnnotations is disabled');
            return;

            if (!frameAnnotations[currentFrame]) {
                frameAnnotations[currentFrame] = [];
            }

            // ê¸°ì¡´ AI ì–´ë…¸í…Œì´ì…˜ ì œê±° (ì¤‘ë³µ ë°©ì§€)
            frameAnnotations[currentFrame] = frameAnnotations[currentFrame].filter(anno =>
                !anno.label.startsWith('class_')
            );

            // ìƒˆ ì–´ë…¸í…Œì´ì…˜ ì¶”ê°€
            for (const bbox of boundingBoxes) {
                frameAnnotations[currentFrame].push({
                    box: {
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height
                    },
                    label: bbox.label,
                    class_id: bbox.class_id,
                    area: bbox.area,
                    source: 'ai'  // AIê°€ ìƒì„±í•œ ì–´ë…¸í…Œì´ì…˜ì„ì„ í‘œì‹œ
                });
            }

            updateAnnotationList();
            updateStatistics();
            console.log('[AI] Converted', boundingBoxes.length, 'bounding boxes to annotations');
        }

        // ë¹„ë””ì˜¤ ìƒíƒœì— ë”°ë¥¸ ì–´ë…¸í…Œì´ì…˜ UI ì—…ë°ì´íŠ¸
        function updateAnnotationUIForStatus() {
            const isCompleted = currentVideoStatus === 'completed';

            console.log('[VIDEO STATUS] Updating UI for status:', currentVideoStatus, 'isCompleted:', isCompleted);

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ì¸ ê²½ìš° ê²½ê³  ë©”ì‹œì§€ í‘œì‹œ
            const videoDisplay = document.getElementById('currentVideoDisplay');
            if (videoDisplay) {
                const currentHTML = videoDisplay.innerHTML;
                if (isCompleted) {
                    if (!currentHTML.includes('ì™„ë£Œ')) {
                        videoDisplay.innerHTML = currentHTML + '<br><span style="background: #28a745; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; margin-top: 5px; display: inline-block;">âœ“ ì™„ë£Œ (ì½ê¸°ì „ìš©)</span>';
                    }
                } else {
                    // ì™„ë£Œ í‘œì‹œ ì œê±°
                    videoDisplay.innerHTML = currentHTML.replace(/<br><span style="background: #28a745.*?ì™„ë£Œ.*?<\/span>/g, '');
                }
            }

            // ë²„íŠ¼ ë¹„í™œì„±í™”/í™œì„±í™”
            const saveFrameBtn = document.querySelector('button[onclick="saveCurrentFrame()"]');
            const clearFrameBtn = document.querySelector('button[onclick="clearFrame()"]');
            const editBtn = document.querySelector('button[onclick="editAnnotation()"]');
            const deleteBtn = document.querySelector('button[onclick="deleteAnnotation()"]');
            const autoInferenceToggle = document.getElementById('autoInferenceToggle');
            const crosshairToggle = document.getElementById('crosshairToggle');

            if (saveFrameBtn) saveFrameBtn.disabled = isCompleted;
            if (clearFrameBtn) clearFrameBtn.disabled = isCompleted;
            if (editBtn) editBtn.disabled = isCompleted;
            if (deleteBtn) deleteBtn.disabled = isCompleted;
            if (autoInferenceToggle) {
                autoInferenceToggle.disabled = isCompleted;
                if (isCompleted) autoInferenceToggle.checked = false;
            }
            if (crosshairToggle) crosshairToggle.disabled = isCompleted;

            // ìº”ë²„ìŠ¤ ë¹„í™œì„±í™” ìŠ¤íƒ€ì¼
            const videoCanvas = document.getElementById('videoCanvas');
            if (videoCanvas) {
                if (isCompleted) {
                    videoCanvas.style.cursor = 'not-allowed';
                    videoCanvas.style.opacity = '0.8';
                } else {
                    videoCanvas.style.cursor = '';
                    videoCanvas.style.opacity = '1';
                }
            }

            console.log('[VIDEO STATUS] UI updated - buttons disabled:', isCompleted);
        }

        // ì£¼ì„ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateAnnotationList() {
            const annotationList = document.getElementById('annotationList');
            const allAnnotations = frameAnnotations[currentFrame] || [];

            // ì „ì²´ í”„ë ˆì„ ë§ˆìŠ¤í¬ëŠ” ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œì™¸
            const annotations = allAnnotations.filter(anno => !anno.is_full_frame);

            if (annotations.length === 0) {
                annotationList.innerHTML = '<div style="color: #999;">No annotations</div>';
                selectedAnnotationIndex = -1;
                return;
            }

            annotationList.innerHTML = annotations.map((anno, idx) => {
                const isSelected = idx === selectedAnnotationIndex;
                const borderColor = isSelected ? '#ffff00' : '#00ff00';
                const bgColor = isSelected ? '#3d3d00' : '#2d2d2d';

                // ì‹ ë¢°ë„ í‘œì‹œ
                let confidenceText = '';
                if (anno.confidence !== undefined) {
                    const confidencePercent = (anno.confidence * 100).toFixed(1);
                    confidenceText = '<br><small style="color: #888;">Confidence: ' + confidencePercent + '%</small>';
                }

                // ì‘ì„±ì ì •ë³´ í‘œì‹œ (ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ì— í‘œì‹œ, ìì‹ ì˜ ì–´ë…¸í…Œì´ì…˜ì€ íšŒìƒ‰ìœ¼ë¡œ)
                let authorText = '';
                const currentUser = getCurrentUser();
                if (anno.created_by_name && currentUser) {
                    const isOwnAnnotation = anno.created_by === currentUser.user_id;
                    const authorColor = isOwnAnnotation ? '#888' : '#4a9eff';
                    authorText = '<br><small style="color: ' + authorColor + ';">ğŸ‘¤ ' + anno.created_by_name + '</small>';
                }

                return '<div onclick="selectAnnotation(' + idx + ')" style="padding: 5px; margin: 3px 0; background: ' + bgColor + '; border-radius: 3px; border-left: 3px solid ' + borderColor + '; cursor: pointer;">' +
                    '<strong>' + (idx + 1) + '. ' + getDisplayLabel(anno.label) + '</strong>' + confidenceText + authorText + '<br>' +
                    '<small>Box: (' + Math.round(anno.box.x) + ', ' + Math.round(anno.box.y) + ') ' +
                    Math.round(anno.box.width) + 'x' + Math.round(anno.box.height) + '</small>' +
                '</div>';
            }).join('');
        }

        // ì–´ë…¸í…Œì´ì…˜ ì„ íƒ
        function selectAnnotation(idx) {
            selectedAnnotationIndex = idx;
            drawFrameWithMasks();
            updateAnnotationList();
            updateCommentSection();
            console.log('[ANNOTATION] Selected annotation from list:', idx);
        }

        // ì½”ë©˜íŠ¸ ì„¹ì…˜ ì—…ë°ì´íŠ¸
        function updateCommentSection() {
            const noAnnotationDiv = document.getElementById('noAnnotationSelected');
            const commentEditor = document.getElementById('commentEditor');
            const selectedAnnotationInfo = document.getElementById('selectedAnnotationInfo');
            const commentTextArea = document.getElementById('annotationCommentText');

            if (selectedAnnotationIndex === -1) {
                // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŒ
                noAnnotationDiv.style.display = 'block';
                commentEditor.style.display = 'none';
            } else {
                // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì´ ìˆìŒ
                noAnnotationDiv.style.display = 'none';
                commentEditor.style.display = 'block';

                const annotations = frameAnnotations[currentFrame] || [];
                const anno = annotations[selectedAnnotationIndex];

                if (anno) {
                    // ì–´ë…¸í…Œì´ì…˜ ì •ë³´ í‘œì‹œ
                    selectedAnnotationInfo.innerHTML = 'ğŸ“ ' + getDisplayLabel(anno.label) + ' (Annotation #' + (selectedAnnotationIndex + 1) + ')';

                    // ê¸°ì¡´ ì½”ë©˜íŠ¸ ë¡œë“œ
                    commentTextArea.value = anno.comment || '';
                }
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ ì½”ë©˜íŠ¸ ì €ì¥
        async function saveAnnotationComment() {
            if (selectedAnnotationIndex === -1) {
                alert('Please select an annotation first');
                return;
            }

            const commentTextArea = document.getElementById('annotationCommentText');
            const comment = commentTextArea.value.trim();

            const annotations = frameAnnotations[currentFrame];
            if (annotations && annotations[selectedAnnotationIndex]) {
                annotations[selectedAnnotationIndex].comment = comment;
                console.log('[COMMENT] Saved comment for annotation', selectedAnnotationIndex, ':', comment);

                // ì„±ê³µ í”¼ë“œë°±
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'ğŸ’¾ Saving...';
                btn.disabled = true;

                try {
                    // í”„ë ˆì„ì„ ì„œë²„ì— ì €ì¥ (ì½”ë©˜íŠ¸ í¬í•¨)
                    await saveCurrentFrame();

                    // ì €ì¥ ì™„ë£Œ í”¼ë“œë°±
                    btn.textContent = 'âœ“ Saved!';
                    btn.style.background = '#28a745';
                    console.log('[COMMENT] Comment saved to server successfully');
                } catch (error) {
                    // ì €ì¥ ì‹¤íŒ¨ í”¼ë“œë°±
                    btn.textContent = 'âœ— Failed';
                    btn.style.background = '#dc3545';
                    console.error('[COMMENT] Failed to save comment to server:', error);
                }

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.disabled = false;
                }, 1500);
            }
        }

        // í”„ë ˆì„-í´ë˜ìŠ¤ë³„ ì½”ë©˜íŠ¸ ì €ì¥ì†Œ
        let frameClassComments = {};

        // í˜‘ì—…ì ëª©ë¡ ì—…ë°ì´íŠ¸
        // í†µê³„ ì¹´ë“œ ìµœì†Œí™”/ìµœëŒ€í™” í† ê¸€
        function toggleStatistics() {
            const statsContent = document.getElementById('statsContent');
            const toggleBtn = document.getElementById('toggleStatsBtn');
            const statsCard = document.getElementById('statisticsCard');

            if (statsContent.style.display === 'none') {
                // ìµœëŒ€í™”
                statsContent.style.display = 'flex';
                toggleBtn.textContent = 'â–¼';
                statsCard.style.flexGrow = '1';
            } else {
                // ìµœì†Œí™”
                statsContent.style.display = 'none';
                toggleBtn.textContent = 'â–¶';
                statsCard.style.flexGrow = '0';
            }
        }

        function updateContributorsList() {
            const contributorsList = document.getElementById('contributorsList');

            if (!annotationContributors || annotationContributors.length === 0) {
                contributorsList.innerHTML = '<span style="color: #888;">ì•„ì§ í˜‘ì—…ìê°€ ì—†ìŠµë‹ˆë‹¤</span>';
                return;
            }

            contributorsList.innerHTML = annotationContributors.map(contributor => {
                const updateDate = new Date(contributor.updated_at).toLocaleDateString('ko-KR', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                return '<div style="padding: 3px 0;">' +
                    '<strong style="color: #4a9eff;">' + contributor.user_name + '</strong>' +
                    ' <span style="color: #888; font-size: 11px;">(' + updateDate + ')</span>' +
                    '</div>';
            }).join('');
        }

        // í†µê³„ ì—…ë°ì´íŠ¸ (Saveëœ ì–´ë…¸í…Œì´ì…˜ë§Œ í‘œì‹œ + í´ë˜ìŠ¤ë³„ í†µê³„)
        function updateStatistics() {
            console.log('[STATISTICS] updateStatistics() called');
            console.log('[STATISTICS] savedFrameAnnotations keys:', Object.keys(savedFrameAnnotations));

            let totalAnnotations = 0;
            let annotatedFrames = 0;

            // í´ë˜ìŠ¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const classes = currentProject?.classes || [];
            const classNames = classes.map(c => (typeof c === 'string') ? c : c.name);

            // í”„ë ˆì„ë³„ í´ë˜ìŠ¤ë³„ ì¹´ìš´íŠ¸ ì§‘ê³„
            const frameStats = {};
            for (const frame in savedFrameAnnotations) {
                const validAnnotations = savedFrameAnnotations[frame].filter(anno => !anno.is_full_frame);
                if (validAnnotations.length > 0) {
                    annotatedFrames++;
                    totalAnnotations += validAnnotations.length;

                    // í´ë˜ìŠ¤ë³„ ì¹´ìš´íŠ¸
                    const classCounts = {};
                    classNames.forEach(className => {
                        classCounts[className] = 0;
                    });

                    // ì½”ë©˜íŠ¸ê°€ ìˆëŠ” ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ”ì§€ ì²´í¬
                    const hasComment = validAnnotations.some(anno => anno.comment && anno.comment.trim().length > 0);

                    validAnnotations.forEach(anno => {
                        const label = anno.label || 'unknown';
                        if (classCounts[label] !== undefined) {
                            classCounts[label]++;
                        } else {
                            classCounts[label] = 1;
                        }
                    });

                    frameStats[frame] = {
                        total: validAnnotations.length,
                        byClass: classCounts,
                        hasComment: hasComment
                    };
                }
            }

            console.log('[STATISTICS] Total annotations:', totalAnnotations, 'Frames:', annotatedFrames);
            document.getElementById('statsInfo').textContent = 'Saved: ' + totalAnnotations + ' | Frames: ' + annotatedFrames;

            // í”„ë ˆì„ë³„ í†µê³„ í‘œì‹œ (í´ë˜ìŠ¤ë³„)
            const statsTable = document.getElementById('statsTable');
            if (annotatedFrames === 0) {
                statsTable.innerHTML = '<div style="color: #999;">No saved annotations</div>';
                return;
            }

            // í…Œì´ë¸” í—¤ë”
            let statsHTML = '<table style="width: 100%; font-size: 10px; border-collapse: collapse;">';
            statsHTML += '<tr style="background: #2d2d2d; position: sticky; top: 0; z-index: 1;">';
            statsHTML += '<th style="padding: 6px 4px; border: 1px solid #404040; min-width: 50px;">Frame</th>';

            classes.forEach((classObj, index) => {
                const className = classNames[index];  // ì‹¤ì œ ì €ì¥ëœ name (ì˜ë¬¸)
                const displayName = getClassDisplayName(classObj);  // í™”ë©´ í‘œì‹œìš©
                const shortName = displayName.length > 6 ? displayName.substring(0, 6) + '.' : displayName;
                const tooltip = currentLanguage === 'ko' ? className : (classObj.description || className);
                const classColor = getColorForClass(className);
                statsHTML += '<th style="padding: 6px 4px; border: 1px solid #404040; font-size: 9px; background: ' + classColor + '; color: #000; font-weight: bold;" title="' + tooltip + '">' + shortName + '</th>';
            });

            statsHTML += '<th style="padding: 6px 4px; border: 1px solid #404040;">Total</th>';
            statsHTML += '</tr>';

            // í…Œì´ë¸” ë°ì´í„°
            const sortedFrames = Object.keys(frameStats).sort((a, b) => parseInt(a) - parseInt(b));
            sortedFrames.forEach(frame => {
                const stats = frameStats[frame];
                const isSelected = (selectedStatsFrame !== null && parseInt(frame) === parseInt(selectedStatsFrame));
                const rowStyle = isSelected ? 'background: #4a9eff; color: #fff;' : '';

                statsHTML += '<tr style="' + rowStyle + '">';
                // Frame ë²ˆí˜¸ì— ì½”ë©˜íŠ¸ ì•„ì´ì½˜ ì¶”ê°€ (ì–´ë…¸í…Œì´ì…˜ì— ì½”ë©˜íŠ¸ê°€ ìˆëŠ” ê²½ìš°)
                const frameLabel = stats.hasComment ? frame + ' ğŸ’¬' : frame;
                const frameTitle = stats.hasComment ? 'This frame has annotation comments' : 'Click to jump to this frame';
                statsHTML += '<td style="padding: 4px; border: 1px solid #404040; cursor: pointer; font-weight: 600;" onclick="jumpToFrame(' + frame + ')" title="' + frameTitle + '">' + frameLabel + '</td>';

                classNames.forEach(className => {
                    const count = stats.byClass[className] || 0;
                    const comment = frameClassComments[frame]?.[className] || '';
                    const hasComment = comment.length > 0;
                    const classColor = getColorForClass(className);

                    // hexë¥¼ rgbaë¡œ ë³€í™˜ (ë°˜íˆ¬ëª… ë°°ê²½ìš©)
                    const hexToRgba = (hex, alpha) => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
                    };

                    const cellStyle = 'padding: 4px; border: 1px solid #404040; text-align: center; cursor: pointer;' +
                                     (count > 0 ? 'background: ' + hexToRgba(classColor, 0.3) + ';' : '') +
                                     (hasComment ? 'position: relative;' : '');
                    const cellTitle = hasComment ? 'Click to edit comment: ' + comment : 'Click to add comment';

                    statsHTML += '<td style="' + cellStyle + '" onclick="editFrameClassComment(' + frame + ', \'' + className + '\')" title="' + cellTitle + '">';
                    if (count > 0) {
                        statsHTML += '<span style="color: ' + classColor + '; font-weight: bold;">' + count + '</span>';
                    } else {
                        statsHTML += '<span style="color: #666;">-</span>';
                    }
                    if (hasComment) {
                        statsHTML += '<span style="position: absolute; top: 2px; right: 2px; font-size: 8px;">ğŸ’¬</span>';
                    }
                    statsHTML += '</td>';
                });

                statsHTML += '<td style="padding: 4px; border: 1px solid #404040; text-align: center; font-weight: 600; background: #3d3d3d;">' + stats.total + '</td>';
                statsHTML += '</tr>';
            });

            statsHTML += '</table>';
            statsTable.innerHTML = statsHTML;

            // Export ê¸°ëŠ¥ì€ Dataset íƒ­ìœ¼ë¡œ ì´ë™ë¨
        }

        // í”„ë ˆì„-í´ë˜ìŠ¤ ì½”ë©˜íŠ¸ í¸ì§‘
        function editFrameClassComment(frameNum, className) {
            const frame = frameNum.toString();
            const currentComment = frameClassComments[frame]?.[className] || '';

            const newComment = prompt(
                `Frame ${frame} - ${className}\n\nì½”ë©˜íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì·¨ì†Œí•˜ë ¤ë©´ ë¹ˆ ì¹¸):`,
                currentComment
            );

            if (newComment !== null) {
                if (!frameClassComments[frame]) {
                    frameClassComments[frame] = {};
                }

                if (newComment.trim() === '') {
                    // ë¹ˆ ë¬¸ìì—´ì´ë©´ ì½”ë©˜íŠ¸ ì‚­ì œ
                    delete frameClassComments[frame][className];
                    if (Object.keys(frameClassComments[frame]).length === 0) {
                        delete frameClassComments[frame];
                    }
                    console.log('[COMMENT] Deleted comment for frame', frame, 'class', className);
                } else {
                    frameClassComments[frame][className] = newComment.trim();
                    console.log('[COMMENT] Saved comment for frame', frame, 'class', className, ':', newComment.trim());
                }

                // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                saveFrameClassComments();

                // í†µê³„ í…Œì´ë¸” ì—…ë°ì´íŠ¸
                updateStatistics();
            }
        }

        // ì½”ë©˜íŠ¸ë¥¼ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        function saveFrameClassComments() {
            if (currentProject) {
                const key = `frameClassComments_${currentProject.id}`;
                localStorage.setItem(key, JSON.stringify(frameClassComments));
                console.log('[COMMENT] Saved to localStorage:', key);
            }
        }

        // ì½”ë©˜íŠ¸ë¥¼ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œ
        function loadFrameClassComments() {
            if (currentProject) {
                const key = `frameClassComments_${currentProject.id}`;
                const saved = localStorage.getItem(key);
                if (saved) {
                    frameClassComments = JSON.parse(saved);
                    console.log('[COMMENT] Loaded from localStorage:', key, frameClassComments);
                } else {
                    frameClassComments = {};
                }
            }
        }

        // í”„ë ˆì„ìœ¼ë¡œ ì´ë™
        async function jumpToFrame(frameNum) {
            currentFrame = parseInt(frameNum);
            selectedStatsFrame = currentFrame;  // ì„ íƒëœ í”„ë ˆì„ ê¸°ë¡
            await loadFrame(currentFrame);
            updateFrameLabel();
            updateAnnotationList();
            updateStatistics();  // í†µê³„ í…Œì´ë¸” ì—…ë°ì´íŠ¸í•˜ì—¬ í•˜ì´ë¼ì´íŠ¸ ì ìš©
        }

        // ì£¼ì„ í¸ì§‘
        function editAnnotation() {
            if (selectedAnnotationIndex === -1) {
                alert('Please select an annotation to edit');
                return;
            }

            const annotations = frameAnnotations[currentFrame];
            if (!annotations || selectedAnnotationIndex >= annotations.length) {
                alert('Selected annotation not found');
                selectedAnnotationIndex = -1;
                return;
            }

            const anno = annotations[selectedAnnotationIndex];
            const newLabel = prompt('Edit label:', anno.label);

            if (newLabel && newLabel.trim() !== '') {
                anno.label = newLabel.trim();
                drawFrameWithMasks();
                updateAnnotationList();
                console.log('[ANNOTATION] Edited annotation', selectedAnnotationIndex, 'to label:', newLabel);
            }
        }

        // ì£¼ì„ ì‚­ì œ (í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ)
        async function deleteAnnotation() {
            if (selectedAnnotationIndex === -1) {
                alert('Please select an annotation to delete');
                return;
            }

            const annotations = frameAnnotations[currentFrame];
            if (!annotations || selectedAnnotationIndex >= annotations.length) {
                alert('Selected annotation not found');
                selectedAnnotationIndex = -1;
                return;
            }

            // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const currentUser = getCurrentUser();
            if (!currentUser) {
                alert('ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ í™•ì¸
            const selectedAnnotation = annotations[selectedAnnotationIndex];

            // í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ì¸ì§€ í™•ì¸
            if (selectedAnnotation.created_by && selectedAnnotation.created_by !== currentUser.user_id) {
                alert('ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì‘ì„±ì: ' + (selectedAnnotation.created_by_name || selectedAnnotation.created_by));
                selectedAnnotationIndex = -1;
                return;
            }

            // ì‚­ì œ ìˆ˜í–‰
            annotations.splice(selectedAnnotationIndex, 1);

            // ë¹ˆ ë°°ì—´ì´ë©´ í”„ë ˆì„ í‚¤ ìœ ì§€ (ë¹ˆ ë°°ì—´ë¡œ ì €ì¥í•˜ì—¬ ëª…ì‹œì  ì‚­ì œ ê¸°ë¡)
            if (annotations.length === 0) {
                frameAnnotations[currentFrame] = [];
            }

            selectedAnnotationIndex = -1;
            drawFrameWithMasks();
            updateAnnotationList();
            updateStatistics();
            console.log('[ANNOTATION] Deleted annotation');

            // ì„œë²„ì— ìë™ ì €ì¥
            await saveCurrentFrame();
        }

        // í”„ë ˆì„ ì´ˆê¸°í™” (í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ)
        async function clearFrame() {
            // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const currentUser = getCurrentUser();
            if (!currentUser) {
                alert('ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            const annotations = frameAnnotations[currentFrame];
            if (!annotations || annotations.length === 0) {
                console.log('[ANNOTATION] Frame already empty');
                return;
            }

            // í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ ê°œìˆ˜ í™•ì¸
            const myAnnotations = annotations.filter(ann =>
                !ann.created_by || ann.created_by === currentUser.user_id
            );
            const othersAnnotations = annotations.filter(ann =>
                ann.created_by && ann.created_by !== currentUser.user_id
            );

            if (myAnnotations.length === 0) {
                alert('í˜„ì¬ í”„ë ˆì„ì— ì‚­ì œí•  ìˆ˜ ìˆëŠ” ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.\n(ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ ìˆìŒ)');
                return;
            }

            // ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ ë‚¨ê¸°ê¸°
            if (othersAnnotations.length > 0) {
                const confirmMsg = `í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ ${myAnnotations.length}ê°œë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.\në‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ ${othersAnnotations.length}ê°œëŠ” ìœ ì§€ë©ë‹ˆë‹¤.\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                if (!confirm(confirmMsg)) {
                    return;
                }
                frameAnnotations[currentFrame] = othersAnnotations;
            } else {
                // ëª¨ë‘ í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ì¸ ê²½ìš°
                const confirmMsg = `í”„ë ˆì„ì˜ ëª¨ë“  ì–´ë…¸í…Œì´ì…˜(${myAnnotations.length}ê°œ)ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                if (!confirm(confirmMsg)) {
                    return;
                }
                frameAnnotations[currentFrame] = [];
            }

            drawFrameWithMasks();
            updateAnnotationList();
            updateStatistics();
            console.log(`[ANNOTATION] Cleared ${myAnnotations.length} annotation(s), kept ${othersAnnotations.length} from other users`);

            // ì„œë²„ì— ìë™ ì €ì¥
            await saveCurrentFrame();
        }

        // Annotation íƒ­ì˜ ë‚´ë³´ë‚´ê¸° í•¨ìˆ˜ë“¤ì€ Dataset íƒ­ìœ¼ë¡œ ì´ë™ë¨
        // exportVideo, exportJSON, exportFinal ê¸°ëŠ¥ì€ Dataset íƒ­ì˜ Export ë²„íŠ¼ ì‚¬ìš©

        // í˜„ì¬ í”„ë ˆì„ ì €ì¥ (Statisticsì— ë°˜ì˜ ë° ì„œë²„ì— ì¦‰ì‹œ ì €ì¥)
        async function saveCurrentFrame() {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            // ë¹ˆ í”„ë ˆì„ë„ ì €ì¥ ê°€ëŠ¥í•˜ë„ë¡ ìˆ˜ì • (ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œí•œ ê²½ìš°ë¥¼ ê¸°ë¡)
            // Deep copy current frame annotations to savedFrameAnnotations
            if (!frameAnnotations[currentFrame]) {
                frameAnnotations[currentFrame] = [];
            }
            savedFrameAnnotations[currentFrame] = JSON.parse(JSON.stringify(frameAnnotations[currentFrame]));
            console.log('[ANNOTATION] Frame', currentFrame, 'saved to Statistics');

            // Update Statistics immediately
            updateStatistics();

            // Save to server immediately
            // IMPORTANT: Only send current user's annotations to prevent overwriting other users' data
            try {
                const currentUser = getCurrentUser();
                if (!currentUser) {
                    console.error('[ANNOTATION] Cannot save: no user info');
                    return;
                }

                // Filter to only include current user's annotations
                // BUT: If an annotation has a comment added by current user, include it
                const myAnnotations = {};
                for (const [frameKey, annotations] of Object.entries(savedFrameAnnotations)) {
                    if (Array.isArray(annotations)) {
                        const myFrameAnnotations = annotations.filter(ann => {
                            // Include if created_by is not set (new annotation) or matches current user
                            const isMyAnnotation = !ann.created_by || ann.created_by === currentUser.user_id;
                            // Also include if this annotation has a comment field (even if empty - for deletion)
                            // This ensures comment deletion is also sent to server
                            const hasCommentField = 'comment' in ann;
                            return isMyAnnotation || hasCommentField;
                        });
                        myAnnotations[frameKey] = myFrameAnnotations;
                    }
                }

                console.log('[ANNOTATION] Saving only current user annotations:', Object.keys(myAnnotations).length, 'frames');

                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        annotations: myAnnotations
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[ANNOTATION] Frame', currentFrame, 'saved to server');
                    // ì €ì¥ ì„±ê³µ - alert ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬
                } else {
                    console.error('[ANNOTATION] Save failed:', data.error);
                    alert('Failed to save frame: ' + data.error);
                }
            } catch (error) {
                console.error('[ANNOTATION] Save error:', error);
                alert('Failed to save frame: ' + error.message);
            }
        }

        // ì„¸ì…˜ ì €ì¥ (savedFrameAnnotationsë¥¼ ì„œë²„ì— ì €ì¥)
        async function saveSession() {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            // Check if there are saved frames to persist
            const savedFrameCount = Object.keys(savedFrameAnnotations).length;
            if (savedFrameCount === 0) {
                alert('No saved frames to persist. Use "Save Frame" first.');
                return;
            }

            try {
                const currentUser = getCurrentUser();
                if (!currentUser) {
                    alert('ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                // Filter to only include current user's annotations
                // BUT: If an annotation has a comment added by current user, include it
                const myAnnotations = {};
                for (const [frameKey, annotations] of Object.entries(savedFrameAnnotations)) {
                    if (Array.isArray(annotations)) {
                        const myFrameAnnotations = annotations.filter(ann => {
                            // Include if created_by is not set (new annotation) or matches current user
                            const isMyAnnotation = !ann.created_by || ann.created_by === currentUser.user_id;
                            // Also include if this annotation has a comment field (even if empty - for deletion)
                            // This ensures comment deletion is also sent to server
                            const hasCommentField = 'comment' in ann;
                            return isMyAnnotation || hasCommentField;
                        });
                        myAnnotations[frameKey] = myFrameAnnotations;
                    }
                }

                const myFrameCount = Object.keys(myAnnotations).length;
                console.log('[ANNOTATION] Saving only current user annotations:', myFrameCount, 'frames');

                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        annotations: myAnnotations
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[ANNOTATION] Session saved:', data.file);
                    console.log('[ANNOTATION] Saved', myFrameCount, 'frames to server');
                    alert('Session saved! (' + myFrameCount + ' frames persisted)');
                } else {
                    console.error('[ANNOTATION] Save failed:', data.error);
                    alert('Failed to save session: ' + data.error);
                }
            } catch (error) {
                console.error('[ANNOTATION] Save error:', error);
                alert('Failed to save session: ' + error.message);
            }
        }

        // ì„¸ì…˜ ë¡œë“œ (ìˆ˜ë™)
        async function loadSession() {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations');
                const data = await response.json();

                if (data.success) {
                    // Load into savedFrameAnnotations (persisted state)
                    savedFrameAnnotations = data.annotations || {};

                    // Also copy to frameAnnotations so saved annotations are visible
                    frameAnnotations = JSON.parse(JSON.stringify(savedFrameAnnotations));

                    // ê¸°ì—¬ì ì •ë³´ ì €ì¥
                    annotationContributors = data.contributors || [];

                    selectedAnnotationIndex = -1;
                    drawFrameWithMasks();
                    updateAnnotationList();
                    updateStatistics();
                    updateContributorsList();  // ê¸°ì—¬ì ëª©ë¡ ì—…ë°ì´íŠ¸

                    console.log('[ANNOTATION] Session loaded:', Object.keys(savedFrameAnnotations).length, 'frames');
                    console.log('[ANNOTATION] Contributors:', annotationContributors.length, 'users');
                    alert('Annotations loaded successfully!');
                } else {
                    console.error('[ANNOTATION] Load failed:', data.error);
                    alert('Failed to load annotations: ' + data.error);
                }
            } catch (error) {
                console.error('[ANNOTATION] Load error:', error);
                alert('Failed to load annotations: ' + error.message);
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ ìë™ ë¡œë“œ (ë¹„ë””ì˜¤ ë¡œë“œ ì‹œ)
        async function autoLoadAnnotations() {
            if (!currentProjectId || !currentVideoId) {
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations');
                const data = await response.json();

                if (data.success && data.annotations) {
                    // Load into savedFrameAnnotations (persisted state for Statistics)
                    savedFrameAnnotations = data.annotations;

                    // Also copy to frameAnnotations so saved annotations are visible
                    frameAnnotations = JSON.parse(JSON.stringify(data.annotations));

                    // ê¸°ì—¬ì ì •ë³´ ì €ì¥
                    annotationContributors = data.contributors || [];

                    updateAnnotationList();
                    updateStatistics();
                    updateContributorsList();  // ê¸°ì—¬ì ëª©ë¡ ì—…ë°ì´íŠ¸
                    console.log('[ANNOTATION] Auto-loaded', Object.keys(savedFrameAnnotations).length, 'saved frames from server');
                    console.log('[ANNOTATION] Contributors:', annotationContributors.length, 'users');
                }
            } catch (error) {
                console.log('[ANNOTATION] No previous annotations found (this is normal for new videos)');
            }
        }

        // ===== Dataset Tab Functions =====
        function selectAllVideos() {
            alert('ë¹„ë””ì˜¤ ì „ì²´ ì„ íƒ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function deselectAllVideos() {
            alert('ë¹„ë””ì˜¤ ì„ íƒ í•´ì œ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function buildDataset() {
            alert('ë°ì´í„°ì…‹ ë¹Œë“œ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        async function exportYOLO() {
            await exportDataset('yolo');
        }

        async function exportSegFormer() {
            await exportDataset('segformer');
        }

        async function exportDataset(format) {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            if (Object.keys(frameAnnotations).length === 0) {
                alert('No annotations to export');
                return;
            }

            // ì‚¬ìš©ì ì¶”ê°€ ì–´ë…¸í…Œì´ì…˜ ê°œìˆ˜ í™•ì¸
            let userAnnotationCount = 0;
            for (const frame in frameAnnotations) {
                const userAnnotations = frameAnnotations[frame].filter(anno => !anno.auto_detected);
                userAnnotationCount += userAnnotations.length;
            }

            if (userAnnotationCount === 0) {
                alert('No user annotations to export. Please add manual annotations before exporting.');
                return;
            }

            const formatName = format === 'yolo' ? 'YOLO Segmentation' : 'SegFormer';
            if (!confirm(`Export dataset in ${formatName} format?\n\nFrames with annotations: ${Object.keys(frameAnnotations).length}\nUser annotations: ${userAnnotationCount}`)) {
                return;
            }

            try {
                console.log(`[EXPORT] Exporting ${formatName} dataset...`);

                const response = await fetch(API_BASE_URL + '/api/export/dataset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_id: currentProjectId,
                        video_id: currentVideoId,
                        annotations: frameAnnotations,
                        format: format,
                        output_dir: 'datasets'
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[EXPORT] Dataset exported successfully:', data);
                    alert(`${formatName} dataset exported successfully!\n\nFrames: ${data.frames_exported}\nLocation: ${data.output_dir}\n\nFormat:\n` +
                        (format === 'segformer' ? '- images/ (frames)\n- masks/ (segmentation masks)\n- dataset_info.json' :
                                                  '- images/ (frames)\n- labels/ (polygon annotations)\n- dataset_info.json'));
                } else {
                    console.error('[EXPORT] Export failed:', data.error);
                    alert('Failed to export dataset: ' + data.error);
                }
            } catch (error) {
                console.error('[EXPORT] Export error:', error);
                alert('Failed to export dataset: ' + error.message);
            }
        }

        // ===== Training Tab Functions =====
        function browseDataset() {
            alert('ë°ì´í„°ì…‹ ì„ íƒ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function startTraining() {
            alert('í•™ìŠµ ì‹œì‘ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function stopTraining() {
            alert('í•™ìŠµ ì¤‘ì§€ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        // ===== Inference Tab Functions =====
        function browseInferenceModel() {
            alert('ëª¨ë¸ ì„ íƒ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function browseInferenceVideo() {
            alert('ë¹„ë””ì˜¤ ì„ íƒ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        async function startInference() {
            const modelType = document.getElementById('inferenceModelType').value;
            let modelPath = document.getElementById('inferenceModelPath').value.trim();
            const videoPath = document.getElementById('inferenceVideoPath').value.trim();
            const outputPath = document.getElementById('inferenceOutputPath').value.trim();

            // ë¹„ë””ì˜¤ ê²½ë¡œ í™•ì¸
            if (!videoPath) {
                alert('ë¹„ë””ì˜¤ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            // ëª¨ë¸ ê²½ë¡œê°€ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš°, í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ëª¨ë¸ ì‚¬ìš©
            if (!modelPath) {
                if (!currentProject || !currentProject.id) {
                    alert('ëª¨ë¸ ê²½ë¡œë¥¼ ì§€ì •í•˜ê±°ë‚˜ í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }

                // segformer ëª¨ë¸ íƒ€ì…ì¸ ê²½ìš° í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ëª¨ë¸ ê²½ë¡œ ì‚¬ìš©
                if (modelType === 'segformer') {
                    modelPath = `projects/${currentProject.user_id || 'default'}/${currentProject.id}/segformer_best.pth`;
                } else {
                    alert('ëª¨ë¸ íŒŒì¼ì„ ì§€ì •í•´ì£¼ì„¸ìš”.');
                    return;
                }
            }

            // ê¸°ì¡´ ì¶”ë¡  ê²°ê³¼ í™•ì¸
            try {
                const checkResponse = await authFetch('/api/inference/check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        video_path: videoPath,
                        output_path: outputPath
                    })
                });

                const checkData = await checkResponse.json();

                if (checkData.success && checkData.exists) {
                    // ì´ë¯¸ ì¶”ë¡  ê²°ê³¼ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°
                    const frameInfo = `\n\ní”„ë ˆì„ ìˆ˜: ${checkData.frame_count}\nFPS: ${checkData.fps}`;
                    const choice = confirm(
                        'ì´ë¯¸ ì¶”ë¡  ê²°ê³¼ê°€ ì¡´ì¬í•©ë‹ˆë‹¤!' + frameInfo +
                        '\n\n[í™•ì¸] - ê¸°ì¡´ ê²°ê³¼ ë³´ê¸°\n[ì·¨ì†Œ] - ì¬ì‹¤í–‰'
                    );

                    if (choice) {
                        // ê¸°ì¡´ ê²°ê³¼ ë³´ê¸°
                        viewInferenceResults(checkData);
                        return;
                    }
                    // ì·¨ì†Œë¥¼ ì„ íƒí•˜ë©´ ê³„ì† ì§„í–‰í•˜ì—¬ ì¬ì‹¤í–‰
                }
            } catch (error) {
                console.error('[INFERENCE] Check error:', error);
                // í™•ì¸ ì‹¤íŒ¨ ì‹œ ê·¸ëƒ¥ ê³„ì† ì§„í–‰
            }

            try {
                document.getElementById('startInferenceBtn').disabled = true;
                document.getElementById('inferenceProgress').textContent = 'ì¶”ë¡  ì‹œì‘ ì¤‘...';

                const response = await authFetch('/api/inference', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_type: modelType,
                        model_path: modelPath,
                        video_path: videoPath,
                        output_path: outputPath
                    })
                });

                const data = await response.json();

                if (data.success && data.job_id) {
                    // ì‘ì—… ID ì €ì¥
                    currentJobId = data.job_id;

                    // ì·¨ì†Œ ë²„íŠ¼ í‘œì‹œ
                    const cancelBtn = document.getElementById('cancelInferenceBtn');
                    if (cancelBtn) {
                        cancelBtn.style.display = 'inline-block';
                        cancelBtn.disabled = false;
                    }

                    // ì§„í–‰ ìƒí™© ì²´í¬ ì‹œì‘
                    document.getElementById('inferenceProgress').textContent = 'ì¶”ë¡  ì§„í–‰ ì¤‘... 0%';
                    startProgressPolling();

                    // ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ì‹œì‘
                    startPreviewPlayer();
                } else {
                    alert('ì¶”ë¡  ì‹œì‘ ì‹¤íŒ¨: ' + data.error);
                    document.getElementById('inferenceProgress').textContent = 'ì¶”ë¡  ì‹¤íŒ¨';
                    document.getElementById('startInferenceBtn').disabled = false;
                }
            } catch (error) {
                console.error('[INFERENCE] Error:', error);
                alert('ì¶”ë¡  ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                document.getElementById('inferenceProgress').textContent = 'ì˜¤ë¥˜ ë°œìƒ';
                document.getElementById('startInferenceBtn').disabled = false;
            }
        }

        // ì§„í–‰ ìƒí™© í´ë§ ì‹œì‘
        function startProgressPolling() {
            if (progressInterval) {
                clearInterval(progressInterval);
            }

            progressInterval = setInterval(async () => {
                if (!currentJobId) {
                    clearInterval(progressInterval);
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/api/inference/status/${currentJobId}`);
                    const data = await response.json();

                    if (data.success) {
                        const progress = data.progress || 0;
                        const currentFrame = data.current_frame || 0;
                        const totalFrames = data.total_frames || 0;
                        const status = data.status;

                        // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                        document.getElementById('inferenceProgress').textContent =
                            `ì¶”ë¡  ì§„í–‰ ì¤‘... ${progress.toFixed(1)}% (${currentFrame}/${totalFrames} í”„ë ˆì„)`;

                        // ë¯¸ë¦¬ë³´ê¸° ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
                        const previewStatus = document.getElementById('inferencePreviewStatus');
                        if (previewStatus) {
                            previewStatus.textContent = `í”„ë ˆì„: ${currentFrame} / ${totalFrames}`;
                        }

                        // ì™„ë£Œ ë˜ëŠ” ì·¨ì†Œë¨
                        if (status === 'completed') {
                            clearInterval(progressInterval);
                            stopPreviewPlayer();
                            document.getElementById('inferenceProgress').textContent = 'ì¶”ë¡  ì™„ë£Œ!';
                            document.getElementById('startInferenceBtn').disabled = false;
                            document.getElementById('cancelInferenceBtn').style.display = 'none';
                            alert('ì¶”ë¡ ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\nì¶œë ¥ ë””ë ‰í† ë¦¬: ' + data.output_path);
                            currentJobId = null;
                        } else if (status === 'cancelled') {
                            clearInterval(progressInterval);
                            stopPreviewPlayer();
                            document.getElementById('inferenceProgress').textContent = 'ì¶”ë¡ ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                            document.getElementById('startInferenceBtn').disabled = false;
                            document.getElementById('cancelInferenceBtn').style.display = 'none';
                            currentJobId = null;
                        } else if (status === 'failed') {
                            clearInterval(progressInterval);
                            stopPreviewPlayer();
                            console.error('[INFERENCE] Job failed:', data.error);
                            document.getElementById('inferenceProgress').textContent = 'ì¶”ë¡  ì‹¤íŒ¨';
                            document.getElementById('startInferenceBtn').disabled = false;
                            document.getElementById('cancelInferenceBtn').style.display = 'none';
                            alert('ì¶”ë¡  ì‹¤íŒ¨: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
                            currentJobId = null;
                        }
                    } else {
                        console.error('[INFERENCE] Status check failed:', data);
                    }
                } catch (error) {
                    console.error('[INFERENCE] Progress check error:', error);
                    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† í´ë§ (ì„œë²„ ì¬ì‹œì‘ ë“±ì˜ ê²½ìš°)
                }
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì²´í¬
        }

        // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ì‹œì‘
        function startPreviewPlayer() {
            // Placeholder ìˆ¨ê¸°ê³  í”Œë ˆì´ì–´ í‘œì‹œ
            document.getElementById('inferencePreviewPlaceholder').style.display = 'none';
            document.getElementById('inferencePreviewPlayer').style.display = 'flex';

            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            inferencePreviewCanvas = document.getElementById('inferencePreviewCanvas');
            inferencePreviewCtx = inferencePreviewCanvas.getContext('2d');

            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™”
            playerState.isPlaying = false;
            playerState.currentFrameIndex = 0;
            playerState.frameCache.clear();

            // ê¸°ì¡´ ì¸í„°ë²Œì´ ìˆìœ¼ë©´ ì¤‘ì§€
            if (previewInterval) {
                clearInterval(previewInterval);
            }

            // í”„ë ˆì„ ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œì‘ (1ì´ˆë§ˆë‹¤)
            previewInterval = setInterval(updatePlayerInfo, 1000);

            // ìµœì‹  í”„ë ˆì„ ìë™ í‘œì‹œ ì‹œì‘
            updateLatestFrame();
        }

        // í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸ (ì²˜ë¦¬ëœ í”„ë ˆì„ ìˆ˜, FPS ë“±)
        async function updatePlayerInfo() {
            if (!currentJobId) return;

            try {
                const response = await fetch(`${API_BASE_URL}/api/inference/frames/${currentJobId}`);
                const data = await response.json();

                if (data.success) {
                    playerState.totalFrames = data.total_frames;
                    playerState.processedFrames = data.processed_frames;
                    playerState.fps = data.fps || 30;

                    // íƒ€ì„ë¼ì¸ ì—…ë°ì´íŠ¸
                    const timeline = document.getElementById('videoTimeline');
                    timeline.max = Math.max(1, playerState.processedFrames - 1);

                    // ë²„í¼ ìƒíƒœ í‘œì‹œ
                    const bufferPercent = playerState.totalFrames > 0
                        ? (playerState.processedFrames / playerState.totalFrames * 100).toFixed(1)
                        : 0;
                    document.getElementById('inferenceBufferStatus').textContent = `ë²„í¼: ${bufferPercent}%`;

                    // ì¬ìƒ ì¤‘ì´ ì•„ë‹ˆë©´ ìµœì‹  í”„ë ˆì„ í‘œì‹œ
                    if (!playerState.isPlaying && playerState.processedFrames > 0) {
                        playerState.currentFrameIndex = playerState.processedFrames - 1;
                        await displayFrame(playerState.currentFrameIndex);
                    }
                }
            } catch (error) {
            }
        }

        // ìµœì‹  í”„ë ˆì„ ìë™ í‘œì‹œ
        async function updateLatestFrame() {
            if (!currentJobId || playerState.isPlaying) return;

            try {
                const response = await fetch(`${API_BASE_URL}/api/inference/frames/${currentJobId}`);
                const data = await response.json();

                if (data.success && data.processed_frames > 0) {
                    playerState.currentFrameIndex = data.processed_frames - 1;
                    await displayFrame(playerState.currentFrameIndex);
                }
            } catch (error) {
            }
        }

        // íŠ¹ì • í”„ë ˆì„ í‘œì‹œ
        async function displayFrame(frameIndex) {
            if (!currentJobId) return;

            try {
                // ìºì‹œì— ìˆìœ¼ë©´ ìºì‹œì—ì„œ ê°€ì ¸ì˜¤ê¸°
                if (playerState.frameCache.has(frameIndex)) {
                    const img = playerState.frameCache.get(frameIndex);
                    drawInferenceFrame(img);
                    updateTimeDisplay();
                    return;
                }

                // ì„œë²„ì—ì„œ í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°
                const img = new Image();

                img.onload = function() {
                    // ìºì‹œì— ì €ì¥ (ìµœëŒ€ 50í”„ë ˆì„ê¹Œì§€)
                    if (playerState.frameCache.size < 50) {
                        playerState.frameCache.set(frameIndex, img);
                    }

                    drawInferenceFrame(img);
                    updateTimeDisplay();
                };

                img.onerror = function() {
                };

                img.src = `${API_BASE_URL}/api/inference/frame/${currentJobId}/${frameIndex}`;

            } catch (error) {
            }
        }

        // Inference í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
        function drawInferenceFrame(img) {
            if (!inferencePreviewCanvas || !inferencePreviewCtx) return;

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
            if (inferencePreviewCanvas.width !== img.width || inferencePreviewCanvas.height !== img.height) {
                inferencePreviewCanvas.width = img.width;
                inferencePreviewCanvas.height = img.height;
            }

            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            inferencePreviewCtx.clearRect(0, 0, inferencePreviewCanvas.width, inferencePreviewCanvas.height);
            inferencePreviewCtx.drawImage(img, 0, 0);
        }

        // ì‹œê°„ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateTimeDisplay() {
            const currentTime = playerState.currentFrameIndex / playerState.fps;
            const totalTime = playerState.processedFrames / playerState.fps;

            document.getElementById('videoCurrentTime').textContent = formatTime(currentTime);
            document.getElementById('videoDuration').textContent = formatTime(totalTime);

            // íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸
            const timeline = document.getElementById('videoTimeline');
            timeline.value = playerState.currentFrameIndex;

            // í”„ë ˆì„ ìƒíƒœ ì—…ë°ì´íŠ¸
            document.getElementById('inferencePreviewStatus').textContent =
                `í”„ë ˆì„: ${playerState.currentFrameIndex + 1} / ${playerState.processedFrames}`;
        }

        // ì‹œê°„ í¬ë§·íŒ… (ì´ˆ -> MM:SS)
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // í”Œë ˆì´ì–´ ì¤‘ì§€
        function stopPreviewPlayer() {
            // ì¬ìƒ ì¤‘ì§€
            if (playerState.isPlaying) {
                togglePlayPause();
            }

            // ì¸í„°ë²Œ ì¤‘ì§€
            if (previewInterval) {
                clearInterval(previewInterval);
                previewInterval = null;
            }

            // í”Œë ˆì´ì–´ ìˆ¨ê¸°ê³  Placeholder í‘œì‹œ
            document.getElementById('inferencePreviewPlayer').style.display = 'none';
            document.getElementById('inferencePreviewPlaceholder').style.display = 'block';

            // ìƒíƒœ ì´ˆê¸°í™”
            playerState.frameCache.clear();
        }

        // ì¬ìƒ/ì¼ì‹œì •ì§€ í† ê¸€
        function togglePlayPause() {
            if (playerState.isPlaying) {
                pausePlayback();
            } else {
                startPlayback();
            }
        }

        // ì¬ìƒ ì‹œì‘
        function startPlayback() {
            if (playerState.processedFrames === 0) {
                alert('ì•„ì§ ì²˜ë¦¬ëœ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            playerState.isPlaying = true;
            document.getElementById('playPauseBtn').innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';

            // ì¬ìƒ ì†ë„ì— ë”°ë¥¸ ì¸í„°ë²Œ ê³„ì‚°
            const frameInterval = (1000 / playerState.fps) / playerState.playbackSpeed;

            playerState.playbackInterval = setInterval(() => {
                playerState.currentFrameIndex++;

                // ëì— ë„ë‹¬í•˜ë©´ ì²˜ìŒìœ¼ë¡œ
                if (playerState.currentFrameIndex >= playerState.processedFrames) {
                    playerState.currentFrameIndex = 0;
                }

                displayFrame(playerState.currentFrameIndex);
            }, frameInterval);

        }

        // ì¬ìƒ ì¼ì‹œì •ì§€
        function pausePlayback() {
            playerState.isPlaying = false;
            document.getElementById('playPauseBtn').innerHTML = 'â–¶ï¸ ì¬ìƒ';

            if (playerState.playbackInterval) {
                clearInterval(playerState.playbackInterval);
                playerState.playbackInterval = null;
            }

        }

        // ì¬ìƒ ì •ì§€ (ì²˜ìŒìœ¼ë¡œ)
        function stopPlayback() {
            pausePlayback();
            playerState.currentFrameIndex = 0;
            displayFrame(0);
        }

        // í”„ë ˆì„ ê±´ë„ˆë›°ê¸°
        function skipFrames(count) {
            if (playerState.processedFrames === 0) return;

            playerState.currentFrameIndex += count;

            // ë²”ìœ„ ì²´í¬
            if (playerState.currentFrameIndex < 0) {
                playerState.currentFrameIndex = 0;
            } else if (playerState.currentFrameIndex >= playerState.processedFrames) {
                playerState.currentFrameIndex = playerState.processedFrames - 1;
            }

            displayFrame(playerState.currentFrameIndex);
        }

        // íŠ¹ì • í”„ë ˆì„ìœ¼ë¡œ ì´ë™ (íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë”)
        function seekToFrame(frameIndex) {
            frameIndex = parseInt(frameIndex);

            if (frameIndex < 0 || frameIndex >= playerState.processedFrames) return;

            playerState.currentFrameIndex = frameIndex;
            displayFrame(frameIndex);
        }

        // ì¬ìƒ ì†ë„ ë³€ê²½
        function changePlaybackSpeed() {
            const speed = parseFloat(document.getElementById('playbackSpeed').value);
            playerState.playbackSpeed = speed;

            // ì¬ìƒ ì¤‘ì´ë©´ ì¬ì‹œì‘
            if (playerState.isPlaying) {
                pausePlayback();
                startPlayback();
            }

        }

        // ì™„ë£Œëœ ì¶”ë¡  ê²°ê³¼ ë³´ê¸°
        async function viewInferenceResults(resultData) {

            // ê°€ì§œ job_id ìƒì„± (ì™„ë£Œëœ ê²°ê³¼ìš©)
            const viewerJobId = 'viewer_' + Date.now();
            currentJobId = viewerJobId;

            // active_jobs ìŠ¤íƒ€ì¼ ê°ì²´ ìƒì„± (GPU ì„œë²„ì—ëŠ” ì¡´ì¬í•˜ì§€ ì•Šì§€ë§Œ í”„ë¡ íŠ¸ì—”ë“œìš©)
            playerState.totalFrames = resultData.total_frames;
            playerState.processedFrames = resultData.frame_count;
            playerState.fps = resultData.fps;
            playerState.currentFrameIndex = 0;
            playerState.isPlaying = false;
            playerState.frameCache.clear();

            // Placeholder ìˆ¨ê¸°ê³  í”Œë ˆì´ì–´ í‘œì‹œ
            document.getElementById('inferencePreviewPlaceholder').style.display = 'none';
            document.getElementById('inferencePreviewPlayer').style.display = 'flex';

            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            inferencePreviewCanvas = document.getElementById('inferencePreviewCanvas');
            inferencePreviewCtx = inferencePreviewCanvas.getContext('2d');

            // íƒ€ì„ë¼ì¸ ì„¤ì •
            const timeline = document.getElementById('videoTimeline');
            timeline.max = Math.max(1, playerState.processedFrames - 1);

            // ë²„í¼ ìƒíƒœ í‘œì‹œ (ì™„ë£Œë¨)
            document.getElementById('inferenceBufferStatus').textContent = 'ë²„í¼: 100%';

            // ê²°ê³¼ ë””ë ‰í† ë¦¬ ê¸°ë°˜ìœ¼ë¡œ í”„ë ˆì„ ë¡œë“œ í•¨ìˆ˜ ì¬ì •ì˜
            window.loadCompletedFrame = async function(frameIndex) {
                if (frameIndex < 0 || frameIndex >= playerState.processedFrames) return;

                try {
                    // ìºì‹œ í™•ì¸
                    if (playerState.frameCache.has(frameIndex)) {
                        const img = playerState.frameCache.get(frameIndex);
                        drawInferenceFrame(img);
                        updateTimeDisplay();
                        return;
                    }

                    // APIë¥¼ í†µí•´ í”„ë ˆì„ ë¡œë“œ
                    const framePath = `${resultData.result_path}/frame_${frameIndex.toString().padStart(6, '0')}.jpg`;

                    const response = await fetch(API_BASE_URL + '/api/inference/completed-frame', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({frame_path: framePath})
                    });

                    if (!response.ok) {
                        return;
                    }

                    const blob = await response.blob();
                    const img = new Image();

                    img.onload = function() {
                        if (playerState.frameCache.size < 50) {
                            playerState.frameCache.set(frameIndex, img);
                        }
                        drawInferenceFrame(img);
                        updateTimeDisplay();
                        URL.revokeObjectURL(img.src);
                    };

                    img.onerror = function() {
                        URL.revokeObjectURL(img.src);
                    };

                    img.src = URL.createObjectURL(blob);

                } catch (error) {
                }
            };

            // displayFrameì„ ì™„ë£Œëœ ê²°ê³¼ìš©ìœ¼ë¡œ ë®ì–´ì“°ê¸°
            const originalDisplayFrame = window.displayFrame;
            window.displayFrame = window.loadCompletedFrame;

            // ì²« í”„ë ˆì„ ë¡œë“œ
            await window.loadCompletedFrame(0);

            // ì¬ìƒ ë²„íŠ¼ í™œì„±í™”
            document.getElementById('playPauseBtn').disabled = false;

            alert('ì¶”ë¡  ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!\n\nì¬ìƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
        }

        // ì¶”ë¡  ì·¨ì†Œ
        async function cancelInference() {
            if (!currentJobId) {
                alert('ì§„í–‰ ì¤‘ì¸ ì¶”ë¡ ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (!confirm('ì •ë§ë¡œ ì¶”ë¡ ì„ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                document.getElementById('cancelInferenceBtn').disabled = true;
                const response = await fetch(`${API_BASE_URL}/api/inference/cancel/${currentJobId}`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[INFERENCE] Cancel requested');
                    document.getElementById('inferenceProgress').textContent = 'ì·¨ì†Œ ì¤‘...';
                } else {
                    alert('ì·¨ì†Œ ì‹¤íŒ¨: ' + data.error);
                    document.getElementById('cancelInferenceBtn').disabled = false;
                }
            } catch (error) {
                console.error('Cancel error:', error);
                alert('ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                document.getElementById('cancelInferenceBtn').disabled = false;
            }
        }

        // ============================================
        // ê´€ë¦¬ì ê¸°ëŠ¥
        // ============================================

        // ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ
        async function loadUsers() {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                const response = await authFetch('/api/auth/users');
                const data = await response.json();

                if (data.success && data.users) {
                    usersList.innerHTML = data.users.map(u => `
                        <div style="padding: 15px; margin-bottom: 10px; background: #2d2d2d; border-radius: 4px; border-left: 4px solid ${u.role === 'admin' ? '#ff6b6b' : '#4a9eff'};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="font-size: 16px; color: #4a9eff;">${u.user_id}</strong>
                                    <span style="margin-left: 10px; padding: 2px 8px; background: ${u.role === 'admin' ? '#ff6b6b' : '#4a9eff'}; color: white; border-radius: 3px; font-size: 11px;">${u.role}</span>
                                    <br>
                                    <small style="color: #999;">${u.full_name || 'No name'}</small>
                                    <br>
                                    <small style="color: #666;">ìƒì„±ì¼: ${new Date(u.created_at).toLocaleString('ko-KR')}</small>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button onclick="editUser('${u.user_id}', '${u.full_name || ''}', '${u.role}')" style="padding: 8px 15px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;" onmouseover="this.style.background='#3a8eef'" onmouseout="this.style.background='#4a9eff'">
                                        âœï¸ ìˆ˜ì •
                                    </button>
                                    <button onclick="deleteUser('${u.user_id}')" style="padding: 8px 15px; background: #ff6b6b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;" onmouseover="this.style.background='#ff4d4d'" onmouseout="this.style.background='#ff6b6b'">
                                        ğŸ—‘ ì‚­ì œ
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    usersList.innerHTML = '<p style="color: #999;">ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }
            } catch (error) {
                console.error('[ADMIN] Load users error:', error);
                usersList.innerHTML = '<p style="color: red;">ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ìƒˆ ì‚¬ìš©ì ìƒì„±
        async function createNewUser() {
            const userId = document.getElementById('newUserId').value.trim();
            const password = document.getElementById('newUserPassword').value;
            const fullName = document.getElementById('newUserFullName').value.trim();
            const role = document.getElementById('newUserRole').value;

            if (!userId || !password) {
                alert('ì‚¬ìš©ì IDì™€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await authFetch('/api/auth/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        password: password,
                        full_name: fullName,
                        role: role
                    })
                });

                const data = await response.json();

                if (data.success) {
                    alert('âœ… ì‚¬ìš©ìê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nUser ID: ' + userId);

                    // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                    document.getElementById('newUserId').value = '';
                    document.getElementById('newUserPassword').value = '';
                    document.getElementById('newUserFullName').value = '';
                    document.getElementById('newUserRole').value = 'user';

                    // ì‚¬ìš©ì ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    loadUsers();
                } else {
                    alert('âŒ ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Create user error:', error);
                alert('âŒ ì‚¬ìš©ì ìƒì„± ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ì‚¬ìš©ì ì‚­ì œ
        async function deleteUser(userId) {
            // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì í™•ì¸
            const currentUser = getCurrentUser();
            if (currentUser && currentUser.user_id === userId) {
                alert('âŒ í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìëŠ” ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // í™•ì¸ ëŒ€í™”ìƒì
            if (!confirm(`âš ï¸ ì •ë§ë¡œ ì‚¬ìš©ìë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nUser ID: ${userId}\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)) {
                return;
            }

            try {
                const response = await authFetch(`/api/auth/users/${userId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    alert('âœ… ì‚¬ìš©ìê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
                    loadUsers(); // ì‚¬ìš©ì ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    alert('âŒ ì‚¬ìš©ì ì‚­ì œ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Delete user error:', error);
                alert('âŒ ì‚¬ìš©ì ì‚­ì œ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ì‚¬ìš©ì ìˆ˜ì • ëª¨ë‹¬ ì—´ê¸°
        function editUser(userId, fullName, role) {
            // ì›ë˜ user_id ì €ì¥ (API endpointì— ì‚¬ìš©)
            document.getElementById('editUserOriginalId').value = userId;
            // í˜„ì¬ user_id (í¸ì§‘ ê°€ëŠ¥)
            document.getElementById('editUserId').value = userId;
            document.getElementById('editUserFullName').value = fullName;
            document.getElementById('editUserRole').value = role;
            document.getElementById('editUserPassword').value = '';  // ë¹„ë°€ë²ˆí˜¸ í•„ë“œ ì´ˆê¸°í™”

            // ëª¨ë‹¬ í‘œì‹œ
            const modal = document.getElementById('editUserModal');
            modal.style.display = 'flex';
        }

        // ì‚¬ìš©ì ìˆ˜ì • ëª¨ë‹¬ ë‹«ê¸°
        function closeEditUserModal() {
            const modal = document.getElementById('editUserModal');
            modal.style.display = 'none';
        }

        // ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
        async function updateUser() {
            const originalUserId = document.getElementById('editUserOriginalId').value;
            const newUserId = document.getElementById('editUserId').value.trim();
            const fullName = document.getElementById('editUserFullName').value.trim();
            const role = document.getElementById('editUserRole').value;
            const password = document.getElementById('editUserPassword').value;

            // user_id ê²€ì¦
            if (!newUserId) {
                alert('âŒ ì‚¬ìš©ì IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.');
                return;
            }

            try {
                const updateData = {
                    full_name: fullName,
                    role: role
                };

                // user_idê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ new_user_id ì¶”ê°€
                if (newUserId !== originalUserId) {
                    updateData.new_user_id = newUserId;
                }

                // ë¹„ë°€ë²ˆí˜¸ê°€ ì…ë ¥ë˜ì—ˆìœ¼ë©´ ì¶”ê°€
                if (password) {
                    updateData.password = password;
                }

                // ì›ë˜ user_idë¡œ API í˜¸ì¶œ (endpoint URLì— ì‚¬ìš©)
                const response = await authFetch(`/api/auth/users/${originalUserId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });

                const data = await response.json();

                if (data.success) {
                    const finalUserId = data.user_id || newUserId;
                    let message = 'âœ… ì‚¬ìš©ì ì •ë³´ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nUser ID: ' + finalUserId;

                    // user_idê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ì•Œë¦¼ ì¶”ê°€
                    if (newUserId !== originalUserId) {
                        message += '\n\nâš ï¸ ì‚¬ìš©ì IDê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n';
                        message += 'ì´ì „: ' + originalUserId + '\n';
                        message += 'ìƒˆë¡œìš´: ' + finalUserId;
                    }

                    alert(message);
                    closeEditUserModal();
                    loadUsers(); // ì‚¬ìš©ì ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    alert('âŒ ì‚¬ìš©ì ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Update user error:', error);
                alert('âŒ ì‚¬ìš©ì ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ì‹œìŠ¤í…œ í†µê³„ ë¡œë“œ
        async function loadSystemStats() {
            const statsDiv = document.getElementById('systemStats');

            try {
                // GPU ì„œë²„ stats ê°€ì ¸ì˜¤ê¸°
                const response = await fetch(API_BASE_URL + '/api/stats');
                const data = await response.json();

                if (data.success) {
                    statsDiv.innerHTML = `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <h4 style="margin-top: 0;">ì¶”ë¡  í†µê³„</h4>
                                <p>ì´ ìš”ì²­: <strong>${data.inference.total_requests}</strong></p>
                                <p>í™œì„± ìš”ì²­: <strong>${data.inference.active_requests}</strong></p>
                                <p>ìµœëŒ€ ë™ì‹œ ìš”ì²­: <strong>${data.inference.max_concurrent}</strong></p>
                            </div>
                            <div>
                                <h4 style="margin-top: 0;">ì„œë²„ ìƒíƒœ</h4>
                                <p>CPU ì‚¬ìš©ëŸ‰: <strong>${data.server.cpu_percent.toFixed(1)}%</strong></p>
                                <p>ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: <strong>${data.server.memory_percent.toFixed(1)}%</strong></p>
                                <p>í™œì„± ìŠ¤ë ˆë“œ: <strong>${data.server.threads}</strong></p>
                            </div>
                            <div>
                                <h4 style="margin-top: 0;">AI ëª¨ë¸</h4>
                                <p>ì´ˆê¸°í™”: <strong>${data.ai_model.initialized ? 'âœ… Yes' : 'âŒ No'}</strong></p>
                                <p>ë””ë°”ì´ìŠ¤: <strong>${data.ai_model.device || 'N/A'}</strong></p>
                            </div>
                        </div>
                    `;
                } else {
                    statsDiv.innerHTML = '<p style="color: #999;">í†µê³„ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                }
            } catch (error) {
                console.error('[ADMIN] Load stats error:', error);
                statsDiv.innerHTML = '<p style="color: red;">í†µê³„ ë¡œë“œ ì‹¤íŒ¨</p>';
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë°±ì—”ë“œ í™•ì¸ ë° í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
        console.log('[SCRIPT END] Setting up load event listener...');
        window.addEventListener('load', async () => {
            console.log('[LOAD EVENT] Page loaded, validating session...');

            // ì„¸ì…˜ ê²€ì¦ ë¨¼ì € ìˆ˜í–‰
            const isValid = await validateSession();

            if (isValid) {
                // ì„¸ì…˜ì´ ìœ íš¨í•œ ê²½ìš°ì—ë§Œ ë°ì´í„° ë¡œë“œ
                // AI ìƒíƒœ ìë™ í™•ì¸
                setTimeout(() => {
                    checkAIStatus();
                }, 500);

                // ê´€ë¦¬ìì¸ ê²½ìš° ëŒ€ì‹œë³´ë“œ í‘œì‹œ
                const user = getCurrentUser();
                if (user && user.user_id === 'admin') {
                    const adminSection = document.getElementById('adminDashboardSection');
                    if (adminSection) {
                        adminSection.style.display = 'block';
                    }
                }
            }
        });

        // ========== ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ í•¨ìˆ˜ ==========
        let allAdminProjects = [];

        async function loadAdminDashboard() {
            try {
                const response = await authFetch('/api/admin/dashboard');
                const data = await response.json();

                if (data.success) {
                    allAdminProjects = data.projects || [];
                    const summary = data.summary || {};

                    // ìš”ì•½ ì¹´ë“œ ì—…ë°ì´íŠ¸
                    const summaryCards = document.getElementById('adminSummaryCards');
                    summaryCards.innerHTML = `
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #4a9eff;">${summary.total_projects || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì´ í”„ë¡œì íŠ¸</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #28a745;">${summary.total_videos || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì´ ë¹„ë””ì˜¤</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #ffa500;">${summary.completed_videos || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì™„ë£Œëœ ë¹„ë””ì˜¤</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #ff6b6b;">${summary.total_annotations || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #9b59b6;">${summary.annotated_frames || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì–´ë…¸í…Œì´ì…˜ í”„ë ˆì„</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #3498db;">${summary.unique_contributors || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ê¸°ì—¬ì ìˆ˜</div>
                        </div>
                    `;

                    // í”„ë¡œì íŠ¸ ëª©ë¡ ë Œë”ë§
                    renderAdminProjects();
                } else {
                    alert('ëŒ€ì‹œë³´ë“œ ë¡œë“œ ì‹¤íŒ¨: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('[ADMIN DASHBOARD] Error loading:', error);
                alert('ëŒ€ì‹œë³´ë“œ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        function renderAdminProjects(filterText = '') {
            const projectsList = document.getElementById('adminProjectsList');

            let filtered = allAdminProjects;
            if (filterText) {
                const lower = filterText.toLowerCase();
                filtered = allAdminProjects.filter(p =>
                    p.project_name.toLowerCase().includes(lower) ||
                    p.user_name.toLowerCase().includes(lower) ||
                    p.user_id.toLowerCase().includes(lower)
                );
            }

            if (filtered.length === 0) {
                projectsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            let html = `
                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead style="position: sticky; top: 0; background: #2d2d2d; z-index: 1;">
                        <tr>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: left;">ì‚¬ìš©ì</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: left;">í”„ë¡œì íŠ¸</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: center;">ë¹„ë””ì˜¤</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: center;">ì™„ë£Œ</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: center;">ì–´ë…¸í…Œì´ì…˜</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: center;">í”„ë ˆì„</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: left;">í´ë˜ìŠ¤ ë¶„í¬</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: left;">ê¸°ì—¬ì</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            filtered.forEach(project => {
                const completionRate = project.total_videos > 0
                    ? Math.round(project.completed_videos / project.total_videos * 100)
                    : 0;

                // í´ë˜ìŠ¤ ë¶„í¬ ë¬¸ìì—´
                const classDistribution = Object.entries(project.class_distribution)
                    .map(([label, count]) => `${label}: ${count}`)
                    .join(', ') || '-';

                // ê¸°ì—¬ì ë¬¸ìì—´
                const contributors = project.contributors.join(', ') || '-';

                html += `
                    <tr style="border-bottom: 1px solid #404040;">
                        <td style="padding: 8px; border: 1px solid #404040;">
                            <div style="font-weight: bold;">${project.user_name}</div>
                            <div style="font-size: 10px; color: #999;">${project.user_id}</div>
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040;">
                            <div style="font-weight: bold;">${project.project_name}</div>
                            <div style="font-size: 10px; color: #999;">${project.project_id}</div>
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">${project.total_videos}</td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">
                            <div>${project.completed_videos}</div>
                            <div style="font-size: 10px; color: ${completionRate === 100 ? '#28a745' : '#ffa500'};">${completionRate}%</div>
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center; font-weight: bold; color: #ff6b6b;">${project.total_annotations}</td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">${project.annotated_frames}</td>
                        <td style="padding: 8px; border: 1px solid #404040; font-size: 10px; max-width: 200px; overflow: hidden; text-overflow: ellipsis;" title="${classDistribution}">${classDistribution}</td>
                        <td style="padding: 8px; border: 1px solid #404040; font-size: 10px;">${contributors}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            projectsList.innerHTML = html;
        }

        function filterAdminProjects() {
            const filterInput = document.getElementById('adminProjectFilter');
            const filterText = filterInput ? filterInput.value : '';
            renderAdminProjects(filterText);
        }

    </script>
</body>
</html>
