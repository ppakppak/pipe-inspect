<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Water ì–´ë…¸í…Œì´ì…˜ ì‹œìŠ¤í…œ</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #e0e0e0;
        }

        /* í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ ì‹­ìì„  ì»¤ì„œ */
        .crosshair-cursor {
            cursor: crosshair !important;
        }

        .crosshair-cursor.hide-cursor {
            cursor: none !important;
        }

        #crosshair-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        #crosshair-lines.active {
            display: block;
        }

        .crosshair-h, .crosshair-v {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        .crosshair-h {
            height: 1px;
            width: 100%;
            left: 0;
        }

        .crosshair-v {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .crosshair-center {
            display: none;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.5);
        }
        h1 {
            color: #ffffff;
            margin-bottom: 30px;
            font-size: 28px;
        }
        h2 {
            color: #ffffff;
            margin-bottom: 20px;
            margin-top: 0;
        }
        h3 {
            color: #e0e0e0;
            margin-bottom: 15px;
            margin-top: 20px;
            font-size: 16px;
        }
        h4 {
            color: #cccccc;
            margin-bottom: 10px;
            margin-top: 15px;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #404040;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 14px;
            color: #999;
            transition: all 0.3s;
        }
        .tab:hover {
            color: #fff;
            background: #3a3a3a;
        }
        .tab.active {
            color: #4a9eff;
            border-bottom: 2px solid #4a9eff;
            margin-bottom: -2px;
        }
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        .tab-content.active {
            display: block;
        }
        .status {
            padding: 15px;
            background: #1a3a4a;
            border-radius: 4px;
            margin-top: 20px;
            border-left: 4px solid #4a9eff;
        }
        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover {
            background: #3080df;
        }
        button:active {
            transform: scale(0.98);
        }

        /* ë¡œê·¸ì¸ í™”ë©´ ìŠ¤íƒ€ì¼ */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .login-box {
            background: #2d2d2d;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.8);
            width: 100%;
            max-width: 400px;
        }

        .login-box h2 {
            margin-top: 0;
            margin-bottom: 30px;
            text-align: center;
            color: #4a9eff;
        }

        .login-form-group {
            margin-bottom: 20px;
        }

        .login-form-group label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .login-form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #404040;
            background: #1e1e1e;
            color: #e0e0e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .login-form-group input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .login-error {
            background: #4a1a1a;
            color: #ff6b6b;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #ff6b6b;
            display: none;
        }

        .login-button {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-weight: 600;
        }

        /* ì‚¬ìš©ì ì •ë³´ í‘œì‹œ */
        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #404040;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info span {
            color: #e0e0e0;
            font-size: 14px;
        }

        .user-info .user-name {
            color: #4a9eff;
            font-weight: 600;
        }

        .logout-button {
            padding: 6px 12px;
            font-size: 12px;
            background: #dc3545;
        }

        .logout-button:hover {
            background: #c82333;
        }
        input[type="text"] {
            background: #1e1e1e;
            border: 1px solid #404040;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        input[type="number"],
        select {
            background: #1e1e1e;
            border: 1px solid #404040;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        label {
            color: #cccccc;
            font-size: 14px;
        }
        input[type="range"] {
            -webkit-appearance: none;
            background: #404040;
            height: 4px;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }
        #projectList {
            border: 1px solid #404040;
            padding: 15px;
            border-radius: 4px;
            min-height: 100px;
            background: #1e1e1e;
        }
        #projectList > div {
            padding: 10px;
            margin: 5px 0;
            background: #2d2d2d;
            border-radius: 4px;
            border-left: 4px solid #4a9eff;
        }
        #projectList > div:hover {
            background: #3a3a3a;
            cursor: pointer;
        }
        code {
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4a9eff;
        }
        small {
            color: #999;
        }

        /* í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ */
        .project-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .project-settings-modal.show {
            display: flex;
        }

        .project-settings-content {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.8);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .project-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #404040;
        }

        .project-settings-header h2 {
            margin: 0;
            color: #4a9eff;
        }

        .close-modal {
            background: #dc3545;
            padding: 8px 15px;
            font-size: 14px;
        }

        .class-list {
            border: 1px solid #404040;
            border-radius: 4px;
            background: #1e1e1e;
            padding: 10px;
            margin-bottom: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .class-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #2d2d2d;
            border-radius: 4px;
            border-left: 4px solid #4a9eff;
        }

        .class-item span {
            color: #e0e0e0;
            font-size: 14px;
        }

        .class-item button {
            background: #dc3545;
            padding: 5px 10px;
            font-size: 12px;
        }

        .add-class-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .add-class-input input {
            flex: 1;
        }

        /* NAS ë¹„ë””ì˜¤ ì„ íƒ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .nas-video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .nas-video-card {
            background: #1e1e1e;
            border: 2px solid #404040;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nas-video-card:hover {
            border-color: #4a9eff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.2);
        }

        .nas-video-card.selected {
            border-color: #4a9eff;
            background: #2a3a4a;
        }

        .nas-video-thumbnail {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
            background: #0a0a0a;
        }

        .nas-video-thumbnail-wrapper {
            position: relative;
            width: 100%;
        }

        .nas-video-completed-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: rgba(40, 167, 69, 0.85);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 18px;
            pointer-events: none;
        }

        .nas-video-completed-overlay .checkmark {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .nas-video-info {
            margin-top: 8px;
            font-size: 12px;
        }

        .nas-video-name {
            color: #e0e0e0;
            font-weight: 600;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .nas-video-meta {
            color: #888;
            font-size: 11px;
            line-height: 1.4;
        }

        .nas-filter-section {
            margin-bottom: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 4px;
        }

        .nas-filter-section select {
            padding: 6px;
            margin-right: 10px;
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #404040;
            border-radius: 4px;
        }

        .nas-loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .nas-selection-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    </style>
</head>
<body>
    <!-- ë¡œê·¸ì¸ í™”ë©´ -->
    <div id="loginOverlay" class="login-overlay">
        <div class="login-box">
            <h2>ğŸ” ë¡œê·¸ì¸</h2>
            <div id="loginError" class="login-error"></div>
            <form id="loginForm" onsubmit="handleLogin(event)">
                <div class="login-form-group">
                    <label for="loginUserId">ì‚¬ìš©ì ID</label>
                    <input type="text" id="loginUserId" required autocomplete="username">
                </div>
                <div class="login-form-group">
                    <label for="loginPassword">ë¹„ë°€ë²ˆí˜¸</label>
                    <input type="password" id="loginPassword" required autocomplete="current-password">
                </div>
                <button type="submit" class="login-button">ë¡œê·¸ì¸</button>
            </form>
            <div style="margin-top: 20px; text-align: center; color: #999; font-size: 12px;">
                <p>ê¸°ë³¸ ê³„ì •: admin / admin123</p>
            </div>
        </div>
    </div>

    <!-- ì‚¬ìš©ì ì •ë³´ -->
    <div id="userInfo" class="user-info" style="display: none;">
        <button onclick="toggleLanguage()" style="padding: 6px 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; margin-right: 10px;">
            <span id="langToggleBtn2">ğŸŒ EN</span>
        </button>
        <span>ğŸ‘¤ <span class="user-name" id="userName">ì‚¬ìš©ì</span></span>
        <button class="logout-button" onclick="handleLogout()">ë¡œê·¸ì•„ì›ƒ</button>
    </div>

    <!-- í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ -->
    <div id="projectSettingsModal" class="project-settings-modal">
        <div class="project-settings-content">
            <div class="project-settings-header">
                <h2>âš™ï¸ í”„ë¡œì íŠ¸ ì„¤ì •</h2>
                <button class="close-modal" onclick="closeProjectSettings()">âœ– ë‹«ê¸°</button>
            </div>

            <div>
                <h3>í”„ë¡œì íŠ¸ ì •ë³´</h3>
                <div style="margin-bottom: 20px;">
                    <div style="color: #888; font-size: 12px; margin-bottom: 5px;">í”„ë¡œì íŠ¸ ì´ë¦„:</div>
                    <input type="text" id="settingsProjectName" placeholder="í”„ë¡œì íŠ¸ ì´ë¦„ ì…ë ¥" style="width: 100%; padding: 10px; font-size: 16px; font-weight: 600; background: #2d2d2d; color: #4a9eff; border: 2px solid #404040; border-radius: 4px;" />
                </div>
                <div style="margin-bottom: 20px;">
                    <div style="color: #888; font-size: 12px; margin-bottom: 5px;">í”„ë¡œì íŠ¸ ID:</div>
                    <div id="settingsProjectId" style="color: #999; font-size: 14px;">-</div>
                </div>
            </div>

            <div>
                <h3>í´ë˜ìŠ¤ ê´€ë¦¬</h3>
                <div id="settingsClassList" class="class-list">
                    <p style="color: #888; font-size: 12px;">í´ë˜ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
                </div>

                <div class="add-class-input" style="display: flex; flex-direction: column; gap: 8px;">
                    <input type="text" id="newClassName" placeholder="í´ë˜ìŠ¤ ì´ë¦„ (ì˜ˆ: rust, scale)" style="width: 100%;">
                    <textarea id="newClassDescription" placeholder="í´ë˜ìŠ¤ ì„¤ëª… (ì„ íƒì‚¬í•­)" style="width: 100%; padding: 8px; resize: vertical; min-height: 60px; font-family: inherit; background: #2d2d2d; color: #ddd; border: 1px solid #404040; border-radius: 4px;" onkeypress="if(event.key==='Enter' && event.ctrlKey) addClass()"></textarea>
                    <button onclick="addClass()" style="width: 100%;">â• í´ë˜ìŠ¤ ì¶”ê°€</button>
                </div>
            </div>

            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #404040;">
                <button onclick="saveProjectSettings()" style="width: 100%; padding: 12px; font-size: 16px;">ğŸ’¾ ë³€ê²½ì‚¬í•­ ì €ì¥</button>
            </div>
        </div>
    </div>

    <!-- ì–´ë…¸í…Œì´ì…˜ ë„ì›€ë§ ëª¨ë‹¬ -->
    <div id="annotationHelpModal" class="project-settings-modal">
        <div class="project-settings-content" style="max-width: 800px;">
            <div class="project-settings-header">
                <h2>â“ <span data-i18n="annotation.help">ì–´ë…¸í…Œì´ì…˜ ë„ì›€ë§</span></h2>
                <button class="close-modal" onclick="closeAnnotationHelp()">âœ– <span data-i18n="common.close">ë‹«ê¸°</span></button>
            </div>

            <div style="overflow-y: auto; max-height: calc(80vh - 100px); padding: 10px;">
                <!-- ê¸°ë³¸ ì‚¬ìš©ë²• -->
                <div style="margin-bottom: 30px;">
                    <h3>ğŸ¯ <span data-i18n="help.basicUsage">ê¸°ë³¸ ì‚¬ìš©ë²•</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px; border-left: 4px solid #4a9eff;">
                        <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
                            <li data-i18n="help.step1">í”„ë¡œì íŠ¸ íƒ­ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ì„ íƒí•˜ì„¸ìš”.</li>
                            <li data-i18n="help.step2">ë¹„ë””ì˜¤ë¥¼ ì¶”ê°€í•˜ê³  ì–´ë…¸í…Œì´ì…˜ íƒ­ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”.</li>
                            <li data-i18n="help.step3">ì™¼ìª½ íŒ¨ë„ì—ì„œ ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”.</li>
                            <li data-i18n="help.step4">AI ì¶”ë¡  ê²°ê³¼ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ìˆ˜ë™ìœ¼ë¡œ í´ë¦¬ê³¤ì„ ê·¸ë¦¬ì„¸ìš”.</li>
                            <li data-i18n="help.step5">ì™„ë£Œí•œ í”„ë ˆì„ì€ "ğŸ’¾ í”„ë ˆì„ ì €ì¥" ë²„íŠ¼ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”.</li>
                        </ol>
                    </div>
                </div>

                <!-- ë‹¨ì¶•í‚¤ -->
                <div style="margin-bottom: 30px;">
                    <h3>âŒ¨ï¸ <span data-i18n="help.shortcuts">ë‹¨ì¶•í‚¤</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px; color: #4a9eff; font-weight: bold;" data-i18n="help.key">í‚¤</td>
                                <td style="padding: 8px; color: #4a9eff; font-weight: bold;" data-i18n="help.action">ë™ì‘</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Space</code></td>
                                <td style="padding: 8px;" data-i18n="help.playPause">ì¬ìƒ / ì¼ì‹œì •ì§€</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">â†</code></td>
                                <td style="padding: 8px;" data-i18n="help.prevFrame">ì´ì „ í”„ë ˆì„</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">â†’</code></td>
                                <td style="padding: 8px;" data-i18n="help.nextFrame">ë‹¤ìŒ í”„ë ˆì„</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Ctrl + S</code></td>
                                <td style="padding: 8px;" data-i18n="help.saveFrame">í˜„ì¬ í”„ë ˆì„ ì €ì¥</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #404040;">
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Delete</code></td>
                                <td style="padding: 8px;" data-i18n="help.deleteAnnotation">ì„ íƒí•œ ì–´ë…¸í…Œì´ì…˜ ì‚­ì œ</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Esc</code></td>
                                <td style="padding: 8px;" data-i18n="help.cancelDrawing">í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ì·¨ì†Œ</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <!-- ê·¸ë¦¬ê¸° ëª¨ë“œ -->
                <div style="margin-bottom: 30px;">
                    <h3>ğŸ–Šï¸ <span data-i18n="help.drawingModes">ê·¸ë¦¬ê¸° ëª¨ë“œ</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                        <div style="margin-bottom: 15px;">
                            <h4 style="color: #4a9eff; margin: 0 0 8px 0;" data-i18n="help.aiMode">ğŸ¤– AI ìë™ ì¶”ë¡ </h4>
                            <p style="margin: 0; color: #ccc;" data-i18n="help.aiModeDesc">í”„ë ˆì„ ì´ë™ ì‹œ ìë™ìœ¼ë¡œ AIê°€ ì˜ì—­ì„ ê°ì§€í•˜ì—¬ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <h4 style="color: #4a9eff; margin: 0 0 8px 0;" data-i18n="help.manualMode">âœï¸ ìˆ˜ë™ í´ë¦¬ê³¤</h4>
                            <p style="margin: 0; color: #ccc;" data-i18n="help.manualModeDesc">í´ë¦­í•˜ì—¬ ì ì„ ì°ê³  í´ë¦¬ê³¤ì„ ê·¸ë¦½ë‹ˆë‹¤. ë”ë¸”í´ë¦­ ë˜ëŠ” ì²« ì  í´ë¦­ìœ¼ë¡œ ì™„ë£Œí•©ë‹ˆë‹¤.</p>
                        </div>
                        <div>
                            <h4 style="color: #4a9eff; margin: 0 0 8px 0;" data-i18n="help.crosshairMode">â• ì‹­ìì„ </h4>
                            <p style="margin: 0; color: #ccc;" data-i18n="help.crosshairModeDesc">ì •í™•í•œ ìœ„ì¹˜ íŒŒì•…ì„ ìœ„í•œ ì‹­ìì„  ê°€ì´ë“œë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                        </div>
                    </div>
                </div>

                <!-- íŒ -->
                <div>
                    <h3>ğŸ’¡ <span data-i18n="help.tips">ìœ ìš©í•œ íŒ</span></h3>
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                            <li data-i18n="help.tip1">AI ì¶”ë¡  ê²°ê³¼ê°€ ë¶€ì •í™•í•˜ë©´ ìˆ˜ë™ìœ¼ë¡œ ìˆ˜ì •í•˜ê±°ë‚˜ ë‹¤ì‹œ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                            <li data-i18n="help.tip2">í”„ë ˆì„ì„ ì €ì¥í•˜ì§€ ì•Šìœ¼ë©´ ì‘ì—… ë‚´ìš©ì´ ì†ì‹¤ë©ë‹ˆë‹¤.</li>
                            <li data-i18n="help.tip3">ì—¬ëŸ¬ ê°œì˜ ë¹„ë””ì˜¤ íŒŒì¼ì„ í•œ ë²ˆì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (Ctrl/Cmd í´ë¦­).</li>
                            <li data-i18n="help.tip4">í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ í´ë˜ìŠ¤(ë¼ë²¨)ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                            <li data-i18n="help.tip5">í†µê³„ íŒ¨ë„ì—ì„œ ì „ì²´ ì‘ì—… ì§„í–‰ë¥ ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- í´ë˜ìŠ¤ ì„ íƒ íŒì—… (í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° í›„ - ë“œë¡­ë‹¤ìš´ í˜•ì‹) -->
    <div id="classSelectionPopup" style="
        display: none;
        position: fixed;
        z-index: 10000;
        background: #2d2d2d;
        border: 2px solid #4a9eff;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        padding: 10px;
        min-width: 200px;
        max-width: 800px;
    ">
        <div id="classSelectionButtons" style="display: grid; gap: 8px;">
            <!-- í´ë˜ìŠ¤ ë²„íŠ¼ë“¤ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë¨ -->
        </div>
    </div>

    <!-- NAS ë¹„ë””ì˜¤ ì„ íƒ ëª¨ë‹¬ -->
    <div id="nasVideoSelectionModal" class="project-settings-modal">
        <div class="project-settings-content" style="max-width: 1200px;">
            <div class="project-settings-header">
                <h2>ğŸ“ NAS ë¹„ë””ì˜¤ ì„ íƒ</h2>
                <button class="close-modal" onclick="closeNasVideoSelection()">âœ– ë‹«ê¸°</button>
            </div>

            <!-- í•„í„° ì„¹ì…˜ -->
            <div class="nas-filter-section">
                <label style="color: #e0e0e0; margin-right: 10px;">ì¥ë¹„:</label>
                <select id="nasFolderFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ì‹œì„¤:</label>
                <select id="nasRegionFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                    <option value="ì§€ë°©">ì§€ë°©</option>
                    <option value="ê´‘ì—­">ê´‘ì—­</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ê´€ê²½:</label>
                <select id="nasPipeSizeFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                    <option value="300MM">300MM</option>
                    <option value="500MM">500MM</option>
                    <option value="800MM">800MM</option>
                    <option value="1000MM">1000MM</option>
                    <option value="1200MM">1200MM</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ê´€ì¢…:</label>
                <select id="nasMethodFilter" onchange="filterNasVideos()">
                    <option value="">ì „ì²´</option>
                    <option value="SP">SP</option>
                    <option value="DCIP">DCIP</option>
                    <option value="HI3P">HI3P</option>
                </select>

                <label style="color: #e0e0e0; margin: 0 10px;">ì •ë ¬:</label>
                <select id="nasSortOrder" onchange="filterNasVideos()">
                    <option value="name">ì´ë¦„</option>
                    <option value="size">í¬ê¸°</option>
                    <option value="duration">ì¬ìƒì‹œê°„</option>
                </select>
                <span id="nasVideoCount" style="color: #888; margin-left: 15px;">0ê°œì˜ ë¹„ë””ì˜¤</span>
            </div>

            <!-- ë¡œë”© í‘œì‹œ -->
            <div id="nasLoading" class="nas-loading" style="display: none;">
                <div style="font-size: 32px; margin-bottom: 10px;">â³</div>
                <div>NAS ë¹„ë””ì˜¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
            </div>

            <!-- ë¹„ë””ì˜¤ ê·¸ë¦¬ë“œ -->
            <div id="nasVideoGrid" class="nas-video-grid"></div>

            <!-- ì„ íƒ ì •ë³´ ë° ë²„íŠ¼ -->
            <div class="nas-selection-footer">
                <div>
                    <span id="nasSelectedCount" style="color: #4a9eff; font-weight: 600;">0ê°œ ì„ íƒë¨</span>
                    <button onclick="selectAllFilteredNasVideos()" style="background: #17a2b8; margin-left: 15px; padding: 5px 12px; font-size: 13px;">â˜‘ ì „ì²´ ì„ íƒ</button>
                    <button onclick="deselectAllNasVideos()" style="background: #6c757d; margin-left: 5px; padding: 5px 12px; font-size: 13px;">â˜ ì„ íƒ í•´ì œ</button>
                </div>
                <div>
                    <button onclick="closeNasVideoSelection()" style="background: #6c757d; margin-right: 10px;">ì·¨ì†Œ</button>
                    <button onclick="addSelectedNasVideos()" style="background: #28a745;">âœ“ ì„ íƒí•œ ë¹„ë””ì˜¤ ì¶”ê°€</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <h1 style="margin-bottom: 20px;" data-i18n="app.title">ğŸ’§ K-Water ì–´ë…¸í…Œì´ì…˜ ì‹œìŠ¤í…œ</h1>

        <div class="tabs">
            <button class="tab active" onclick="showTab('project')" data-i18n="tab.project">ğŸ“‚ Project</button>
            <button class="tab" onclick="showTab('annotation')" data-i18n="tab.annotation">ğŸ“¹ Annotation</button>
            <button class="tab" onclick="showTab('dataset')" data-i18n="tab.dataset">ğŸ“¦ Dataset</button>
            <button class="tab" onclick="showTab('training')" data-i18n="tab.training">ğŸš€ Training</button>
            <button class="tab" onclick="showTab('inference')" data-i18n="tab.inference">ğŸ¬ Inference</button>
            <button id="adminTab" class="tab" onclick="showTab('admin')" style="display: none;" data-i18n="tab.admin">ğŸ‘¥ Admin</button>
        </div>

        <div id="project-tab" class="tab-content active">
            <h2 data-i18n="project.title">í”„ë¡œì íŠ¸ ê´€ë¦¬</h2>

            <!-- Projects List Section (3-column layout) -->
            <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040; margin-bottom: 30px;">
                <h3 style="margin-top: 0; margin-bottom: 15px; color: #4a9eff;">
                    <span data-i18n="project.list">í”„ë¡œì íŠ¸ ëª©ë¡</span>
                    <button onclick="loadProjects()" style="font-size: 12px; padding: 5px 10px; margin-left: 10px;" data-i18n="common.refresh">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                </h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <!-- ìƒˆ í”„ë¡œì íŠ¸ ìƒì„± (ì™¼ìª½) -->
                    <div>
                        <h4 data-i18n="project.createNew" style="margin-bottom: 10px; color: #4a9eff;">â• ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±</h4>
                        <div style="background: #1e1e1e; border: 1px solid #404040; padding: 15px; border-radius: 4px;">
                            <div style="margin-bottom: 12px;">
                                <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 12px;">í”„ë¡œì íŠ¸ ì´ë¦„ (í•„ìˆ˜)</label>
                                <input type="text" id="projectName" data-i18n-placeholder="project.namePlaceholder" placeholder="í”„ë¡œì íŠ¸ ì´ë¦„ (í•„ìˆ˜)"
                                       style="padding: 8px; width: 100%; box-sizing: border-box; background: #2a2a2a; border: 1px solid #555; color: white; border-radius: 4px; font-size: 13px;">
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 12px;">ì‘ì—…ì ì´ë¦„ (ì„ íƒ)</label>
                                <input type="text" id="projectWorker" data-i18n-placeholder="project.workerPlaceholder" placeholder="ì‘ì—…ì ì´ë¦„ (ì„ íƒ)"
                                       style="padding: 8px; width: 100%; box-sizing: border-box; background: #2a2a2a; border: 1px solid #555; color: white; border-radius: 4px; font-size: 13px;">
                            </div>
                            <button onclick="createProject(); return false;" data-i18n="project.create"
                                    style="width: 100%; padding: 10px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px;">
                                â• í”„ë¡œì íŠ¸ ìƒì„±
                            </button>
                        </div>
                    </div>
                    <!-- ë‚´ í”„ë¡œì íŠ¸ (ê°€ìš´ë°) -->
                    <div>
                        <h4 style="margin-bottom: 10px; color: #4a9eff;">ğŸ“ ë‚´ í”„ë¡œì íŠ¸</h4>
                        <div id="myProjectList" style="background: #1e1e1e; border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; max-height: 600px; overflow-y: auto;">
                            <span data-i18n="project.loading">í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                        </div>
                    </div>
                    <!-- ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ (ì˜¤ë¥¸ìª½) -->
                    <div>
                        <h4 style="margin-bottom: 10px; color: #888;">ğŸ‘¥ ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸</h4>
                        <div id="sharedProjectList" style="background: #1a1a1a; border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; max-height: 600px; overflow-y: auto;">
                            <span data-i18n="project.loading">í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Global/Project Annotation Dashboard -->
            <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040; margin-bottom: 30px;">
                <h3 id="annotationDashboardTitle" style="margin-top: 0; margin-bottom: 15px; color: #4a9eff;">
                    ğŸ“Š ì „ì²´ ì–´ë…¸í…Œì´ì…˜ í˜„í™©
                    <button onclick="refreshAnnotationDashboard()" style="font-size: 12px; padding: 5px 10px; margin-left: 10px; background: #555;">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                </h3>
                <div id="globalAnnotationDashboard" style="background: #1e1e1e; padding: 15px; border-radius: 4px;">
                    <span style="color: #888;">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                </div>
            </div>

            <!-- Current Project Section - 2 Column Layout -->
            <div id="currentProjectSection" style="margin-bottom: 30px; display: none;">
                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px;">
                    <!-- Current Project Info Card -->
                    <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040;">
                        <h3 data-i18n="project.current" style="margin-top: 0; margin-bottom: 15px; color: #4a9eff;">í˜„ì¬ í”„ë¡œì íŠ¸</h3>
                        <div style="background: #1e1e1e; padding: 20px; border-radius: 4px; border-left: 4px solid #4a9eff;">
                            <div style="margin-bottom: 15px;">
                                <strong id="currentProjectName" style="font-size: 18px; color: #4a9eff; display: block; margin-bottom: 10px;">í”„ë¡œì íŠ¸ ì´ë¦„</strong>
                                <button onclick="openProjectSettings()" style="width: 100%; margin-bottom: 8px; background: #4a9eff;" data-i18n="common.settings">âš™ï¸ ì„¤ì •</button>
                                <button onclick="closeProject()" style="width: 100%; background: #dc3545;" data-i18n="common.close">âœ– ë‹«ê¸°</button>
                            </div>
                            <div id="currentProjectStats" style="font-size: 14px; color: #999; line-height: 1.8;">
                                í†µê³„ ì •ë³´...
                            </div>
                        </div>
                    </div>

                    <!-- Project Videos Card -->
                    <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040;">
                        <h3 style="margin-top: 0; margin-bottom: 15px; color: #4a9eff;">
                            <span data-i18n="project.videos">í”„ë¡œì íŠ¸ ë¹„ë””ì˜¤</span>
                            <button onclick="showAddVideoDialog()" style="font-size: 12px; padding: 5px 10px; margin-left: 10px;" data-i18n="project.addVideo">â• ë¹„ë””ì˜¤ ì¶”ê°€</button>
                        </h3>

                        <!-- Upload Progress Bar -->
                        <div id="uploadProgress" style="display: none; margin-bottom: 10px; background: #1e1e1e; border: 1px solid #404040; border-radius: 4px; padding: 10px;">
                            <div style="margin-bottom: 5px;">
                                <span id="uploadFileName" style="font-weight: bold; color: #4a9eff;"></span>
                                <span id="uploadPercent" style="float: right; color: #888;">0%</span>
                            </div>
                            <div style="width: 100%; height: 20px; background: #2a2a2a; border-radius: 10px; overflow: hidden;">
                                <div id="uploadProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4a9eff, #2e7bd4); transition: width 0.3s ease;"></div>
                            </div>
                            <div id="uploadStatus" style="margin-top: 5px; font-size: 12px; color: #888;"></div>
                        </div>

                        <div id="videosList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 150px; max-height: 400px; overflow-y: auto; background: #1e1e1e;">
                            <span data-i18n="project.noVideos">ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Comments Dashboard Card -->
            <div style="margin-bottom: 30px;">
                <!-- Comments Dashboard Card -->
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #4a9eff;">ğŸ’¬ ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ</h3>
                        <button onclick="loadCommentsDashboard()" style="font-size: 12px; padding: 6px 12px; background: #555; border: none; border-radius: 4px; cursor: pointer; color: white;">
                            ğŸ”„ ìƒˆë¡œê³ ì¹¨
                        </button>
                    </div>

                    <!-- Filter Controls - Row 1 -->
                    <div style="margin-bottom: 10px; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr auto; gap: 8px;">
                        <select id="commentFilterProject" onchange="filterComments()" style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="">ëª¨ë“  í”„ë¡œì íŠ¸</option>
                        </select>
                        <select id="commentFilterUser" onchange="filterComments()" style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="">ëª¨ë“  ì‚¬ìš©ì</option>
                        </select>
                        <select id="commentFilterLabel" onchange="filterComments()" style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="">ëª¨ë“  ë¼ë²¨</option>
                        </select>
                        <select id="commentFilterStatus" onchange="filterComments()" style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="">ëª¨ë“  ìƒíƒœ</option>
                            <option value="open">ì§„í–‰ì¤‘</option>
                            <option value="resolved">í•´ê²°ë¨</option>
                            <option value="pending">ë³´ë¥˜</option>
                        </select>
                        <select id="commentSortBy" onchange="filterComments()" style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="recent">ìµœì‹ ìˆœ</option>
                            <option value="project">í”„ë¡œì íŠ¸ìˆœ</option>
                            <option value="user">ì‚¬ìš©ììˆœ</option>
                        </select>
                    </div>

                    <!-- Filter Controls - Row 2 -->
                    <div style="margin-bottom: 10px; display: grid; grid-template-columns: auto auto 1fr auto auto; gap: 8px; align-items: center;">
                        <input type="date" id="commentFilterDateFrom" onchange="filterComments()"
                               style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                        <input type="date" id="commentFilterDateTo" onchange="filterComments()"
                               style="padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                        <label style="color: #888; font-size: 13px; display: flex; align-items: center; gap: 6px; padding-left: 10px; cursor: pointer;">
                            <input type="checkbox" id="commentFilterMyOnly" onchange="filterComments()"
                                   style="width: 16px; height: 16px; cursor: pointer;">
                            <span>ë‚´ ì½”ë©˜íŠ¸ë§Œ ë³´ê¸°</span>
                        </label>
                        <button onclick="resetCommentFilters()"
                                style="padding: 8px 16px; background: #555; border: none; border-radius: 4px; cursor: pointer; color: white; font-size: 13px; white-space: nowrap;">
                            ğŸ”„ í•„í„° ì´ˆê¸°í™”
                        </button>
                        <button id="toggleAnnotationsBtn" onclick="toggleAnnotationsDisplay()"
                                style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; color: white; font-size: 13px; white-space: nowrap;">
                            ğŸ‘ï¸ ì–´ë…¸í…Œì´ì…˜ ìˆ¨ê¹€
                        </button>
                    </div>

                    <!-- Filter Results Count and Export -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 5px 10px; background: #252525; border-radius: 4px;">
                        <div id="commentFilterCount" style="color: #888; font-size: 13px;">
                            ì „ì²´: 0ê°œ / í‘œì‹œ: 0ê°œ
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button onclick="exportFilteredCommentsCSV()" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="CSVë¡œ ë‚´ë³´ë‚´ê¸°">ğŸ“Š CSV</button>
                            <button onclick="exportFilteredCommentsJSON()" style="background: #17a2b8; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="JSONìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°">ğŸ“„ JSON</button>
                        </div>
                    </div>

                    <!-- Comments List -->
                    <div id="commentsDashboard" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 600px; max-height: 900px; overflow-y: auto; background: #1e1e1e;">
                        <span style="color: #888;">ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="annotation-tab" class="tab-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;" data-i18n="annotation.title">Video Annotation</h2>
                <button onclick="showAnnotationHelp()" style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">
                    â“ <span data-i18n="annotation.help">ë„ì›€ë§</span>
                </button>
            </div>
            <div style="display: flex; gap: 20px; align-items: stretch;">
                <!-- Left Column: Settings & Annotations -->
                <div style="flex: 1; min-width: 300px; max-width: 400px; display: flex; flex-direction: column; gap: 20px;">
                    <!-- Unified Settings Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.project">Project</h3>

                        <!-- Current Project Info -->
                        <div style="margin-bottom: 20px;">
                            <div id="currentProjectDisplay" style="padding: 10px; background: #2d2d2d; border-radius: 4px; font-size: 12px; color: #4a9eff;">
                                <span data-i18n="annotation.noProject">No project selected</span>
                            </div>
                        </div>

                        <!-- Current Video Info -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;" data-i18n="annotation.video">Video</h4>
                            <div id="currentVideoDisplay" style="padding: 10px; background: #2d2d2d; border-radius: 4px; font-size: 12px; color: #888;">
                                <span data-i18n="annotation.noVideo">No video selected</span>
                            </div>
                        </div>

                        <!-- Annotation Mode Selection -->
                        <div style="margin-bottom: 15px;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;">ğŸ¯ ì–´ë…¸í…Œì´ì…˜ ëª¨ë“œ</h4>
                            <div style="display: flex; gap: 8px;">
                                <label style="display: flex; align-items: center; justify-content: center; padding: 10px; background: #2d2d2d; border: 2px solid #4a9eff; border-radius: 4px; cursor: pointer; flex: 1; transition: all 0.2s;" id="polygonModeLabel">
                                    <input type="radio" name="annotationMode" value="polygon" checked onclick="setAnnotationMode('polygon')" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-size: 12px; font-weight: bold;">ğŸ”· í´ë¦¬ê³¤ (ë“œë˜ê·¸)</span>
                                </label>
                                <label style="display: flex; align-items: center; justify-content: center; padding: 10px; background: #2d2d2d; border: 2px solid #404040; border-radius: 4px; cursor: pointer; flex: 1; transition: all 0.2s;" id="pointModeLabel">
                                    <input type="radio" name="annotationMode" value="point" onclick="setAnnotationMode('point')" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-size: 12px; font-weight: bold;">ğŸ“ í¬ì¸íŠ¸ (í´ë¦­)</span>
                                </label>
                            </div>
                        </div>

                        <!-- Drawing Mode Toggle -->
                        <div style="margin-bottom: 0;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;" data-i18n="annotation.drawingMode">Drawing Options</h4>
                            <div style="display: flex; gap: 8px;">
                                <label style="display: flex; align-items: center; padding: 8px; background: #2d2d2d; border: 2px solid #404040; border-radius: 4px; cursor: pointer; flex: 1;">
                                    <input type="checkbox" id="autoInferenceToggle" onclick="toggleAutoInference()" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-size: 12px;" data-i18n="annotation.autoInference">ğŸ¤– AI ìë™ ì¶”ë¡ </span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 8px; background: #2d2d2d; border: 2px solid #404040; border-radius: 4px; cursor: pointer; flex: 1;">
                                    <input type="checkbox" id="crosshairToggle" onclick="toggleCrosshair()" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-size: 12px;">â• ì‹­ìì„  ë³´ê¸°</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Current Frame Annotations Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); flex-grow: 1; display: flex; flex-direction: column;">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.annotations">Annotations</h3>

                        <!-- Current Frame Annotations -->
                        <div style="margin-bottom: 0; flex-grow: 1; display: flex; flex-direction: column;">
                            <h4 style="color: #e0e0e0; margin-top: 0; margin-bottom: 10px; font-size: 14px;" data-i18n="annotation.currentFrame">Current Frame</h4>
                            <div id="annotationList" style="border: 1px solid #404040; padding: 10px; border-radius: 4px; min-height: 200px; max-height: 280px; overflow-y: auto; background: #2d2d2d; font-size: 12px;">
                                <span data-i18n="annotation.noAnnotations">No annotations</span>
                            </div>
                            <div style="margin-top: 10px; display: flex; gap: 5px;">
                                <button onclick="editAnnotation()" style="flex: 1; font-size: 12px;" data-i18n="common.edit">âœï¸ Edit</button>
                                <button onclick="deleteAnnotation()" style="flex: 1; font-size: 12px;" data-i18n="common.delete">ğŸ—‘ Delete</button>
                            </div>
                            <div style="margin-top: 5px; display: flex; gap: 5px;">
                                <button onclick="saveCurrentFrame()" style="flex: 1; font-size: 12px;" data-i18n="annotation.saveFrame">ğŸ’¾ Save Frame</button>
                                <button onclick="clearFrame()" style="flex: 1; font-size: 12px;" data-i18n="annotation.clearFrame">Clear Frame</button>
                            </div>
                        </div>
                    </div>

                    <!-- Contributors Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        <h4 style="margin-top: 0; margin-bottom: 10px; color: #4a9eff; font-size: 14px;">ğŸ‘¥ í˜‘ì—…ì (Collaborators)</h4>
                        <div id="contributorsList" style="font-size: 12px; color: #ccc; min-height: 30px;">
                            <span style="color: #888;">í˜‘ì—…ì ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                        </div>
                    </div>

                    <!-- Annotation Comment Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.comment">Comment</h3>

                        <div id="commentSection">
                            <div id="noAnnotationSelected" style="color: #888; font-size: 12px; text-align: center; padding: 20px;">
                                <span data-i18n="annotation.selectAnnotationForComment">Select an annotation to add a comment</span>
                            </div>
                            <div id="commentEditor" style="display: none;">
                                <div style="margin-bottom: 10px;">
                                    <div id="selectedAnnotationInfo" style="color: #4a9eff; font-size: 12px; margin-bottom: 10px;"></div>
                                    <textarea id="annotationCommentText"
                                              placeholder="Enter your comment here..."
                                              style="width: 100%; min-height: 100px; padding: 10px; background: #2d2d2d; color: #e0e0e0; border: 1px solid #404040; border-radius: 4px; font-size: 12px; resize: vertical; font-family: inherit;"></textarea>
                                </div>
                                <button onclick="saveAnnotationComment()" style="width: 100%; font-size: 12px;" data-i18n="annotation.saveComment">ğŸ’¬ Save Comment</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Video Player & Statistics -->
                <div style="flex: 2; display: flex; flex-direction: column; gap: 20px;">
                    <!-- Video Player Card -->
                    <div style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px 20px 10px 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); flex-grow: 1; display: flex; flex-direction: column;">
                        <h3 style="margin-top: 0; margin-bottom: 20px; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px;" data-i18n="annotation.videoPlayer">Video Player</h3>

                        <div style="flex-grow: 1; display: flex; flex-direction: column;">
                            <!-- Video Canvas (Hybrid: video + canvas overlay) -->
<div id="canvasContainer" style="position: relative; background: #000; border-radius: 4px; margin-bottom: 8px; flex-shrink: 0;">
                            <!-- Hidden video element for playback (not visible but renders to canvas) -->
                            <video id="videoElement" style="position: absolute; top: 0; left: 0; width: 100%; height: auto; display: none;"></video>
                            <!-- Main canvas for video display -->
                            <canvas id="videoCanvas" width="1200" height="900" style="width: 100%; height: auto; display: block;"></canvas>

                            <!-- ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ -->
                            <div id="annotationContextMenu" style="
                                position: fixed;
                                display: none;
                                background: #2d2d2d;
                                border: 1px solid #404040;
                                border-radius: 4px;
                                padding: 4px 0;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.5);
                                z-index: 1000;
                                min-width: 150px;
                                max-width: 800px;">
                            </div>
                            <!-- Overlay canvas for annotations and preview -->
                            <canvas id="previewCanvas" width="1200" height="900" style="position: absolute; top: 0; left: 0; width: 100%; height: auto; display: block; pointer-events: none;"></canvas>
                            <!-- ì‹­ìì„  ì»¤ì„œ -->
                            <div id="crosshair-lines">
                                <div class="crosshair-h"></div>
                                <div class="crosshair-v"></div>
                                <div class="crosshair-center"></div>
                            </div>
                        </div>

                        <!-- Video Controls -->
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Playback Buttons Row -->
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <button id="playBtn" onclick="togglePlay()" disabled data-i18n="annotation.play">â–¶ Play</button>
                                <button id="prevFrameBtn" onclick="prevFrame()" disabled data-i18n="annotation.prev">â—€ Prev</button>
                                <button id="nextFrameBtn" onclick="nextFrame()" disabled data-i18n="annotation.next">Next â–¶</button>
                                <button id="skip15BackBtn" onclick="skip15SecondsBackward()" disabled data-i18n="annotation.skip15Back">âª -15s</button>
                                <button id="skip15ForwardBtn" onclick="skip15SecondsForward()" disabled data-i18n="annotation.skip15Forward">+15s â©</button>
                                <span id="frameLabel" style="margin-left: auto;">Frame: 0 / 0</span>
                                <label style="color: #e0e0e0; font-size: 14px;" data-i18n="annotation.speed">ì†ë„:</label>
                                <select id="annotationPlaybackSpeed" onchange="changeAnnotationPlaybackSpeed()" style="padding: 6px 10px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px; cursor: pointer; font-size: 13px;">
                                    <option value="0.25">0.25x</option>
                                    <option value="0.5">0.5x</option>
                                    <option value="1" selected>1x</option>
                                    <option value="1.5">1.5x</option>
                                    <option value="2">2x</option>
                                    <option value="4">4x</option>
                                    <option value="8">8x</option>
                                    <option value="16">16x</option>
                                </select>
                            </div>
                            <!-- Progress Bar Row (matches canvas width) -->
                            <div style="display: flex; width: 100%;">
                                <input type="range" id="frameSlider" min="0" max="0" value="0"
                                       style="width: 100%;" disabled oninput="onSliderChange()">
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Statistics Card -->
                    <div id="statisticsCard" style="background: #1e1e1e; border: 1px solid #404040; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; flex-direction: column; transition: all 0.3s ease;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: #4a9eff; border-bottom: 2px solid #4a9eff; padding-bottom: 10px; flex-grow: 1;" data-i18n="annotation.statistics">Statistics</h3>
                            <button id="toggleStatsBtn" onclick="toggleStatistics()" style="background: none; border: none; color: #4a9eff; cursor: pointer; font-size: 20px; padding: 5px 10px; margin-left: 10px;" title="í†µê³„ ìµœì†Œí™”/ìµœëŒ€í™”">â–¼</button>
                        </div>
                        <div id="statsContent" style="display: flex; flex-direction: column; flex-grow: 1;">
                            <div id="statsInfo" style="font-size: 12px; color: #4a9eff; margin-bottom: 10px;">
                                Saved: 0 | Frames: 0
                            </div>
                            <div id="statsTable" style="border: 1px solid #404040; padding: 10px; border-radius: 4px; overflow-y: auto; max-height: 400px; background: #2d2d2d; font-size: 11px; flex-grow: 1;">
                                <span data-i18n="annotation.noSavedAnnotations">No saved annotations</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="dataset-tab" class="tab-content">
            <h2 data-i18n="dataset.title">ğŸ¯ Dataset Builder</h2>

            <!-- Admin Dashboard (ê´€ë¦¬ì ì „ìš©) -->
            <div id="adminDashboardSection" style="display: block; margin-bottom: 30px;">
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 2px solid #4a9eff;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: #4a9eff;">ğŸ“Š ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ - ì „ì²´ í”„ë¡œì íŠ¸ í˜„í™©</h3>
                        <div style="display: flex; gap: 10px;">
                            <button id="createDatasetFromAdminBtn" onclick="createDatasetFromSelectedProjects()"
                                    style="padding: 8px 16px; background: #9b59b6; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold; display: none;">
                                ğŸ“¦ ì„ íƒí•œ í”„ë¡œì íŠ¸ë¡œ ë°ì´í„°ì…‹ ìƒì„± (<span id="selectedProjectCount">0</span>)
                            </button>
                            <button onclick="exportAdminDashboardCSV()" style="padding: 8px 16px; background: #28a745; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold;">
                                ğŸ“¥ CSV ë‚´ë³´ë‚´ê¸°
                            </button>
                            <button onclick="loadAdminDashboard()" style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold;">
                                ğŸ”„ ìƒˆë¡œê³ ì¹¨
                            </button>
                        </div>
                    </div>

                    <!-- ì „ì²´ í†µê³„ ìš”ì•½ -->
                    <div id="adminSummaryCards" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 15px; margin-bottom: 20px;">
                        <!-- Summary cards will be populated by JavaScript -->
                    </div>

                    <!-- í•„í„° ì»¨íŠ¸ë¡¤ -->
                    <div style="margin-bottom: 10px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <input type="text" id="adminProjectFilter" placeholder="í”„ë¡œì íŠ¸ ë˜ëŠ” ì‚¬ìš©ì ê²€ìƒ‰..."
                               style="padding: 8px; width: 250px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;"
                               oninput="filterAdminProjects()">
                        <select id="adminClassFilter" onchange="filterAdminProjects()"
                                style="padding: 8px; min-width: 180px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                            <option value="">ğŸ·ï¸ ëª¨ë“  í´ë˜ìŠ¤</option>
                        </select>
                        <span id="adminFilterInfo" style="color: #888; font-size: 12px; margin-left: 10px;"></span>
                        <button onclick="viewClassAnnotations()" id="viewClassAnnotationsBtn" 
                                style="padding: 8px 12px; background: #9b59b6; border: none; border-radius: 4px; cursor: pointer; color: white; display: none;">
                            ğŸ‘ï¸ í´ë˜ìŠ¤ ì–´ë…¸í…Œì´ì…˜ ë³´ê¸°
                        </button>
                    </div>
                    <div id="adminProjectsList" style="max-height: 600px; overflow-y: auto; border: 1px solid #404040; border-radius: 4px; background: #1e1e1e;">
                        <div style="padding: 20px; text-align: center; color: #999;">ëŒ€ì‹œë³´ë“œë¥¼ ë¡œë“œí•˜ë ¤ë©´ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</div>
                    </div>
                </div>
            </div>

            <!-- í”„ë¡œì íŠ¸ ìƒì„¸ ëª¨ë‹¬ -->
            <div id="projectDetailModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; overflow: auto;">
                <div style="position: relative; background: #2d2d2d; margin: 50px auto; padding: 30px; max-width: 900px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <button onclick="closeProjectDetail()" style="position: absolute; top: 15px; right: 15px; background: #ff4444; border: none; color: white; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">âœ• ë‹«ê¸°</button>

                    <div id="projectDetailContent">
                        <!-- Content will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- 2ë‹¨ê³„ ì›Œí¬í”Œë¡œìš° -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">

                <!-- STEP 1: í”„ë¡œì íŠ¸ & í´ë˜ìŠ¤ ì„ íƒ -->
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 2px solid #4a9eff;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <div style="background: #4a9eff; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">1</div>
                        <h3 style="margin: 0; color: #4a9eff;">í”„ë¡œì íŠ¸ & í´ë˜ìŠ¤ ì„ íƒ</h3>
                    </div>

                    <!-- í”„ë¡œì íŠ¸ ë‹¤ì¤‘ ì„ íƒ -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #aaa;">ğŸ“ í”„ë¡œì íŠ¸ (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)</label>
                        <div id="datasetProjectList" style="max-height: 180px; overflow-y: auto; padding: 10px; background: #1e1e1e; border: 1px solid #555; border-radius: 4px;">
                            <div style="color: #999; text-align: center; padding: 20px;">í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë”© ì¤‘...</div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <button onclick="selectAllProjects()" style="flex: 1; padding: 5px; background: #4a9eff; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">ì „ì²´ ì„ íƒ</button>
                            <button onclick="deselectAllProjects()" style="flex: 1; padding: 5px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">ì „ì²´ í•´ì œ</button>
                        </div>
                        <div style="margin-top: 5px; font-size: 11px; color: #888;">
                            ì„ íƒëœ í”„ë¡œì íŠ¸: <span id="selectedProjectCount" style="color: #4a9eff; font-weight: bold;">0</span>ê°œ
                        </div>
                    </div>

                    <!-- í´ë˜ìŠ¤ í•„í„° -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #aaa;">ğŸ·ï¸ í´ë˜ìŠ¤ ì„ íƒ</label>
                        <div id="datasetClassFilter" style="max-height: 200px; overflow-y: auto; padding: 10px; background: #1e1e1e; border: 1px solid #555; border-radius: 4px;">
                            <div style="color: #999; text-align: center; padding: 20px;">í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”</div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <button onclick="selectAllClasses()" style="flex: 1; padding: 5px; background: #4a9eff; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">ì „ì²´ ì„ íƒ</button>
                            <button onclick="deselectAllClasses()" style="flex: 1; padding: 5px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">ì „ì²´ í•´ì œ</button>
                        </div>
                        <!-- í´ë˜ìŠ¤ ê´€ë¦¬ ë²„íŠ¼ -->
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <button onclick="openClassManager('rename')" style="flex: 1; padding: 5px; background: #e67e22; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;" title="ì„ íƒí•œ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½">âœï¸ ì´ë¦„ë³€ê²½</button>
                            <button onclick="openClassManager('merge')" style="flex: 1; padding: 5px; background: #9b59b6; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;" title="ì„ íƒí•œ í´ë˜ìŠ¤ë“¤ì„ í•˜ë‚˜ë¡œ ë³‘í•©">ğŸ”— ë³‘í•©</button>
                            <button onclick="openClassManager('delete')" style="flex: 1; padding: 5px; background: #e74c3c; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;" title="ì„ íƒí•œ í´ë˜ìŠ¤ ì‚­ì œ">ğŸ—‘ï¸ ì‚­ì œ</button>
                            <button onclick="openClassManager('preview')" style="flex: 1; padding: 5px; background: #3498db; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;" title="ì„ íƒí•œ í´ë˜ìŠ¤ ì–´ë…¸í…Œì´ì…˜ ë¯¸ë¦¬ë³´ê¸°">ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸°</button>
                        </div>
                    </div>

                    <!-- í†µê³„ ìš”ì•½ -->
                    <div id="datasetStats" style="padding: 12px; background: #1e1e1e; border-radius: 4px; border: 1px solid #555;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 12px; text-align: center;">
                            <div>
                                <div style="color: #aaa;">í”„ë ˆì„</div>
                                <div style="color: #4a9eff; font-weight: bold; font-size: 16px;" id="statTotalFrames">0</div>
                            </div>
                            <div>
                                <div style="color: #aaa;">ì–´ë…¸í…Œì´ì…˜</div>
                                <div style="color: #9b59b6; font-weight: bold; font-size: 16px;" id="statTotalAnnotations">0</div>
                            </div>
                            <div>
                                <div style="color: #aaa;">ë¹„ë””ì˜¤</div>
                                <div style="color: #28a745; font-weight: bold; font-size: 16px;" id="statTotalVideos">0</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- STEP 2: ë¹Œë“œ ì„¤ì • & ì‹¤í–‰ -->
                <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 2px solid #28a745;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <div style="background: #28a745; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">2</div>
                        <h3 style="margin: 0; color: #28a745;">ë¹Œë“œ ì„¤ì •</h3>
                    </div>

                    <!-- ì„¤ì • -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #aaa;">ì¶œë ¥ ë””ë ‰í† ë¦¬</label>
                            <input type="text" id="datasetOutputPath" value="pipe_dataset" style="width: 100%; padding: 6px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px; font-size: 12px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #aaa;">Train/Val/Test ë¹„ìœ¨</label>
                            <input type="text" id="datasetSplit" value="0.7,0.15,0.15" style="width: 100%; padding: 6px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px; font-size: 12px;">
                        </div>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #aaa;">ë°ì´í„°ì…‹ í˜•ì‹</label>
                        <select id="datasetFormat" style="width: 100%; padding: 6px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px; font-size: 12px;">
                            <option value="yolo">YOLO Segmentation</option>
                        </select>
                    </div>

                    <!-- ì§„í–‰ë¥  -->
                    <div style="margin-bottom: 15px;">
                        <div style="background: #1e1e1e; height: 20px; border-radius: 4px; overflow: hidden; margin-bottom: 5px;">
                            <div id="datasetProgressBar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="datasetProgressText" style="font-size: 11px; color: #aaa; text-align: center;">ì¤€ë¹„ë¨</div>
                    </div>

                    <!-- ë²„íŠ¼ë“¤ -->
                    <div style="display: flex; gap: 10px;">
                        <button onclick="openLabelingInspector()" id="inspectLabelingBtn" style="flex: 1; padding: 10px; font-size: 13px; font-weight: bold; background: #9b59b6; border: none; color: white; border-radius: 4px; cursor: pointer;">
                            ğŸ” ë¼ë²¨ë§ ì ê²€
                        </button>
                        <button onclick="buildDataset()" id="buildDatasetBtn" style="flex: 1; padding: 10px; font-size: 13px; font-weight: bold; background: #28a745; border: none; color: white; border-radius: 4px; cursor: pointer;">
                            ğŸš€ ë°ì´í„°ì…‹ ë¹Œë“œ
                        </button>
                    </div>
                </div>
            </div>

            <!-- ë¼ë²¨ë§ ì ê²€ íŒ¨ë„ (ìˆ¨ê¹€ ìƒíƒœ) -->
            <div id="labelingInspectorPanel" style="display: none; background: #2d2d2d; padding: 20px; border-radius: 8px; border: 2px solid #9b59b6; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; color: #9b59b6;">ğŸ” ë¼ë²¨ë§ ì ê²€</h3>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="inspectorVideoSelector" onchange="loadInspectorFrames()" style="padding: 6px 12px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px; min-width: 200px;">
                            <option value="">-- ë¹„ë””ì˜¤ ì„ íƒ --</option>
                        </select>
                        <button onclick="closeLabelingInspector()" style="padding: 6px 12px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer;">ë‹«ê¸°</button>
                    </div>
                </div>

                <!-- í•„í„° ì˜µì…˜ -->
                <div style="display: flex; gap: 15px; margin-bottom: 15px; padding: 10px; background: #1e1e1e; border-radius: 4px;">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #ccc; font-size: 13px;">
                        <input type="radio" name="inspectorFilter" value="all" checked onchange="filterInspectorFrames()"> ì‘ì—…ëœ í”„ë ˆì„
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #ccc; font-size: 13px;">
                        <input type="radio" name="inspectorFilter" value="annotated" onchange="filterInspectorFrames()"> ì„ íƒ í´ë˜ìŠ¤ ìˆìŒ
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #ccc; font-size: 13px;">
                        <input type="radio" name="inspectorFilter" value="empty" onchange="filterInspectorFrames()"> ì„ íƒ í´ë˜ìŠ¤ ì—†ìŒ
                    </label>
                    <div style="margin-left: auto; color: #aaa; font-size: 13px;">
                        í‘œì‹œ: <span id="inspectorFrameCount" style="color: #4a9eff; font-weight: bold;">0</span>ê°œ í”„ë ˆì„
                    </div>
                </div>

                <!-- í”„ë ˆì„ ê·¸ë¦¬ë“œ -->
                <div id="inspectorFrameGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; max-height: 500px; overflow-y: auto; padding: 10px; background: #1e1e1e; border-radius: 4px;">
                    <div style="color: #999; text-align: center; padding: 40px; grid-column: 1/-1;">ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ë©´ í”„ë ˆì„ì´ í‘œì‹œë©ë‹ˆë‹¤</div>
                </div>
            </div>

            <!-- ì–´ë…¸í…Œì´ì…˜ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ -->
            <div id="annotationPreviewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; justify-content: center; align-items: center;">
                <div style="position: relative; max-width: 90%; max-height: 90%;">
                    <button onclick="closeAnnotationPreview()" style="position: absolute; top: -40px; right: 0; background: #ff4444; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;">ë‹«ê¸° (ESC)</button>
                    <div style="position: absolute; top: -40px; left: 0; color: white; font-size: 14px;">
                        <span id="previewFrameInfo">í”„ë ˆì„ 0</span> -
                        <span id="previewAnnotationCount">0ê°œ ì–´ë…¸í…Œì´ì…˜</span>
                    </div>
                    <div id="previewImageContainer" style="position: relative; display: inline-block; line-height: 0;">
                        <img id="previewBaseImage" style="max-width: 85vw; max-height: 75vh; display: block;" />
                    </div>
                    <div id="previewLegend" style="margin-top: 10px; padding: 10px; background: #2d2d2d; border-radius: 4px; display: flex; flex-wrap: wrap; gap: 10px;"></div>
                    <!-- ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼ -->
                    <div style="position: absolute; top: 50%; left: -50px; transform: translateY(-50%);">
                        <button onclick="navigatePreview(-1)" style="background: #4a9eff; border: none; color: white; padding: 15px 20px; border-radius: 4px; cursor: pointer; font-size: 20px;">â—€</button>
                    </div>
                    <div style="position: absolute; top: 50%; right: -50px; transform: translateY(-50%);">
                        <button onclick="navigatePreview(1)" style="background: #4a9eff; border: none; color: white; padding: 15px 20px; border-radius: 4px; cursor: pointer; font-size: 20px;">â–¶</button>
                    </div>
                </div>
            </div>

            <!-- í´ë˜ìŠ¤ ê´€ë¦¬ ëª¨ë‹¬ -->
            <div id="classManagerModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
                <div style="background: #2d2d2d; border-radius: 8px; padding: 25px; max-width: 800px; width: 90%; max-height: 85vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 id="classManagerTitle" style="margin: 0; color: #4a9eff;">í´ë˜ìŠ¤ ê´€ë¦¬</h3>
                        <button onclick="closeClassManager()" style="background: #ff4444; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">ë‹«ê¸°</button>
                    </div>
                    <div id="classManagerContent">
                        <!-- ë™ì  ì½˜í…ì¸  -->
                    </div>
                </div>
            </div>

            <!-- ì–´ë…¸í…Œì´ì…˜ í¸ì§‘ ëª¨ë‹¬ -->
            <div id="annotationEditorModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10001; justify-content: center; align-items: center;">
                <div style="display: flex; flex-direction: column; width: 95%; height: 95%; max-width: 1400px;">
                    <!-- í—¤ë” -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: #2d2d2d; border-radius: 8px 8px 0 0;">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <h3 style="margin: 0; color: #4a9eff;">âœï¸ ì–´ë…¸í…Œì´ì…˜ í¸ì§‘</h3>
                            <span id="editorFrameInfo" style="color: #aaa; font-size: 13px;"></span>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="editorPrevFrame()" style="background: #555; border: none; color: white; padding: 8px 15px; border-radius: 4px; cursor: pointer;">â—€ ì´ì „</button>
                            <button onclick="editorNextFrame()" style="background: #555; border: none; color: white; padding: 8px 15px; border-radius: 4px; cursor: pointer;">ë‹¤ìŒ â–¶</button>
                            <button onclick="saveAnnotationEdit()" style="background: #28a745; border: none; color: white; padding: 8px 20px; border-radius: 4px; cursor: pointer; font-weight: bold;">ğŸ’¾ ì €ì¥</button>
                            <button onclick="closeAnnotationEditor()" style="background: #ff4444; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">ë‹«ê¸°</button>
                        </div>
                    </div>
                    <!-- ë©”ì¸ ì˜ì—­ -->
                    <div style="display: flex; flex: 1; overflow: hidden; background: #1a1a1a;">
                        <!-- ìº”ë²„ìŠ¤ ì˜ì—­ -->
                        <div style="flex: 1; position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden;">
                            <canvas id="editorCanvas" style="max-width: 100%; max-height: 100%; cursor: crosshair;"></canvas>
                        </div>
                        <!-- ì‚¬ì´ë“œë°” - ì–´ë…¸í…Œì´ì…˜ ëª©ë¡ -->
                        <div style="width: 280px; background: #2d2d2d; padding: 15px; overflow-y: auto;">
                            <h4 style="margin: 0 0 10px 0; color: #ccc;">ì–´ë…¸í…Œì´ì…˜ ëª©ë¡</h4>
                            <div id="editorAnnotationList" style="display: flex; flex-direction: column; gap: 8px;">
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                                <div style="font-size: 11px; color: #888; margin-bottom: 10px;">
                                    ğŸ’¡ íŒ: ì–´ë…¸í…Œì´ì…˜ í´ë¦­ìœ¼ë¡œ ì„ íƒ, ì  ë“œë˜ê·¸ë¡œ ìˆ˜ì •
                                </div>
                                <button onclick="deleteSelectedAnnotation()" id="deleteAnnotationBtn" style="width: 100%; padding: 10px; background: #e74c3c; border: none; color: white; border-radius: 4px; cursor: pointer; display: none;">
                                    ğŸ—‘ï¸ ì„ íƒí•œ ì–´ë…¸í…Œì´ì…˜ ì‚­ì œ
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ë¹Œë“œ ê²°ê³¼ ìš”ì•½ -->
            <div id="datasetResultPanel" style="display: none; background: #1a3a1a; padding: 20px; border-radius: 8px; border: 2px solid #28a745; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; color: #28a745;">âœ… ë°ì´í„°ì…‹ ë¹Œë“œ ì™„ë£Œ</h3>
                <div id="datasetResultContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                </div>
            </div>

            <!-- ë¹Œë“œ ë¡œê·¸ -->
            <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; border: 1px solid #404040;">
                <h3 style="margin: 0 0 15px 0; color: #ccc;">ğŸ“‹ ë¹Œë“œ ë¡œê·¸</h3>
                <div id="datasetLog" style="padding: 15px; border-radius: 4px; min-height: 150px; max-height: 300px; background: #1e1e1e; font-family: monospace; font-size: 12px; overflow-y: auto; border: 1px solid #555; color: #aaa;">
                    <span data-i18n="dataset.ready">Ready to build dataset...</span>
                </div>
            </div>
        </div>

        <div id="training-tab" class="tab-content">
            <h2 data-i18n="training.title">Model Training</h2>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="training.modelType">ëª¨ë¸ íƒ€ì…</h3>
                <select id="trainingModelType" style="width: 300px;">
                    <option value="classification">Classification (MobileNet)</option>
                    <option value="yolo">Detection (YOLO)</option>
                </select>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="training.dataset">ë°ì´í„°ì…‹</h3>
                <input type="text" id="trainingDatasetPath" value="pipe_dataset" style="width: 400px;">
                <button onclick="browseDataset()" style="margin-left: 10px;" data-i18n="training.browse">Browse...</button>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 data-i18n="training.settings">í•™ìŠµ ì„¤ì •</h3>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.outputDir">ì¶œë ¥ ë””ë ‰í† ë¦¬:</label>
                    <input type="text" id="trainingOutputPath" value="models" style="width: 300px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.epochs">Epochs:</label>
                    <input type="number" id="trainingEpochs" value="20" min="1" max="200" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.batchSize">Batch Size:</label>
                    <input type="number" id="trainingBatchSize" value="32" min="1" max="128" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label data-i18n="training.learningRate">Learning Rate:</label>
                    <input type="text" id="trainingLR" value="0.001" style="width: 100px; margin-left: 10px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label>
                        <input type="checkbox" id="trainingEvaluate" checked>
                        <span data-i18n="training.evaluate">Evaluate on test set</span>
                    </label>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <button onclick="startTraining()" id="startTrainingBtn" style="padding: 10px 20px; background: #28a745;" data-i18n="training.start">â–¶ Start Training</button>
                <button onclick="stopTraining()" id="stopTrainingBtn" disabled style="padding: 10px 20px; background: #dc3545; margin-left: 10px;" data-i18n="training.stop">â¹ Stop</button>
            </div>

            <div style="margin-bottom: 10px;">
                <div id="trainingProgress" style="background: #1e1e1e; height: 30px; border-radius: 4px; overflow: hidden; position: relative;">
                    <div id="trainingProgressBar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    <div id="trainingProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold;">0%</div>
                </div>
            </div>

            <div>
                <h3 data-i18n="training.log">í•™ìŠµ ë¡œê·¸</h3>
                <div id="trainingLog" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; height: 300px; background: #1e1e1e; font-family: monospace; font-size: 12px; overflow-y: auto;">
                    <span data-i18n="training.ready">Ready to start training...</span>
                </div>
            </div>
        </div>

        <div id="inference-tab" class="tab-content">
            <h2 data-i18n="inference.title">ğŸ¬ Video Inference</h2>

            <!-- 2ë‹¨ ë ˆì´ì•„ì›ƒ: ì™¼ìª½ ì„¤ì •, ì˜¤ë¥¸ìª½ ì‹¤ì‹œê°„ ê²°ê³¼ -->
            <div style="display: grid; grid-template-columns: 400px 1fr; gap: 20px; height: calc(100vh - 180px);">

                <!-- ì™¼ìª½: ì„¤ì • íŒ¨ë„ -->
                <div style="background: #1e1e1e; padding: 20px; border-radius: 8px; overflow-y: auto;">
                    <h3 style="margin-top: 0; border-bottom: 2px solid #404040; padding-bottom: 10px;" data-i18n="inference.settings">âš™ï¸ ì¶”ë¡  ì„¤ì •</h3>

                    <!-- í”„ë¡œì íŠ¸ ì„ íƒ -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;">í”„ë¡œì íŠ¸ ì„ íƒ</label>
                        <select id="inferenceProjectSelect" onchange="loadInferenceVideos()" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <option value="">-- í”„ë¡œì íŠ¸ ì„ íƒ --</option>
                        </select>
                    </div>

                    <!-- ë¹„ë””ì˜¤ ì„ íƒ -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;">ë¹„ë””ì˜¤ ì„ íƒ</label>
                        <select id="inferenceVideoSelect" onchange="onInferenceVideoSelected()" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <option value="">-- ë¹„ë””ì˜¤ ì„ íƒ --</option>
                        </select>
                    </div>

                    <!-- ëª¨ë¸ ì„ íƒ -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.modelType">ëª¨ë¸ íƒ€ì…</label>
                        <select id="inferenceModelType" onchange="onModelTypeChanged()" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <option value="yolo" selected>YOLO Detection</option>
                            <option value="segformer">SegFormer Segmentation</option>
                            <option value="classification">Classification</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.modelFile">ëª¨ë¸ íŒŒì¼</label>
                        <div style="display: flex; gap: 5px;">
                            <input type="text" id="inferenceModelPath" placeholder="ëª¨ë¸ ê²½ë¡œ (ì˜ˆ: best.pt)" style="flex: 1; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                            <button onclick="browseInferenceModel()" style="padding: 8px 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer;">ğŸ“</button>
                        </div>
                        <div style="font-size: 11px; color: #666; margin-top: 5px;">YOLO: .pt íŒŒì¼ / SegFormer: .pth íŒŒì¼</div>
                    </div>

                    <!-- ë¹„ë””ì˜¤ ê²½ë¡œ (ì§ì ‘ ì…ë ¥ìš©, ìˆ¨ê¹€) -->
                    <input type="hidden" id="inferenceVideoPath">

                    <!-- ì¶”ë¡  ì„¤ì • -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.outputDir">ì¶œë ¥ ë””ë ‰í† ë¦¬</label>
                        <input type="text" id="inferenceOutputPath" value="inference_results" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.confidence">Confidence ì„ê³„ê°’</label>
                        <input type="number" id="inferenceConfidence" value="0.5" min="0" max="1" step="0.1" style="width: 100%; padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                    </div>

                    <!-- ì‹¤í–‰ ë²„íŠ¼ -->
                    <div style="margin-bottom: 20px;">
                        <button onclick="startInference()" id="startInferenceBtn" style="width: 100%; padding: 12px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;" data-i18n="inference.start">
                            â–¶ï¸ Start Inference
                        </button>
                        <button onclick="cancelInference()" id="cancelInferenceBtn" style="width: 100%; padding: 12px; background: #ff4444; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold; display: none; margin-top: 10px;" data-i18n="inference.cancel">
                            âŒ Cancel
                        </button>
                        <button onclick="saveInferenceResults()" id="saveInferenceBtn" style="width: 100%; padding: 12px; background: #28a745; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold; display: none; margin-top: 10px;">
                            ğŸ’¾ ê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥
                        </button>
                    </div>

                    <!-- ì§„í–‰ë¥  -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;" data-i18n="inference.progress">ì§„í–‰ ìƒí™©</label>
                        <div id="inferenceProgress" style="background: #0e0e0e; height: 40px; border-radius: 4px; overflow: hidden; position: relative; border: 1px solid #404040;">
                            <div id="inferenceProgressBar" style="background: linear-gradient(90deg, #4a9eff, #00d4ff); height: 100%; width: 0%; transition: width 0.3s;"></div>
                            <div id="inferenceProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold; font-size: 14px;">
                                <span data-i18n="inference.preparing">ì¤€ë¹„ ì¤‘...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ì˜¤ë¥¸ìª½: ì‹¤ì‹œê°„ ì¶”ë¡  ê²°ê³¼ -->
                <div style="background: #1e1e1e; padding: 20px; border-radius: 8px; overflow: hidden; display: flex; flex-direction: column;">
                    <h3 style="margin-top: 0; border-bottom: 2px solid #404040; padding-bottom: 10px;" data-i18n="inference.results">ğŸ¥ ì‹¤ì‹œê°„ ì¶”ë¡  ê²°ê³¼</h3>

                    <!-- í”Œë ˆì´ì–´ ì»¨í…Œì´ë„ˆ -->
                    <div id="inferencePreviewContainer" style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 0;">
                        <!-- ì´ˆê¸° ìƒíƒœ: ëŒ€ê¸° ë©”ì‹œì§€ -->
                        <div id="inferencePreviewPlaceholder" style="text-align: center; color: #666;">
                            <div style="font-size: 64px; margin-bottom: 20px;">ğŸ¬</div>
                            <div style="font-size: 18px; margin-bottom: 10px;">ì¶”ë¡ ì„ ì‹œì‘í•˜ë©´ ì—¬ê¸°ì— ì‹¤ì‹œê°„ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>
                            <div style="font-size: 14px; color: #888;">ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ê³  Start Inference ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</div>
                        </div>

                        <!-- ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ (ìˆ¨ê¹€ ìƒíƒœë¡œ ì‹œì‘) -->
                        <div id="inferencePreviewPlayer" style="display: none; width: 100%; height: 100%; flex-direction: column;">
                            <div style="flex: 1; border: 2px solid #404040; border-radius: 8px; overflow: hidden; background: #000; display: flex; flex-direction: column;">
                                <!-- ë¹„ë””ì˜¤ ë””ìŠ¤í”Œë ˆì´ -->
                                <div style="flex: 1; position: relative; display: flex; align-items: center; justify-content: center; background: #000;">
                                    <canvas id="inferencePreviewCanvas" style="max-width: 100%; max-height: 100%; display: block;"></canvas>
                                    <div id="inferencePreviewStatus" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #fff; padding: 8px 12px; border-radius: 4px; font-size: 14px; font-weight: bold;">
                                        í”„ë ˆì„: 0 / 0
                                    </div>
                                    <div id="inferenceBufferStatus" style="position: absolute; top: 10px; left: 10px; background: rgba(74,158,255,0.9); color: #fff; padding: 8px 12px; border-radius: 4px; font-size: 14px; font-weight: bold;">
                                        ë²„í¼: 0%
                                    </div>
                                </div>

                                <!-- ë¹„ë””ì˜¤ ì»¨íŠ¸ë¡¤ -->
                                <div style="background: #0e0e0e; padding: 15px; border-top: 1px solid #404040;">
                                    <!-- íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë” -->
                                    <div style="margin-bottom: 10px;">
                                        <input type="range" id="videoTimeline" min="0" max="100" value="0"
                                               style="width: 100%; cursor: pointer;"
                                               oninput="seekToFrame(this.value)">
                                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: #999; margin-top: 5px;">
                                            <span id="videoCurrentTime">00:00</span>
                                            <span id="videoDuration">00:00</span>
                                        </div>
                                    </div>

                                    <!-- ì¬ìƒ ì»¨íŠ¸ë¡¤ -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <button onclick="togglePlayPause()" id="playPauseBtn" style="padding: 8px 16px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                                            â–¶ï¸ ì¬ìƒ
                                        </button>
                                        <button onclick="stopPlayback()" style="padding: 8px 16px; background: #666; border: none; border-radius: 4px; cursor: pointer;">
                                            â¹ï¸ ì •ì§€
                                        </button>
                                        <button onclick="skipFrames(-10)" style="padding: 8px 12px; background: #666; border: none; border-radius: 4px; cursor: pointer;">
                                            âª -10
                                        </button>
                                        <button onclick="skipFrames(10)" style="padding: 8px 12px; background: #666; border: none; border-radius: 4px; cursor: pointer;">
                                            â© +10
                                        </button>

                                        <div style="flex: 1;"></div>

                                        <label style="color: #fff; font-size: 14px;">ì†ë„:</label>
                                        <select id="playbackSpeed" onchange="changePlaybackSpeed()" style="padding: 8px; background: #2e2e2e; color: #fff; border: 1px solid #404040; border-radius: 4px; cursor: pointer;">
                                            <option value="0.25">0.25x</option>
                                            <option value="0.5">0.5x</option>
                                            <option value="1" selected>1x</option>
                                            <option value="1.5">1.5x</option>
                                            <option value="2">2x</option>
                                            <option value="4">4x</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ ì„¹ì…˜ -->
            <div id="representativeFramePanel" style="display: none; margin-top: 20px; background: #1e1e1e; padding: 20px; border-radius: 8px; border: 2px solid #4a9eff;">
                <h3 style="margin-top: 0; border-bottom: 2px solid #404040; padding-bottom: 10px;">
                    ğŸ¯ ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ
                    <span style="font-size: 12px; color: #888; font-weight: normal; margin-left: 10px;">ì¶”ë¡  ê²°ê³¼ì—ì„œ í•™ìŠµ ë°ì´í„°ì…‹ìš© ëŒ€í‘œ í”„ë ˆì„ ì„ ë³„</span>
                </h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                    <!-- 1ë‹¨ê³„: ì›€ì§ì„ ë¶„ì„ -->
                    <div style="background: #252525; padding: 15px; border-radius: 8px;">
                        <h4 style="margin: 0 0 15px 0; color: #4a9eff;">ğŸ“Š 1ë‹¨ê³„: ì›€ì§ì„ ë¶„ì„</h4>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">ì›€ì§ì„ ì„ê³„ê°’</label>
                            <input type="range" id="motionThreshold" min="1" max="20" value="5" style="width: 100%;"
                                   oninput="document.getElementById('motionThresholdValue').textContent = this.value">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666;">
                                <span>ë¯¼ê° (1)</span>
                                <span id="motionThresholdValue" style="color: #4a9eff; font-weight: bold;">5</span>
                                <span>ë‘”ê° (20)</span>
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">ìµœì†Œ êµ¬ê°„ ê¸¸ì´ (ì´ˆ)</label>
                            <input type="number" id="minSegmentDuration" value="1.0" min="0.5" max="10" step="0.5"
                                   style="width: 100%; padding: 8px; background: #1e1e1e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                        </div>

                        <button onclick="analyzeMotion()" id="analyzeMotionBtn"
                                style="width: 100%; padding: 10px; background: #4a9eff; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                            ğŸ” êµ¬ê°„ ë¶„ì„
                        </button>

                        <div id="motionAnalysisResult" style="margin-top: 12px; padding: 10px; background: #1e1e1e; border-radius: 4px; font-size: 12px; display: none;">
                            <div>ì •ì§€ êµ¬ê°„: <span id="segmentCount" style="color: #4a9eff; font-weight: bold;">-</span>ê°œ</div>
                            <div>ì›€ì§ì„ ë²”ìœ„: <span id="motionRange" style="color: #888;">-</span></div>
                        </div>
                    </div>

                    <!-- 2ë‹¨ê³„: ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ -->
                    <div style="background: #252525; padding: 15px; border-radius: 8px;">
                        <h4 style="margin: 0 0 15px 0; color: #28a745;">âœ… 2ë‹¨ê³„: ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ</h4>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">êµ¬ê°„ë‹¹ í”„ë ˆì„ ìˆ˜</label>
                            <select id="framesPerSegment" style="width: 100%; padding: 8px; background: #1e1e1e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                                <option value="1">1ê°œ</option>
                                <option value="2">2ê°œ</option>
                                <option value="3" selected>3ê°œ</option>
                                <option value="5">5ê°œ</option>
                            </select>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">ìµœì†Œ Confidence</label>
                            <input type="range" id="minConfidenceFilter" min="0.3" max="0.95" value="0.5" step="0.05" style="width: 100%;"
                                   oninput="document.getElementById('minConfidenceValue').textContent = parseFloat(this.value).toFixed(2)">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666;">
                                <span>0.30</span>
                                <span id="minConfidenceValue" style="color: #28a745; font-weight: bold;">0.50</span>
                                <span>0.95</span>
                            </div>
                        </div>

                        <button onclick="extractRepresentatives()" id="extractRepresentativesBtn" disabled
                                style="width: 100%; padding: 10px; background: #28a745; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; opacity: 0.5;">
                            âœ… ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ
                        </button>

                        <div id="extractionResult" style="margin-top: 12px; padding: 10px; background: #1e1e1e; border-radius: 4px; font-size: 12px; display: none;">
                            <div>ì„ íƒëœ í”„ë ˆì„: <span id="selectedFrameCount" style="color: #28a745; font-weight: bold;">-</span>ê°œ</div>
                            <div>ì´ ê²€ì¶œ ìˆ˜: <span id="selectedDetectionCount" style="color: #888;">-</span>ê°œ</div>
                        </div>
                    </div>

                    <!-- 3ë‹¨ê³„: ë°ì´í„°ì…‹ ë‚´ë³´ë‚´ê¸° -->
                    <div style="background: #252525; padding: 15px; border-radius: 8px;">
                        <h4 style="margin: 0 0 15px 0; color: #ff9800;">ğŸ’¾ 3ë‹¨ê³„: ë°ì´í„°ì…‹ ë‚´ë³´ë‚´ê¸°</h4>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">ì¶œë ¥ ë””ë ‰í† ë¦¬</label>
                            <input type="text" id="extractedDatasetPath" value="extracted_dataset"
                                   style="width: 100%; padding: 8px; background: #1e1e1e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">ë°ì´í„°ì…‹ í˜•ì‹</label>
                            <select id="extractedDatasetFormat" style="width: 100%; padding: 8px; background: #1e1e1e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                                <option value="yolo" selected>YOLO Segmentation</option>
                                <option value="coco">COCO</option>
                            </select>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #aaa;">Train/Val/Test ë¹„ìœ¨</label>
                            <input type="text" id="extractedSplitRatio" value="0.8,0.1,0.1"
                                   style="width: 100%; padding: 8px; background: #1e1e1e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
                        </div>

                        <button onclick="exportExtractedDataset()" id="exportDatasetBtn" disabled
                                style="width: 100%; padding: 10px; background: #ff9800; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; color: #000; opacity: 0.5;">
                            ğŸš€ ë°ì´í„°ì…‹ ìƒì„±
                        </button>

                        <div id="exportResult" style="margin-top: 12px; padding: 10px; background: #1e1e1e; border-radius: 4px; font-size: 12px; display: none;">
                            <div id="exportResultContent"></div>
                        </div>
                    </div>
                </div>

                <!-- ì§„í–‰ ìƒíƒœ ë°” -->
                <div id="extractionProgressContainer" style="display: none; margin-top: 15px;">
                    <div style="background: #0e0e0e; height: 30px; border-radius: 4px; overflow: hidden; position: relative;">
                        <div id="extractionProgressBar" style="background: linear-gradient(90deg, #4a9eff, #28a745); height: 100%; width: 0%; transition: width 0.3s;"></div>
                        <div id="extractionProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold; font-size: 12px;">
                            ì¤€ë¹„ ì¤‘...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Admin Tab (ê´€ë¦¬ì ì „ìš©) -->
        <div id="admin-tab" class="tab-content">
            <h2>ğŸ‘¥ ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ</h2>

            <!-- ì „ì²´ í”„ë¡œì íŠ¸ ëŒ€ì‹œë³´ë“œ -->
            <div style="margin-bottom: 30px;">
                <h3>ğŸ“Š ì „ì²´ í”„ë¡œì íŠ¸ í˜„í™©</h3>
                <div id="allProjectsList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 300px; background: #1e1e1e; max-height: 600px; overflow-y: auto;">
                    <p style="color: #999;">ë¡œë”© ì¤‘...</p>
                </div>
            </div>

            <!-- ì‚¬ìš©ì ëª©ë¡ -->
            <div style="margin-bottom: 30px;">
                <h3>ì‚¬ìš©ì ëª©ë¡</h3>
                <div id="usersList" style="border: 1px solid #404040; padding: 15px; border-radius: 4px; min-height: 200px; background: #1e1e1e;">
                    <p style="color: #999;">ë¡œë”© ì¤‘...</p>
                </div>
            </div>

            <!-- ìƒˆ ì‚¬ìš©ì ìƒì„± -->
            <div style="margin-bottom: 30px;">
                <h3>ìƒˆ ì‚¬ìš©ì ìƒì„±</h3>
                <div style="background: #2d2d2d; padding: 20px; border-radius: 4px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì‚¬ìš©ì ID:</label>
                        <input type="text" id="newUserId" placeholder="ì‚¬ìš©ì ID" style="width: 100%; max-width: 300px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ë¹„ë°€ë²ˆí˜¸:</label>
                        <input type="password" id="newUserPassword" placeholder="ë¹„ë°€ë²ˆí˜¸" style="width: 100%; max-width: 300px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì´ë¦„:</label>
                        <input type="text" id="newUserFullName" placeholder="Full Name" style="width: 100%; max-width: 300px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì—­í• :</label>
                        <select id="newUserRole" style="width: 100%; max-width: 300px;">
                            <option value="user">User</option>
                            <option value="admin">Admin</option>
                        </select>
                    </div>
                    <button onclick="createNewUser()" style="padding: 10px 20px;">â• ì‚¬ìš©ì ìƒì„±</button>
                </div>
            </div>

            <!-- ì‚¬ìš©ì ìˆ˜ì • ëª¨ë‹¬ -->
            <div id="editUserModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
                <div style="background: #2d2d2d; padding: 30px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <h3 style="margin-top: 0;">ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •</h3>

                    <!-- ì›ë˜ user_idë¥¼ ì €ì¥í•˜ëŠ” hidden í•„ë“œ -->
                    <input type="hidden" id="editUserOriginalId">

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #999;">ì‚¬ìš©ì ID:</label>
                        <input type="text" id="editUserId" readonly style="width: 100%; background: #404040; color: #999; cursor: not-allowed;">
                        <small style="color: #666;">ë³´ì•ˆìƒì˜ ì´ìœ ë¡œ ì‚¬ìš©ì IDëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</small>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì´ë¦„:</label>
                        <input type="text" id="editUserFullName" placeholder="Full Name" style="width: 100%;">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ì—­í• :</label>
                        <select id="editUserRole" style="width: 100%;">
                            <option value="user">User</option>
                            <option value="admin">Admin</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">ìƒˆ ë¹„ë°€ë²ˆí˜¸ (ì„ íƒì‚¬í•­):</label>
                        <input type="password" id="editUserPassword" placeholder="ë³€ê²½í•˜ë ¤ë©´ ìƒˆ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" style="width: 100%;">
                        <small style="color: #999;">ë¹„ì›Œë‘ë©´ ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</small>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px;">
                        <button onclick="closeEditUserModal()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            ì·¨ì†Œ
                        </button>
                        <button onclick="updateUser()" style="padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            âœ… ì €ì¥
                        </button>
                    </div>
                </div>
            </div>

            <!-- ì‹œìŠ¤í…œ í†µê³„ -->
            <div style="margin-bottom: 30px;">
                <h3>ì‹œìŠ¤í…œ í†µê³„</h3>
                <div id="systemStats" style="background: #2d2d2d; padding: 20px; border-radius: 4px;">
                    <p style="color: #999;">ë¡œë”© ì¤‘...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('[SCRIPT START] JavaScript is loading...');

        // ============================================
        // ë‹¤êµ­ì–´ ì§€ì› ì‹œìŠ¤í…œ
        // ============================================

        // í˜„ì¬ ì–¸ì–´ (ê¸°ë³¸ê°’: í•œê¸€)
        let currentLanguage = localStorage.getItem('language') || 'ko';

        // ë‹¤êµ­ì–´ ë²ˆì—­ ë°ì´í„°
        const translations = {
            ko: {
                // ì•± íƒ€ì´í‹€ & íƒ­
                'app.title': 'ğŸ’§ K-Water ì–´ë…¸í…Œì´ì…˜ ì‹œìŠ¤í…œ',
                'tab.project': 'ğŸ“‚ í”„ë¡œì íŠ¸',
                'tab.annotation': 'ğŸ“¹ ì–´ë…¸í…Œì´ì…˜',
                'tab.dataset': 'ğŸ“¦ ë°ì´í„°ì…‹',
                'tab.training': 'ğŸš€ í•™ìŠµ',
                'tab.inference': 'ğŸ¬ ì¶”ë¡ ',
                'tab.admin': 'ğŸ‘¥ ê´€ë¦¬ì',

                // ê³µí†µ
                'common.close': 'âœ– ë‹«ê¸°',
                'common.save': 'ğŸ’¾ ì €ì¥',
                'common.delete': 'ğŸ—‘ ì‚­ì œ',
                'common.edit': 'âœï¸ í¸ì§‘',
                'common.add': 'â• ì¶”ê°€',
                'common.cancel': 'ì·¨ì†Œ',
                'common.settings': 'âš™ï¸ ì„¤ì •',
                'common.refresh': 'ğŸ”„ ìƒˆë¡œê³ ì¹¨',

                // í”„ë¡œì íŠ¸
                'project.title': 'í”„ë¡œì íŠ¸ ê´€ë¦¬',
                'project.current': 'í˜„ì¬ í”„ë¡œì íŠ¸',
                'project.createNew': 'ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±',
                'project.create': 'â• í”„ë¡œì íŠ¸ ìƒì„±',
                'project.name': 'í”„ë¡œì íŠ¸ ì´ë¦„',
                'project.worker': 'ì‘ì—…ì ì´ë¦„',
                'project.videos': 'í”„ë¡œì íŠ¸ ë¹„ë””ì˜¤',
                'project.addVideo': 'â• ë¹„ë””ì˜¤ ì¶”ê°€',
                'project.noVideos': 'ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.',
                'project.list': 'í”„ë¡œì íŠ¸ ëª©ë¡',
                'project.loading': 'í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...',
                'project.namePlaceholder': 'í”„ë¡œì íŠ¸ ì´ë¦„ (í•„ìˆ˜)',
                'project.workerPlaceholder': 'ì‘ì—…ì ì´ë¦„ (ì„ íƒ)',

                // ì–´ë…¸í…Œì´ì…˜
                'annotation.title': 'ë¹„ë””ì˜¤ ì–´ë…¸í…Œì´ì…˜',
                'annotation.help': 'ë„ì›€ë§',
                'annotation.project': 'í”„ë¡œì íŠ¸',
                'annotation.video': 'ë¹„ë””ì˜¤',
                'annotation.noProject': 'í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
                'annotation.noVideo': 'ë¹„ë””ì˜¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
                'annotation.aiStatus': 'AI ìƒíƒœ',
                'annotation.checking': 'í™•ì¸ ì¤‘...',
                'annotation.autoInference': 'ìë™ ì¶”ë¡  í™œì„±í™”',
                'annotation.labelSelection': 'ë¼ë²¨ ì„ íƒ',
                'annotation.selectProject': 'í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                'annotation.drawingMode': 'ê·¸ë¦¬ê¸° ëª¨ë“œ',
                'annotation.manualPolygon': 'ğŸ–Šï¸ ìˆ˜ë™ í´ë¦¬ê³¤ (OFF)',
                'annotation.annotations': 'ì–´ë…¸í…Œì´ì…˜',
                'annotation.videoPlayer': 'ë¹„ë””ì˜¤ í”Œë ˆì´ì–´',
                'annotation.currentFrame': 'í˜„ì¬ í”„ë ˆì„',
                'annotation.noAnnotations': 'ì–´ë…¸í…Œì´ì…˜ ì—†ìŒ',
                'annotation.saveFrame': 'ğŸ’¾ í”„ë ˆì„ ì €ì¥',
                'annotation.clearFrame': 'í”„ë ˆì„ ì§€ìš°ê¸°',
                'annotation.statistics': 'í†µê³„',
                'annotation.noSavedAnnotations': 'ì €ì¥ëœ ì–´ë…¸í…Œì´ì…˜ ì—†ìŒ',
                'annotation.comment': 'ì½”ë©˜íŠ¸',
                'annotation.selectAnnotationForComment': 'ì½”ë©˜íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ì–´ë…¸í…Œì´ì…˜ì„ ì„ íƒí•˜ì„¸ìš”',
                'annotation.saveComment': 'ğŸ’¬ ì½”ë©˜íŠ¸ ì €ì¥',
                'annotation.play': 'â–¶ ì¬ìƒ',
                'annotation.prev': 'â—€ ì´ì „',
                'annotation.next': 'ë‹¤ìŒ â–¶',
                'annotation.skip15Back': 'âª -15 Frame',
                'annotation.skip15Forward': '+15 Frame â©',
                'annotation.speed': 'ì†ë„:',

                // ë„ì›€ë§
                'help.basicUsage': 'ê¸°ë³¸ ì‚¬ìš©ë²•',
                'help.step1': 'í”„ë¡œì íŠ¸ íƒ­ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ì„ íƒí•˜ì„¸ìš”.',
                'help.step2': 'ë¹„ë””ì˜¤ë¥¼ ì¶”ê°€í•˜ê³  ì–´ë…¸í…Œì´ì…˜ íƒ­ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”.',
                'help.step3': 'ì™¼ìª½ íŒ¨ë„ì—ì„œ ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”.',
                'help.step4': 'AI ì¶”ë¡  ê²°ê³¼ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ìˆ˜ë™ìœ¼ë¡œ í´ë¦¬ê³¤ì„ ê·¸ë¦¬ì„¸ìš”.',
                'help.step5': 'ì™„ë£Œí•œ í”„ë ˆì„ì€ "ğŸ’¾ í”„ë ˆì„ ì €ì¥" ë²„íŠ¼ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”.',
                'help.shortcuts': 'ë‹¨ì¶•í‚¤',
                'help.key': 'í‚¤',
                'help.action': 'ë™ì‘',
                'help.playPause': 'ì¬ìƒ / ì¼ì‹œì •ì§€',
                'help.prevFrame': 'ì´ì „ í”„ë ˆì„',
                'help.nextFrame': 'ë‹¤ìŒ í”„ë ˆì„',
                'help.saveFrame': 'í˜„ì¬ í”„ë ˆì„ ì €ì¥',
                'help.deleteAnnotation': 'ì„ íƒí•œ ì–´ë…¸í…Œì´ì…˜ ì‚­ì œ',
                'help.cancelDrawing': 'í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ì·¨ì†Œ',
                'help.drawingModes': 'ê·¸ë¦¬ê¸° ëª¨ë“œ',
                'help.aiMode': 'ğŸ¤– AI ìë™ ì¶”ë¡ ',
                'help.aiModeDesc': 'í”„ë ˆì„ ì´ë™ ì‹œ ìë™ìœ¼ë¡œ AIê°€ ì˜ì—­ì„ ê°ì§€í•˜ì—¬ í‘œì‹œí•©ë‹ˆë‹¤.',
                'help.manualMode': 'âœï¸ ìˆ˜ë™ í´ë¦¬ê³¤',
                'help.manualModeDesc': 'í´ë¦­í•˜ì—¬ ì ì„ ì°ê³  í´ë¦¬ê³¤ì„ ê·¸ë¦½ë‹ˆë‹¤. ë”ë¸”í´ë¦­ ë˜ëŠ” ì²« ì  í´ë¦­ìœ¼ë¡œ ì™„ë£Œí•©ë‹ˆë‹¤.',
                'help.crosshairMode': 'â• ì‹­ìì„ ',
                'help.crosshairModeDesc': 'ì •í™•í•œ ìœ„ì¹˜ íŒŒì•…ì„ ìœ„í•œ ì‹­ìì„  ê°€ì´ë“œë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.',
                'help.tips': 'ìœ ìš©í•œ íŒ',
                'help.tip1': 'AI ì¶”ë¡  ê²°ê³¼ê°€ ë¶€ì •í™•í•˜ë©´ ìˆ˜ë™ìœ¼ë¡œ ìˆ˜ì •í•˜ê±°ë‚˜ ë‹¤ì‹œ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'help.tip2': 'í”„ë ˆì„ì„ ì €ì¥í•˜ì§€ ì•Šìœ¼ë©´ ì‘ì—… ë‚´ìš©ì´ ì†ì‹¤ë©ë‹ˆë‹¤.',
                'help.tip3': 'ì—¬ëŸ¬ ê°œì˜ ë¹„ë””ì˜¤ íŒŒì¼ì„ í•œ ë²ˆì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (Ctrl/Cmd í´ë¦­).',
                'help.tip4': 'í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ í´ë˜ìŠ¤(ë¼ë²¨)ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'help.tip5': 'í†µê³„ íŒ¨ë„ì—ì„œ ì „ì²´ ì‘ì—… ì§„í–‰ë¥ ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',

                // ë°ì´í„°ì…‹
                'dataset.title': 'ë°ì´í„°ì…‹ ë¹Œë”',
                'dataset.projectInfo': 'í”„ë¡œì íŠ¸ ì •ë³´',
                'dataset.noProject': 'í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
                'dataset.selectVideos': 'ë¹„ë””ì˜¤ ì„ íƒ',
                'dataset.selectProjectFirst': 'í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.',
                'dataset.selectAll': 'ì „ì²´ ì„ íƒ',
                'dataset.deselectAll': 'ì „ì²´ í•´ì œ',
                'dataset.settings': 'ë°ì´í„°ì…‹ ì„¤ì •',
                'dataset.outputDir': 'ì¶œë ¥ ë””ë ‰í† ë¦¬:',
                'dataset.splitRatio': 'Train/Val/Test ë¹„ìœ¨:',
                'dataset.augmentation': 'Augmentation ë°°ìˆ˜:',
                'dataset.format': 'ë°ì´í„°ì…‹ í˜•ì‹:',
                'dataset.build': 'ğŸš€ ë°ì´í„°ì…‹ ë¹Œë“œ',
                'dataset.exportSegFormer': 'ğŸ¯ SegFormer ë‚´ë³´ë‚´ê¸°',
                'dataset.exportYOLO': 'ğŸ“¦ YOLO ë‚´ë³´ë‚´ê¸°',
                'dataset.buildLog': 'ë¹Œë“œ ë¡œê·¸',
                'dataset.ready': 'ë°ì´í„°ì…‹ ë¹Œë“œ ì¤€ë¹„ ì™„ë£Œ...',

                // í•™ìŠµ
                'training.title': 'ëª¨ë¸ í•™ìŠµ',
                'training.modelType': 'ëª¨ë¸ íƒ€ì…',
                'training.dataset': 'ë°ì´í„°ì…‹',
                'training.browse': 'ì°¾ì•„ë³´ê¸°...',
                'training.settings': 'í•™ìŠµ ì„¤ì •',
                'training.outputDir': 'ì¶œë ¥ ë””ë ‰í† ë¦¬:',
                'training.epochs': 'Epochs:',
                'training.batchSize': 'Batch Size:',
                'training.learningRate': 'Learning Rate:',
                'training.evaluate': 'Test setì—ì„œ í‰ê°€',
                'training.start': 'â–¶ í•™ìŠµ ì‹œì‘',
                'training.stop': 'â¹ ì¤‘ì§€',
                'training.log': 'í•™ìŠµ ë¡œê·¸',
                'training.ready': 'í•™ìŠµ ì‹œì‘ ì¤€ë¹„ ì™„ë£Œ...',

                // ì¶”ë¡ 
                'inference.title': 'ë¹„ë””ì˜¤ ì¶”ë¡ ',
                'inference.settings': 'ì¶”ë¡  ì„¤ì •',
                'inference.modelType': 'ëª¨ë¸ íƒ€ì…',
                'inference.modelFile': 'ëª¨ë¸ íŒŒì¼',
                'inference.modelPath': 'ëª¨ë¸ ê²½ë¡œ',
                'inference.videoFile': 'ë¹„ë””ì˜¤ íŒŒì¼',
                'inference.videoPath': 'ë¹„ë””ì˜¤ ê²½ë¡œ',
                'inference.outputDir': 'ì¶œë ¥ ë””ë ‰í† ë¦¬',
                'inference.confidence': 'Confidence ì„ê³„ê°’',
                'inference.start': 'â–¶ï¸ ì¶”ë¡  ì‹œì‘',
                'inference.cancel': 'âŒ ì·¨ì†Œ',
                'inference.results': 'ğŸ¥ ì‹¤ì‹œê°„ ì¶”ë¡  ê²°ê³¼',
                'inference.progress': 'ì§„í–‰ ìƒí™©',
                'inference.preparing': 'ì¤€ë¹„ ì¤‘...'
            },
            en: {
                // App Title & Tabs
                'app.title': 'ğŸ’§ K-Water Annotation System',
                'tab.project': 'ğŸ“‚ Project',
                'tab.annotation': 'ğŸ“¹ Annotation',
                'tab.dataset': 'ğŸ“¦ Dataset',
                'tab.training': 'ğŸš€ Training',
                'tab.inference': 'ğŸ¬ Inference',
                'tab.admin': 'ğŸ‘¥ Admin',

                // Common
                'common.close': 'âœ– Close',
                'common.save': 'ğŸ’¾ Save',
                'common.delete': 'ğŸ—‘ Delete',
                'common.edit': 'âœï¸ Edit',
                'common.add': 'â• Add',
                'common.cancel': 'Cancel',
                'common.settings': 'âš™ï¸ Settings',
                'common.refresh': 'ğŸ”„ Refresh',

                // Project
                'project.title': 'Project Management',
                'project.current': 'Current Project',
                'project.createNew': 'Create New Project',
                'project.create': 'â• Create Project',
                'project.name': 'Project Name',
                'project.worker': 'Worker Name',
                'project.videos': 'Project Videos',
                'project.addVideo': 'â• Add Video',
                'project.noVideos': 'No videos available.',
                'project.list': 'Project List',
                'project.loading': 'Loading project list...',
                'project.namePlaceholder': 'Project Name (Required)',
                'project.workerPlaceholder': 'Worker Name (Optional)',

                // Annotation
                'annotation.title': 'Video Annotation',
                'annotation.help': 'Help',
                'annotation.project': 'Project',
                'annotation.video': 'Video',
                'annotation.noProject': 'No project selected',
                'annotation.noVideo': 'No video selected',
                'annotation.aiStatus': 'AI Status',
                'annotation.checking': 'Checking...',
                'annotation.autoInference': 'Auto-inference enabled',
                'annotation.labelSelection': 'Label Selection',
                'annotation.selectProject': 'Select a project',
                'annotation.drawingMode': 'Drawing Mode',
                'annotation.manualPolygon': 'ğŸ–Šï¸ Manual Polygon (OFF)',
                'annotation.annotations': 'Annotations',
                'annotation.videoPlayer': 'Video Player',
                'annotation.currentFrame': 'Current Frame',
                'annotation.noAnnotations': 'No annotations',
                'annotation.saveFrame': 'ğŸ’¾ Save Frame',
                'annotation.clearFrame': 'Clear Frame',
                'annotation.statistics': 'Statistics',
                'annotation.noSavedAnnotations': 'No saved annotations',
                'annotation.comment': 'Comment',
                'annotation.selectAnnotationForComment': 'Select an annotation to add a comment',
                'annotation.saveComment': 'ğŸ’¬ Save Comment',
                'annotation.play': 'â–¶ Play',
                'annotation.prev': 'â—€ Prev',
                'annotation.next': 'Next â–¶',
                'annotation.skip15Back': 'âª -15s',
                'annotation.skip15Forward': '+15s â©',
                'annotation.speed': 'Speed:',

                // Help
                'help.basicUsage': 'Basic Usage',
                'help.step1': 'Create or select a project from the Project tab.',
                'help.step2': 'Add videos and navigate to the Annotation tab.',
                'help.step3': 'Select a label from the left panel.',
                'help.step4': 'Review AI inference results or manually draw polygons.',
                'help.step5': 'Save completed frames using the "ğŸ’¾ Save Frame" button.',
                'help.shortcuts': 'Keyboard Shortcuts',
                'help.key': 'Key',
                'help.action': 'Action',
                'help.playPause': 'Play / Pause',
                'help.prevFrame': 'Previous Frame',
                'help.nextFrame': 'Next Frame',
                'help.saveFrame': 'Save Current Frame',
                'help.deleteAnnotation': 'Delete Selected Annotation',
                'help.cancelDrawing': 'Cancel Polygon Drawing',
                'help.drawingModes': 'Drawing Modes',
                'help.aiMode': 'ğŸ¤– AI Auto-Inference',
                'help.aiModeDesc': 'AI automatically detects and displays regions when navigating frames.',
                'help.manualMode': 'âœï¸ Manual Polygon',
                'help.manualModeDesc': 'Click to place points and draw polygons. Double-click or click first point to complete.',
                'help.crosshairMode': 'â• Crosshair',
                'help.crosshairModeDesc': 'Display crosshair guide for precise positioning.',
                'help.tips': 'Useful Tips',
                'help.tip1': 'If AI inference results are inaccurate, you can manually correct or redraw.',
                'help.tip2': 'Unsaved frames will lose their annotation data.',
                'help.tip3': 'You can add multiple video files at once (Ctrl/Cmd + Click).',
                'help.tip4': 'Add or modify classes (labels) in Project Settings.',
                'help.tip5': 'Check overall progress in the Statistics panel.',

                // Dataset
                'dataset.title': 'Dataset Builder',
                'dataset.projectInfo': 'Project Information',
                'dataset.noProject': 'No project selected.',
                'dataset.selectVideos': 'Select Videos',
                'dataset.selectProjectFirst': 'Please select a project first.',
                'dataset.selectAll': 'Select All',
                'dataset.deselectAll': 'Deselect All',
                'dataset.settings': 'Dataset Settings',
                'dataset.outputDir': 'Output Directory:',
                'dataset.splitRatio': 'Train/Val/Test Ratio:',
                'dataset.augmentation': 'Augmentation Multiplier:',
                'dataset.format': 'Dataset Format:',
                'dataset.build': 'ğŸš€ Build Dataset',
                'dataset.exportSegFormer': 'ğŸ¯ Export SegFormer',
                'dataset.exportYOLO': 'ğŸ“¦ Export YOLO',
                'dataset.buildLog': 'Build Log',
                'dataset.ready': 'Ready to build dataset...',

                // Training
                'training.title': 'Model Training',
                'training.modelType': 'Model Type',
                'training.dataset': 'Dataset',
                'training.browse': 'Browse...',
                'training.settings': 'Training Settings',
                'training.outputDir': 'Output Directory:',
                'training.epochs': 'Epochs:',
                'training.batchSize': 'Batch Size:',
                'training.learningRate': 'Learning Rate:',
                'training.evaluate': 'Evaluate on test set',
                'training.start': 'â–¶ Start Training',
                'training.stop': 'â¹ Stop',
                'training.log': 'Training Log',
                'training.ready': 'Ready to start training...',

                // Inference
                'inference.title': 'Video Inference',
                'inference.settings': 'Inference Settings',
                'inference.modelType': 'Model Type',
                'inference.modelFile': 'Model File',
                'inference.modelPath': 'Model Path',
                'inference.videoFile': 'Video File',
                'inference.videoPath': 'Video Path',
                'inference.outputDir': 'Output Directory',
                'inference.confidence': 'Confidence Threshold',
                'inference.start': 'â–¶ï¸ Start Inference',
                'inference.cancel': 'âŒ Cancel',
                'inference.results': 'ğŸ¥ Real-time Inference Results',
                'inference.progress': 'Progress',
                'inference.preparing': 'Preparing...'
            }
        };

        // ì–¸ì–´ í† ê¸€ í•¨ìˆ˜
        function toggleLanguage() {
            const oldLang = currentLanguage;
            currentLanguage = currentLanguage === 'ko' ? 'en' : 'ko';
            localStorage.setItem('language', currentLanguage);
            console.log('[LANG] Language toggled:', oldLang, '->', currentLanguage);

            applyLanguage();

            // í† ê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
            const btn2 = document.getElementById('langToggleBtn2');
            if (btn2) {
                btn2.textContent = currentLanguage === 'ko' ? 'ğŸŒ EN' : 'ğŸŒ í•œê¸€';
            }

            // í´ë˜ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸ (í˜„ì¬ í”„ë¡œì íŠ¸ê°€ ìˆëŠ” ê²½ìš°)
            if (currentProject && currentProject.classes) {
                console.log('[LANG] Updating class displays for project:', currentProject.name);

                // ì„¤ì • ëª¨ë‹¬ í´ë˜ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸
                if (typeof updateSettingsClassList === 'function') {
                    updateSettingsClassList();
                }

                // ì–´ë…¸í…Œì´ì…˜ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                if (typeof updateAnnotationList === 'function') {
                    updateAnnotationList();
                }

                // Statistics í…Œì´ë¸” ì—…ë°ì´íŠ¸
                if (typeof updateStatistics === 'function') {
                    updateStatistics();
                }

                // ìº”ë²„ìŠ¤ì˜ ì–´ë…¸í…Œì´ì…˜ ë¼ë²¨ë„ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                if (typeof drawFrameWithMasks === 'function' && currentFrame !== null) {
                    drawFrameWithMasks();
                }
            } else {
                console.log('[LANG] No current project or classes');
            }
        }

        // ì–¸ì–´ ì ìš© í•¨ìˆ˜
        function applyLanguage() {
            // í…ìŠ¤íŠ¸ ë²ˆì—­
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = translations[currentLanguage][key];
                if (translation) {
                    element.textContent = translation;
                }
            });

            // Placeholder ë²ˆì—­
            const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
            placeholderElements.forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                const translation = translations[currentLanguage][key];
                if (translation) {
                    element.placeholder = translation;
                }
            });

            console.log('[I18N] Language applied:', currentLanguage);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì–¸ì–´ ì ìš©
        document.addEventListener('DOMContentLoaded', function() {
            applyLanguage();
            const btn2 = document.getElementById('langToggleBtn2');
            if (btn2) {
                btn2.textContent = currentLanguage === 'ko' ? 'ğŸŒ EN' : 'ğŸŒ í•œê¸€';
            }

            // í´ë¦¬ê³¤ ëª¨ë“œê°€ ê¸°ë³¸ê°’ì´ë¯€ë¡œ ì»¤ì„œ ìŠ¤íƒ€ì¼ ì ìš©
            const canvas = document.getElementById('videoCanvas');
            if (canvas) {
                canvas.classList.add('crosshair-cursor');
            }
        });

        // í´ë˜ìŠ¤ ì´ë¦„ í‘œì‹œìš© helper í•¨ìˆ˜ (ì–¸ì–´ì— ë”°ë¼ name/description ì„ íƒ)
        function getClassDisplayName(classObj) {
            // í•œêµ­ì–´ ëª¨ë“œ: ì„¤ëª…ì„ ë©”ì¸ìœ¼ë¡œ, ì´ë¦„ì„ ê´„í˜¸ ì•ˆì— (ì„¤ëª…ì´ ìˆì„ ê²½ìš°)
            // ì˜ì–´ ëª¨ë“œ: ì´ë¦„ë§Œ
            if (currentLanguage === 'ko' && classObj.description) {
                return `${classObj.description} (${classObj.name})`;
            } else {
                return classObj.name;
            }
        }

        // ìº”ë²„ìŠ¤ ë¼ë²¨ í‘œì‹œìš© helper í•¨ìˆ˜ (category nameì„ í˜„ì¬ ì–¸ì–´ì˜ í‘œì‹œëª…ìœ¼ë¡œ ë³€í™˜)
        function getDisplayLabel(categoryName) {
            if (!currentProject || !currentProject.classes) return categoryName;

            // í´ë˜ìŠ¤ ì°¾ê¸° (ë¬¸ìì—´ ë°°ì—´ì¼ ìˆ˜ë„ ìˆê³ , ê°ì²´ ë°°ì—´ì¼ ìˆ˜ë„ ìˆìŒ)
            const classObj = currentProject.classes.find(c => {
                if (typeof c === 'string') return c === categoryName;
                return c.name === categoryName;
            });

            if (!classObj) return categoryName;

            // ë¬¸ìì—´ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
            if (typeof classObj === 'string') return classObj;

            // ê°ì²´ë©´ ì–¸ì–´ì— ë”°ë¼ í‘œì‹œ
            return getClassDisplayName(classObj);
        }

        // ============================================
        // ì¸ì¦ ê´€ë¦¬
        // ============================================

        // ì„¸ì…˜ ID ì €ì¥/ê°€ì ¸ì˜¤ê¸°
        function getSessionId() {
            return localStorage.getItem('session_id');
        }

        function setSessionId(sessionId) {
            localStorage.setItem('session_id', sessionId);
            // Also set as cookie for video element authentication
            document.cookie = `session_id=${sessionId}; path=/; SameSite=Strict`;
        }

        function clearSessionId() {
            localStorage.removeItem('session_id');
            // Also clear cookie
            document.cookie = 'session_id=; path=/; expires=Thu, 01 Jan 1970 00:00:00 UTC; SameSite=Strict';
        }

        // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì €ì¥/ê°€ì ¸ì˜¤ê¸°
        function getCurrentUser() {
            const userJson = localStorage.getItem('current_user');
            return userJson ? JSON.parse(userJson) : null;
        }

        function setCurrentUser(user) {
            localStorage.setItem('current_user', JSON.stringify(user));
        }

        function clearCurrentUser() {
            localStorage.removeItem('current_user');
        }

        // ë¡œê·¸ì¸ ì²˜ë¦¬
        async function handleLogin(event) {
            event.preventDefault();

            const userId = document.getElementById('loginUserId').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            try {
                const response = await fetch(API_BASE_URL + '/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        password: password
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // ì„¸ì…˜ IDì™€ ì‚¬ìš©ì ì •ë³´ ì €ì¥
                    setSessionId(data.session_id);
                    setCurrentUser(data.user);

                    // ë¡œê·¸ì¸ ì„±ê³µ
                    console.log('[AUTH] Login successful:', data.user);
                    showLoginSuccess();
                } else {
                    // ë¡œê·¸ì¸ ì‹¤íŒ¨
                    errorDiv.textContent = data.error || 'ë¡œê·¸ì¸ ì‹¤íŒ¨';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('[AUTH] Login error:', error);
                errorDiv.textContent = 'ì„œë²„ ì—°ê²° ì˜¤ë¥˜: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
        async function handleLogout() {
            const sessionId = getSessionId();

            if (sessionId) {
                try {
                    await fetch(API_BASE_URL + '/api/auth/logout', {
                        method: 'POST',
                        headers: {
                            'X-Session-ID': sessionId
                        }
                    });
                } catch (error) {
                    console.error('[AUTH] Logout error:', error);
                }
            }

            // ë¡œì»¬ ë°ì´í„° ì •ë¦¬
            clearSessionId();
            clearCurrentUser();

            // ë¡œê·¸ì¸ í™”ë©´ í‘œì‹œ
            showLoginScreen();
        }

        // ë¡œê·¸ì¸ ì„±ê³µ í›„ UI ì—…ë°ì´íŠ¸
        function showLoginSuccess() {
            const user = getCurrentUser();
            console.log('[LOGIN SUCCESS] Current user:', user);
            console.log('[LOGIN SUCCESS] User role:', user ? user.role : 'undefined');

            if (!user) {
                console.error('[LOGIN SUCCESS] No user data found!');
                return;
            }

            // ë¡œê·¸ì¸ í™”ë©´ ìˆ¨ê¸°ê¸°
            document.getElementById('loginOverlay').style.display = 'none';

            // ì‚¬ìš©ì ì •ë³´ í‘œì‹œ
            document.getElementById('userName').textContent = user.full_name || user.user_id;
            document.getElementById('userInfo').style.display = 'flex';

            // ê´€ë¦¬ì íƒ­ í‘œì‹œ (ê´€ë¦¬ìë§Œ)
            const adminTab = document.getElementById('adminTab');
            console.log('[LOGIN SUCCESS] Admin tab element:', adminTab);

            if (user.role === 'admin') {
                console.log('[LOGIN SUCCESS] User is admin - showing admin tab');
                adminTab.style.display = 'block';
            } else {
                console.log('[LOGIN SUCCESS] User is NOT admin - hiding admin tab');
                adminTab.style.display = 'none';
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì´ˆê¸°í™” (ìƒˆë¡œìš´ ì‚¬ìš©ìì´ë¯€ë¡œ)
            currentProject = null;

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            const currentProjectSection = document.getElementById('currentProjectSection');
            if (currentProjectSection) {
                currentProjectSection.style.display = 'none';
            }

            const currentProjectDiv = document.getElementById('currentProject');
            if (currentProjectDiv) {
                currentProjectDiv.innerHTML = '<p style="color: #999;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
            }

            // í”„ë¡œì íŠ¸ íƒ­ìœ¼ë¡œ ì´ë™
            console.log('[LOGIN SUCCESS] Switching to project tab');
            showTab('project');

            // ê´€ë¦¬ìì™€ ì¼ë°˜ ì‚¬ìš©ì ëª¨ë‘ í”„ë¡œì íŠ¸ ëª©ë¡ í‘œì‹œ
            console.log('[LOGIN SUCCESS] Loading projects for user:', user.user_id);
            loadProjects();  // í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ (ê´€ë¦¬ìëŠ” ëª¨ë“  í”„ë¡œì íŠ¸, ì¼ë°˜ ì‚¬ìš©ìëŠ” ìì‹ ì˜ í”„ë¡œì íŠ¸)
        }

        // ë¡œê·¸ì¸ í™”ë©´ í‘œì‹œ
        function showLoginScreen() {
            document.getElementById('loginOverlay').style.display = 'flex';
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('loginError').style.display = 'none';
            document.getElementById('loginForm').reset();

            // ë¡œê·¸ì•„ì›ƒ ì‹œ ê´€ë¦¬ì íƒ­ ìˆ¨ê¸°ê¸°
            document.getElementById('adminTab').style.display = 'none';

            // í”„ë¡œì íŠ¸ ëª©ë¡ í´ë¦¬ì–´
            const myProjectList = document.getElementById('myProjectList');
            const sharedProjectList = document.getElementById('sharedProjectList');
            if (myProjectList) {
                myProjectList.innerHTML = '<p style="color: #999;">ë¡œê·¸ì¸ í›„ í™•ì¸í•˜ì„¸ìš”.</p>';
            }
            if (sharedProjectList) {
                sharedProjectList.innerHTML = '<p style="color: #999;">ë¡œê·¸ì¸ í›„ í™•ì¸í•˜ì„¸ìš”.</p>';
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ í´ë¦¬ì–´
            currentProject = null;

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            const currentProjectSection = document.getElementById('currentProjectSection');
            if (currentProjectSection) {
                currentProjectSection.style.display = 'none';
            }

            const currentProjectDiv = document.getElementById('currentProject');
            if (currentProjectDiv) {
                currentProjectDiv.innerHTML = '<p style="color: #999;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
            }

            // í”„ë¡œì íŠ¸ íƒ­ìœ¼ë¡œ ì „í™˜ (ê¸°ë³¸ íƒ­)
            showTab('project');
        }

        // ì„¸ì…˜ ê²€ì¦
        async function validateSession() {
            const sessionId = getSessionId();

            if (!sessionId) {
                showLoginScreen();
                return false;
            }

            try {
                const response = await fetch(API_BASE_URL + '/api/auth/me', {
                    headers: {
                        'X-Session-ID': sessionId
                    }
                });

                const data = await response.json();

                if (data.success) {
                    // ì„¸ì…˜ ìœ íš¨ - ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
                    setCurrentUser(data.user);
                    showLoginSuccess();
                    return true;
                } else {
                    // ì„¸ì…˜ ë¬´íš¨
                    clearSessionId();
                    clearCurrentUser();
                    showLoginScreen();
                    return false;
                }
            } catch (error) {
                console.error('[AUTH] Session validation error:', error);
                showLoginScreen();
                return false;
            }
        }

        // API ìš”ì²­ í—¬í¼ (ìë™ìœ¼ë¡œ ì„¸ì…˜ ID í¬í•¨)
        async function authFetch(url, options = {}) {
            console.log('[authFetch] Starting request to:', url);
            const sessionId = getSessionId();

            if (!sessionId) {
                console.error('[authFetch] No session ID found');
                showLoginScreen();
                throw new Error('Not authenticated');
            }

            options.headers = {
                ...options.headers,
                'X-Session-ID': sessionId
            };

            console.log('[authFetch] Fetching:', API_BASE_URL + url);
            const response = await fetch(API_BASE_URL + url, options);
            console.log('[authFetch] Response received:', response.status, response.statusText);

            // 401 Unauthorized ì²˜ë¦¬
            if (response.status === 401) {
                console.warn('[AUTH] Session expired or invalid');
                clearSessionId();
                clearCurrentUser();
                showLoginScreen();
                throw new Error('Session expired');
            }

            return response;
        }

        function showTab(tabName) {
            // ëª¨ë“  íƒ­ ì»¨í…ì¸  ë¹„í™œì„±í™”
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');

            // ì„ íƒëœ íƒ­ ì»¨í…ì¸  í™œì„±í™”
            document.getElementById(tabName + '-tab').style.display = 'block';

            // íƒ­ ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

            // í´ë¦­ ì´ë²¤íŠ¸ë¡œ í˜¸ì¶œëœ ê²½ìš° (event targetì´ íƒ­ ë²„íŠ¼ì¸ ê²½ìš°ë§Œ)
            if (window.event && window.event.target && window.event.target.classList && window.event.target.classList.contains('tab')) {
                window.event.target.classList.add('active');
            } else {
                // í”„ë¡œê·¸ë¨ì ìœ¼ë¡œ í˜¸ì¶œëœ ê²½ìš° - íƒ­ ì´ë¦„ìœ¼ë¡œ ë²„íŠ¼ ì°¾ê¸°
                const tabButtons = document.querySelectorAll('.tab');
                const tabIndex = {'project': 0, 'annotation': 1, 'dataset': 2, 'training': 3, 'inference': 4, 'admin': 5};
                if (tabIndex[tabName] !== undefined && tabButtons[tabIndex[tabName]]) {
                    tabButtons[tabIndex[tabName]].classList.add('active');
                }
            }

            // ê´€ë¦¬ì íƒ­ í´ë¦­ ì‹œ ë°ì´í„° ë¡œë“œ
            if (tabName === 'admin') {
                loadUsers();
                loadSystemStats();
            }

            // í”„ë¡œì íŠ¸ íƒ­ í´ë¦­ ì‹œ ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ ë° ì „ì²´ ì–´ë…¸í…Œì´ì…˜ ëŒ€ì‹œë³´ë“œ ìë™ ë¡œë“œ
            if (tabName === 'project') {
                loadCommentsDashboard();
                loadGlobalAnnotationDashboard();
            }

            // ë°ì´í„°ì…‹ íƒ­ í´ë¦­ ì‹œ í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
            if (tabName === 'dataset') {
                initializeDatasetTab();
            }

            // ì¶”ë¡  íƒ­ í´ë¦­ ì‹œ í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
            if (tabName === 'inference') {
                initInferenceTab();
            }

            // ê´€ë¦¬ì ì‚¬ìš©ìê°€ í”„ë¡œì íŠ¸/ì–´ë…¸í…Œì´ì…˜ íƒ­ í´ë¦­ ì‹œ ê´€ë¦¬ììš© ë°ì´í„° ë¡œë“œ
            const user = getCurrentUser();
            if (user && user.role === 'admin') {
                if (tabName === 'project') {
                    loadAdminCompletedVideos();
                } else if (tabName === 'annotation') {
                    loadAdminAnnotationStats();
                } else if (tabName === 'dataset') {
                    loadAdminDashboard();
                }
            }

            // íˆìŠ¤í† ë¦¬ì— íƒ­ ì „í™˜ ê¸°ë¡
            pushToHistory('tab', { tab: tabName }, `Tab: ${tabName}`);
        }

        // API Base URL ì„¤ì •
        // Electron (file://): localhost:5003 ì‚¬ìš©
        // ì›¹ ë¸Œë¼ìš°ì €: í˜„ì¬ ì„œë²„ ì£¼ì†Œ ì‚¬ìš© (ìë™ìœ¼ë¡œ localhost ë˜ëŠ” ì™¸ë¶€ IP)
        const isElectron = (window.location.protocol === 'file:');
        const API_BASE_URL = isElectron
            ? 'http://localhost:5003'
            : `${window.location.protocol}//${window.location.host}`;

        console.log('[DEBUG] API_BASE_URL:', API_BASE_URL);
        console.log('[DEBUG] Location:', window.location.protocol, window.location.host);

        async function testPython() {
            try {
                const response = await fetch(API_BASE_URL + '/api/test');
                const data = await response.json();
                document.getElementById('status').innerHTML =
                    '<strong>[OK] Python Backend Connected!</strong><br>' +
                    'Message: ' + data.message + '<br>' +
                    'Python Version: ' + data.python_version;
            } catch (error) {
                document.getElementById('status').innerHTML =
                    '<strong>[ERROR] Error:</strong> ' + error.message + '<br>' +
                    'Check if backend server is running (python backend.py)';
            }
        }

        // ì „ì—­ ë³€ìˆ˜
        let currentProject = null;
        let selectedStatsFrame = null;  // í†µê³„ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì„ íƒëœ í”„ë ˆì„
        let currentJobId = null;  // í˜„ì¬ ì¶”ë¡  ì‘ì—… ID
        let progressInterval = null;  // ì§„í–‰ ìƒí™© í´ë§ ì¸í„°ë²Œ
        let previewInterval = null;  // ë¯¸ë¦¬ë³´ê¸° í”„ë ˆì„ í´ë§ ì¸í„°ë²Œ
        let inferencePreviewCanvas = null;  // ì¶”ë¡  ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤
        let inferencePreviewCtx = null;  // ì¶”ë¡  ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸

        // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ìƒíƒœ
        let playerState = {
            isPlaying: false,
            currentFrameIndex: 0,
            totalFrames: 0,
            processedFrames: 0,
            fps: 30,
            playbackSpeed: 1.0,
            playbackInterval: null,
            frameCache: new Map()  // í”„ë ˆì„ ì´ë¯¸ì§€ ìºì‹œ
        };

        // ============================================
        // ë¸Œë¼ìš°ì € ë’¤ë¡œê°€ê¸° ê¸°ëŠ¥ (History API)
        // ============================================

        let isRestoringHistory = false;  // íˆìŠ¤í† ë¦¬ ë³µì› ì¤‘ì¸ì§€ ì—¬ë¶€ (ë¬´í•œ ë£¨í”„ ë°©ì§€)

        // í˜„ì¬ ìƒíƒœë¥¼ Historyì— í‘¸ì‹œ
        function pushToHistory(type, data, title) {
            if (isRestoringHistory) return;  // ë³µì› ì¤‘ì—ëŠ” ìƒˆ íˆìŠ¤í† ë¦¬ ì¶”ê°€í•˜ì§€ ì•ŠìŒ

            const state = {
                type: type,  // 'tab', 'project', 'video', 'frame'
                data: data,
                timestamp: Date.now()
            };

            // URL íŒŒë¼ë¯¸í„°ë¡œ ìƒíƒœ í‘œí˜„ (ì„ íƒì‚¬í•­)
            let url = window.location.pathname;
            if (type === 'tab') {
                url = `?tab=${data.tab}`;
            } else if (type === 'project') {
                url = `?tab=project&project=${encodeURIComponent(data.projectId)}`;
            } else if (type === 'video') {
                url = `?tab=annotation&project=${encodeURIComponent(data.projectId)}&video=${encodeURIComponent(data.videoId)}`;
            } else if (type === 'frame') {
                url = `?tab=annotation&project=${encodeURIComponent(data.projectId)}&video=${encodeURIComponent(data.videoId)}&frame=${data.frame}`;
            }

            history.pushState(state, title, url);
            console.log('[HISTORY] Pushed:', type, data);
        }

        // íˆìŠ¤í† ë¦¬ ìƒíƒœ ë³µì›
        async function restoreHistoryState(state) {
            if (!state) return;

            isRestoringHistory = true;  // ë³µì› ì¤‘ í”Œë˜ê·¸ ì„¤ì •
            console.log('[HISTORY] Restoring state:', state.type, state.data);

            try {
                if (state.type === 'tab') {
                    // íƒ­ ë³€ê²½
                    showTab(state.data.tab);

                } else if (state.type === 'project') {
                    // í”„ë¡œì íŠ¸ ì—´ê¸°
                    showTab('project');
                    await openProject(state.data.projectId);

                } else if (state.type === 'video') {
                    // ë¹„ë””ì˜¤ ì„ íƒ
                    showTab('annotation');
                    if (!currentProject || currentProject.id !== state.data.projectId) {
                        await openProject(state.data.projectId);
                    }
                    await startAnnotation(state.data.videoId);

                } else if (state.type === 'frame') {
                    // íŠ¹ì • í”„ë ˆì„ìœ¼ë¡œ ì´ë™
                    showTab('annotation');
                    if (!currentProject || currentProject.id !== state.data.projectId) {
                        await openProject(state.data.projectId);
                    }
                    if (currentVideoId !== state.data.videoId) {
                        await startAnnotation(state.data.videoId);
                    }
                    // í”„ë ˆì„ ë¡œë“œ ëŒ€ê¸° í›„ ì´ë™
                    await new Promise(resolve => setTimeout(resolve, 500));
                    if (state.data.frame !== undefined && state.data.frame !== null) {
                        currentFrame = state.data.frame;
                        await loadFrame(currentFrame);
                    }
                }
            } catch (error) {
                console.error('[HISTORY] Error restoring state:', error);
            } finally {
                isRestoringHistory = false;  // ë³µì› ì™„ë£Œ
            }
        }

        // ë¸Œë¼ìš°ì € ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬
        window.addEventListener('popstate', async (event) => {
            console.log('[HISTORY] Pop state event:', event.state);
            if (event.state) {
                await restoreHistoryState(event.state);
            }
        });

        // ============================================
        // ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ ê¸°ëŠ¥
        // ============================================

        // ë‹µê¸€ ë°ì´í„° ì €ì¥ (comment_id -> replies ë°°ì—´)
        const repliesData = new Map();

        // ì „ì—­ ë³€ìˆ˜ë¡œ ëª¨ë“  ì½”ë©˜íŠ¸ ì €ì¥
        let allComments = [];

        // í•„í„°ë§ëœ ì½”ë©˜íŠ¸ ì €ì¥ (ë‚´ë³´ë‚´ê¸°ìš©)
        let filteredComments = [];

        // ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ ìƒíƒœ (true: ë³´ì„, false: ìˆ¨ê¹€)
        let showAnnotations = true;

        // ì½”ë©˜íŠ¸ ëŒ€ì‹œë³´ë“œ ë¶ˆëŸ¬ì˜¤ê¸°
        async function loadCommentsDashboard() {
            const dashboard = document.getElementById('commentsDashboard');

            try {
                dashboard.innerHTML = '<span style="color: #888;">ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>';

                const response = await fetch(`${API_BASE_URL}/api/comments/all`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    allComments = data.comments || [];

                    // ë“œë¡­ë‹¤ìš´ ì˜µì…˜ ìƒì„±
                    populateCommentFilters();

                    // í•„í„° ì ìš© í›„ í‘œì‹œ
                    filterComments();
                } else {
                    dashboard.innerHTML = '<span style="color: #f44;">ì˜¤ë¥˜: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜') + '</span>';
                }
            } catch (error) {
                console.error('ì½”ë©˜íŠ¸ ë¡œë“œ ì˜¤ë¥˜:', error);
                dashboard.innerHTML = '<span style="color: #f44;">ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message + '</span>';
            }
        }

        // í•„í„° ë“œë¡­ë‹¤ìš´ ì˜µì…˜ ì±„ìš°ê¸°
        function populateCommentFilters() {
            // í”„ë¡œì íŠ¸ ëª©ë¡ ì¶”ì¶œ
            const projects = [...new Set(allComments.map(c => c.project_name))].sort();
            const projectSelect = document.getElementById('commentFilterProject');
            projectSelect.innerHTML = '<option value="">ëª¨ë“  í”„ë¡œì íŠ¸</option>';
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project;
                option.textContent = project;
                projectSelect.appendChild(option);
            });

            // ì‚¬ìš©ì ëª©ë¡ ì¶”ì¶œ
            const users = [...new Set(allComments.map(c => c.created_by))].sort();
            const userSelect = document.getElementById('commentFilterUser');
            userSelect.innerHTML = '<option value="">ëª¨ë“  ì‚¬ìš©ì</option>';
            users.forEach(user => {
                const option = document.createElement('option');
                option.value = user;
                option.textContent = user;
                userSelect.appendChild(option);
            });

            // ë¼ë²¨ ëª©ë¡ ì¶”ì¶œ
            const labels = [...new Set(allComments.map(c => c.label))].sort();
            const labelSelect = document.getElementById('commentFilterLabel');
            labelSelect.innerHTML = '<option value="">ëª¨ë“  ë¼ë²¨</option>';
            labels.forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                labelSelect.appendChild(option);
            });
        }

        // ì½”ë©˜íŠ¸ í•„í„°ë§ ë° í‘œì‹œ
        function filterComments() {
            const dashboard = document.getElementById('commentsDashboard');
            const projectFilter = document.getElementById('commentFilterProject')?.value || '';
            const userFilter = document.getElementById('commentFilterUser')?.value || '';
            const labelFilter = document.getElementById('commentFilterLabel')?.value || '';
            const statusFilter = document.getElementById('commentFilterStatus')?.value || '';
            const dateFrom = document.getElementById('commentFilterDateFrom')?.value || '';
            const dateTo = document.getElementById('commentFilterDateTo')?.value || '';
            const myOnly = document.getElementById('commentFilterMyOnly')?.checked || false;
            const sortBy = document.getElementById('commentSortBy')?.value || 'recent';

            // í˜„ì¬ ì‚¬ìš©ì ì •ë³´
            const currentUser = localStorage.getItem('username');

            // í•„í„° ì ìš©
            let filtered = allComments.filter(comment => {
                // í”„ë¡œì íŠ¸ í•„í„°
                const matchProject = !projectFilter || comment.project_name === projectFilter;

                // ì‚¬ìš©ì í•„í„°
                const matchUser = !userFilter || comment.created_by === userFilter;

                // ë¼ë²¨ í•„í„°
                const matchLabel = !labelFilter || comment.label === labelFilter;

                // ìƒíƒœ í•„í„°
                const matchStatus = !statusFilter || (comment.discussion_status || 'open') === statusFilter;

                // ë‚ ì§œ í•„í„°
                const commentDate = new Date(comment.modified_at || comment.created_at);
                const matchDateFrom = !dateFrom || commentDate >= new Date(dateFrom);
                const matchDateTo = !dateTo || commentDate <= new Date(dateTo + 'T23:59:59');

                // ë‚´ ì½”ë©˜íŠ¸ë§Œ ë³´ê¸°
                const matchOwner = !myOnly || comment.created_by === currentUser;

                return matchProject && matchUser && matchLabel && matchStatus &&
                       matchDateFrom && matchDateTo && matchOwner;
            });

            // ì •ë ¬
            if (sortBy === 'recent') {
                // ëŒ“ê¸€ ìˆ˜ì • ì‹œê°„(modified_at) ìš°ì„ , ì—†ìœ¼ë©´ ì–´ë…¸í…Œì´ì…˜ ìƒì„± ì‹œê°„(created_at) ì‚¬ìš©
                filtered.sort((a, b) => {
                    const timeA = a.modified_at || a.created_at || '';
                    const timeB = b.modified_at || b.created_at || '';
                    return timeB.localeCompare(timeA);
                });
            } else if (sortBy === 'project') {
                filtered.sort((a, b) => a.project_name.localeCompare(b.project_name));
            } else if (sortBy === 'user') {
                filtered.sort((a, b) => a.created_by.localeCompare(b.created_by));
            }

            // í•„í„°ë§ëœ ì½”ë©˜íŠ¸ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ (ë‚´ë³´ë‚´ê¸°ìš©)
            filteredComments = filtered;

            // í•„í„° ê²°ê³¼ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
            const countDiv = document.getElementById('commentFilterCount');
            if (countDiv) {
                const totalCount = allComments.length;
                const filteredCount = filtered.length;
                countDiv.innerHTML = `ì „ì²´: <strong>${totalCount}</strong>ê°œ / í‘œì‹œ: <strong style="color: #4a9eff;">${filteredCount}</strong>ê°œ`;
            }

            // í‘œì‹œ
            if (filtered.length === 0) {
                dashboard.innerHTML = '<span style="color: #888;">í‘œì‹œí•  ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</span>';
                return;
            }

            // Lazy loadingì„ ìœ„í•œ Intersection Observer ì„¤ì •
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        const dataSrc = img.getAttribute('data-src');
                        if (dataSrc) {
                            img.src = dataSrc;
                            img.removeAttribute('data-src');
                            observer.unobserve(img);

                            // ì´ë¯¸ì§€ ë¡œë“œ í›„ ì–´ë…¸í…Œì´ì…˜ ê·¸ë¦¬ê¸°
                            const commentIndex = parseInt(img.getAttribute('data-comment-index'));
                            if (!isNaN(commentIndex)) {
                                img.addEventListener('load', () => {
                                    drawAnnotationOnCanvas(allComments[commentIndex], commentIndex);
                                }, { once: true });
                            }
                        }
                    }
                });
            }, {
                rootMargin: '50px' // í™”ë©´ ê²½ê³„ 50px ì „ì— ë¡œë“œ ì‹œì‘
            });

            dashboard.innerHTML = filtered.map((comment, displayIndex) => {
                // ì›ë³¸ allComments ë°°ì—´ì—ì„œì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ì°¾ê¸°
                const actualIndex = allComments.findIndex(c => c.comment_id === comment.comment_id);
                const index = actualIndex; // ì´í›„ ì½”ë“œì—ì„œ index ì‚¬ìš©

                const statusColors = {
                    'open': '#4a9eff',
                    'resolved': '#28a745',
                    'pending': '#ffa500'
                };
                const statusLabels = {
                    'open': 'ì§„í–‰ì¤‘',
                    'resolved': 'í•´ê²°ë¨',
                    'pending': 'ë³´ë¥˜'
                };
                const statusColor = statusColors[comment.discussion_status || 'open'];
                const statusLabel = statusLabels[comment.discussion_status || 'open'];

                return `
                <div id="comment-card-${index}" style="background: #2a2a2a; border-left: 3px solid ${statusColor}; padding: 12px; margin-bottom: 10px; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <div>
                            <span style="color: #4a9eff; font-weight: bold;">${comment.project_name}</span>
                            <span style="color: #888; margin-left: 10px;">í”„ë ˆì„: ${comment.frame}</span>
                            <span style="background: ${statusColor}; color: white; padding: 2px 6px; margin-left: 10px; border-radius: 3px; font-size: 11px;">${statusLabel}</span>
                        </div>
                        <div style="font-size: 11px; color: #888;">
                            ${comment.created_at ? new Date(comment.created_at).toLocaleString() : ''}
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <span style="background: #1a1a1a; padding: 2px 8px; border-radius: 3px; font-size: 12px; color: #ffa500;">${comment.label}</span>
                        <span style="color: #888; margin-left: 10px; font-size: 12px;">ì‘ì„±ì: ${comment.created_by}</span>
                    </div>
                    <div style="background: #1a1a1a; padding: 8px; border-radius: 3px; margin-bottom: 8px; white-space: pre-wrap;">
                        ${comment.comment}
                    </div>

                    <!-- ì´ë¯¸ì§€ì™€ ì»¨íŠ¸ë¡¤ì„ ë‚˜ë€íˆ ë°°ì¹˜ -->
                    <div style="display: flex; gap: 15px; margin-bottom: 8px; align-items: flex-start;">
                        <!-- ì™¼ìª½: í”„ë ˆì„ ì´ë¯¸ì§€ ë° ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ -->
                        <div style="flex-shrink: 0;">
                            <div style="position: relative; display: inline-block; max-width: 400px; background: #000; border-radius: 4px; overflow: hidden;">
                                <img
                                    loading="lazy"
                                    data-src="${API_BASE_URL}${comment.frame_url}?token=${encodeURIComponent(localStorage.getItem('session_id'))}"
                                    data-comment-index="${index}"
                                    src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='400' height='300'><rect width='100%25' height='100%25' fill='%23222'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%23888' font-size='14'>ì´ë¯¸ì§€ ë¡œë”© ì¤‘...</text></svg>"
                                    alt="Frame ${comment.frame}"
                                    style="width: 100%; height: auto; display: block;"
                                    onerror="this.onerror=null; this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22300%22><rect width=%22100%25%22 height=%22100%25%22 fill=%22%23333%22/><text x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23888%22>ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨</text></svg>';"
                                />
                                ${comment.polygon || comment.box ? `
                                    <canvas
                                        id="annotation-canvas-${index}"
                                        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"
                                    ></canvas>
                                ` : ''}
                            </div>
                            <div style="font-size: 12px; color: #888; margin-top: 8px;">
                                ë¹„ë””ì˜¤: ${comment.video_id} | í”„ë¡œì íŠ¸ ì†Œìœ ì: ${comment.project_owner}
                            </div>
                        </div>

                        <!-- ì˜¤ë¥¸ìª½: ë‹µê¸€ ë²„íŠ¼, ìƒíƒœ ë³€ê²½ ë° ë‹µê¸€ ë¦¬ìŠ¤íŠ¸ -->
                        <div style="display: flex; flex-direction: column; gap: 8px; flex: 1; min-width: 0;">
                            <!-- ë²„íŠ¼ ì˜ì—­ -->
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <button onclick="goToAnnotation('${comment.project_name_full}', '${comment.video_id}', ${comment.frame}, '${comment.label}', ${comment.box ? JSON.stringify(comment.box).replace(/"/g, '&quot;') : 'null'})" style="background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                    ğŸ“ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì´ë™
                                </button>
                                <button id="reply-btn-${comment.comment_id}" onclick="toggleReplies('${comment.comment_id}')" style="background: #1a1a1a; color: #4a9eff; border: 1px solid #4a9eff; padding: 8px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                    ğŸ’¬ ë‹µê¸€ (${comment.replies_count || 0})
                                </button>
                                <select onchange="updateDiscussionStatus('${comment.comment_id}', this.value)" style="background: #1a1a1a; color: white; border: 1px solid #555; padding: 8px; border-radius: 3px; font-size: 12px;">
                                    <option value="open" ${comment.discussion_status === 'open' ? 'selected' : ''}>ì§„í–‰ì¤‘</option>
                                    <option value="pending" ${comment.discussion_status === 'pending' ? 'selected' : ''}>ë³´ë¥˜</option>
                                    <option value="resolved" ${comment.discussion_status === 'resolved' ? 'selected' : ''}>í•´ê²°ë¨</option>
                                </select>
                            </div>

                            <!-- ë‹µê¸€ ì„¹ì…˜ (ìˆ¨ê¹€ ìƒíƒœë¡œ ì‹œì‘) -->
                            <div id="replies-section-${comment.comment_id}" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 4px;">
                                <div id="replies-list-${comment.comment_id}" style="margin-bottom: 10px; max-height: 300px; overflow-y: auto;">
                                    <span style="color: #888;">ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                                </div>

                                <!-- ë‹µê¸€ ì‘ì„± í¼ -->
                                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
                                    <textarea id="reply-input-${comment.comment_id}" placeholder="ë‹µê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..." style="width: 100%; min-height: 60px; background: #2a2a2a; color: white; border: 1px solid #555; padding: 8px; border-radius: 3px; resize: vertical; font-family: inherit; box-sizing: border-box;"></textarea>
                                    <button onclick="submitReply('${comment.comment_id}')" style="margin-top: 8px; background: #4a9eff; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                                        ë‹µê¸€ ì‘ì„±
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `}).join('');

            // Lazy loading ì ìš©: data-srcê°€ ìˆëŠ” ëª¨ë“  ì´ë¯¸ì§€ë¥¼ Observerì— ë“±ë¡
            setTimeout(() => {
                const lazyImages = dashboard.querySelectorAll('img[data-src]');
                lazyImages.forEach(img => imageObserver.observe(img));
                console.log(`[LAZY_LOAD] ${lazyImages.length}ê°œ ì´ë¯¸ì§€ lazy loading ì ìš©`);
            }, 100);
        }

        // ============================================
        // í† ë¡  ê¸°ëŠ¥ í•¨ìˆ˜ë“¤
        // ============================================

        // ë‹µê¸€ ì„¹ì…˜ í† ê¸€
        function toggleReplies(commentId) {
            const repliesSection = document.getElementById(`replies-section-${commentId}`);
            const currentDisplay = repliesSection.style.display;

            if (currentDisplay === 'none') {
                repliesSection.style.display = 'block';
                loadReplies(commentId);
            } else {
                repliesSection.style.display = 'none';
            }
        }

        // ë‹µê¸€ ë¡œë“œ
        async function loadReplies(commentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }
            const repliesList = document.getElementById(`replies-list-${commentId}`);

            try {
                repliesList.innerHTML = '<span style="color: #888;">ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>';

                const response = await fetch(
                    `${API_BASE_URL}/api/discussions/${comment.comment_id}?project_owner=${encodeURIComponent(comment.project_owner)}&project_name=${encodeURIComponent(comment.project_name_full)}`,
                    {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success && data.thread && data.thread.replies && data.thread.replies.length > 0) {
                    // ë‹µê¸€ ë°ì´í„° ì €ì¥
                    repliesData.set(commentId, data.thread.replies);

                    const currentUser = getCurrentUser();
                    const currentUserId = currentUser ? currentUser.user_id : null;

                    repliesList.innerHTML = data.thread.replies.map((reply, replyIndex) => {
                        const isOwnReply = currentUserId && reply.user_id === currentUserId;

                        return `
                        <div id="reply-${commentId}-${replyIndex}" style="background: #2a2a2a; padding: 10px; margin-bottom: 8px; border-left: 2px solid ${isOwnReply ? '#4a9eff' : '#555'}; border-radius: 3px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div>
                                    <span style="color: #4a9eff; font-size: 12px; font-weight: bold;">${reply.user_id}</span>
                                    ${isOwnReply ? '<span style="color: #4a9eff; font-size: 10px; margin-left: 5px;">(ë‚˜)</span>' : ''}
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="color: #888; font-size: 11px;">${new Date(reply.created_at).toLocaleString()}</span>
                                    ${isOwnReply ? `
                                        <button onclick="editReply('${commentId}', ${replyIndex}, '${comment.comment_id}')" style="background: #555; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">âœï¸ í¸ì§‘</button>
                                        <button onclick="deleteReply('${commentId}', ${replyIndex}, '${comment.comment_id}')" style="background: #dc3545; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">ğŸ—‘ï¸ ì‚­ì œ</button>
                                    ` : ''}
                                </div>
                            </div>
                            <div id="reply-content-${commentId}-${replyIndex}" style="color: #ddd; font-size: 13px; white-space: pre-wrap;">${reply.comment}</div>
                        </div>
                    `}).join('');

                    // ë‹µê¸€ ê°œìˆ˜ ì—…ë°ì´íŠ¸
                    const replyCount = data.thread.replies.length;
                    comment.replies_count = replyCount;
                    const btn = document.getElementById(`reply-btn-${commentId}`);
                    if (btn) {
                        btn.textContent = `ğŸ’¬ ë‹µê¸€ (${replyCount})`;
                    }
                } else {
                    // ë‹µê¸€ ë°ì´í„° ì´ˆê¸°í™”
                    repliesData.set(commentId, []);

                    repliesList.innerHTML = '<span style="color: #888;">ì•„ì§ ë‹µê¸€ì´ ì—†ìŠµë‹ˆë‹¤.</span>';

                    // ë‹µê¸€ì´ ì—†ìœ¼ë©´ ê°œìˆ˜ë¥¼ 0ìœ¼ë¡œ ì—…ë°ì´íŠ¸
                    comment.replies_count = 0;
                    const btn = document.getElementById(`reply-btn-${commentId}`);
                    if (btn) {
                        btn.textContent = `ğŸ’¬ ë‹µê¸€ (0)`;
                    }
                }
            } catch (error) {
                console.error('ë‹µê¸€ ë¡œë“œ ì˜¤ë¥˜:', error);
                repliesList.innerHTML = '<span style="color: #f44;">ë‹µê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</span>';
            }
        }

        // ë‹µê¸€ ì œì¶œ
        async function submitReply(commentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }
            const replyInput = document.getElementById(`reply-input-${commentId}`);
            const replyText = replyInput.value.trim();

            if (!replyText) {
                alert('ë‹µê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/reply`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        comment_id: comment.comment_id,
                        reply: replyText,
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full,
                        original_comment: {
                            project_id: comment.project_id,
                            video_id: comment.video_id,
                            frame: comment.frame,
                            label: comment.label,
                            comment: comment.comment,
                            created_by: comment.created_by
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    // ì…ë ¥ì°½ ì´ˆê¸°í™”
                    replyInput.value = '';

                    // ë‹µê¸€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await loadReplies(commentId);

                    // ë‹µê¸€ ìˆ˜ ì—…ë°ì´íŠ¸
                    comment.replies_count = data.total_replies;

                    // ë‹µê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    const btn = document.getElementById(`reply-btn-${commentId}`);
                    if (btn) {
                        btn.textContent = `ğŸ’¬ ë‹µê¸€ (${data.total_replies})`;
                    }

                    alert('ë‹µê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    throw new Error(data.error || 'ë‹µê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ë‹µê¸€ ì‘ì„± ì˜¤ë¥˜:', error);
                alert('ë‹µê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // í† ë¡  ìƒíƒœ ì—…ë°ì´íŠ¸
        async function updateDiscussionStatus(commentId, newStatus) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/${comment.comment_id}/status`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full,
                        status: newStatus
                    })
                });

                if (!response.ok) {
                    throw new Error('ìƒíƒœ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    // ìƒíƒœ ì—…ë°ì´íŠ¸
                    comment.discussion_status = newStatus;

                    // UI ìƒˆë¡œê³ ì¹¨
                    filterComments();
                } else {
                    throw new Error(data.error || 'ìƒíƒœ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
                alert('ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // Commentì—ì„œ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì´ë™
        async function goToAnnotation(projectId, videoId, frameNum, targetLabel = null, targetBox = null) {
            try {
                // 1. í”„ë¡œì íŠ¸ ë¡œë“œ
                console.log('í”„ë¡œì íŠ¸ ë¡œë“œ:', projectId);
                await openProject(projectId);

                // 2. ë¹„ë””ì˜¤ ë¦¬ìŠ¤íŠ¸ê°€ ë Œë”ë§ë  ë•Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 5ì´ˆ)
                let videoItem = null;
                let attempts = 0;
                const maxAttempts = 10;

                while (!videoItem && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    videoItem = document.querySelector(`[data-video-id="${videoId}"]`);
                    attempts++;
                    console.log(`ë¹„ë””ì˜¤ ì°¾ê¸° ì‹œë„ ${attempts}/${maxAttempts}...`);
                }

                if (videoItem) {
                    console.log('ë¹„ë””ì˜¤ ì„ íƒ:', videoId);

                    // [Start Annotation] ë²„íŠ¼ ì°¾ì•„ì„œ í´ë¦­
                    const startBtn = videoItem.querySelector('button[onclick*="startAnnotation"]');
                    if (startBtn) {
                        startBtn.click();
                    } else {
                        // ë²„íŠ¼ì´ ì—†ìœ¼ë©´ ì§ì ‘ startAnnotation í˜¸ì¶œ
                        await startAnnotation(videoId);
                    }

                    // 3. currentVideoIdê°€ ëª©í‘œ videoIdì™€ ì¼ì¹˜í•  ë•Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 10ì´ˆ)
                    let videoLoadAttempts = 0;
                    while (currentVideoId !== videoId && videoLoadAttempts < 20) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        videoLoadAttempts++;
                        console.log(`ë¹„ë””ì˜¤ ë¡œë“œ ëŒ€ê¸° ${videoLoadAttempts}/20... (ëª©í‘œ: ${videoId}, í˜„ì¬: ${currentVideoId})`);
                    }

                    if (currentVideoId !== videoId) {
                        throw new Error(`ë¹„ë””ì˜¤ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ëª©í‘œ: ${videoId}, í˜„ì¬: ${currentVideoId})`);
                    }

                    console.log('âœ… ì˜¬ë°”ë¥¸ ë¹„ë””ì˜¤ ë¡œë“œ ì™„ë£Œ:', currentVideoId);

                    // 4. totalFramesê°€ ì„¤ì •ë  ë•Œê¹Œì§€ ì¶”ê°€ ëŒ€ê¸° (ë¹„ë””ì˜¤ ì •ë³´ ì™„ì „ ë¡œë“œ í™•ì¸)
                    let frameInfoAttempts = 0;
                    while (!totalFrames && frameInfoAttempts < 10) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                        frameInfoAttempts++;
                        console.log(`ë¹„ë””ì˜¤ ì •ë³´ ëŒ€ê¸° ${frameInfoAttempts}/10... (totalFrames: ${totalFrames})`);
                    }

                    // 5. ì¶”ê°€ ì•ˆì •í™” ì‹œê°„ (500ms)
                    await new Promise(resolve => setTimeout(resolve, 500));
                    console.log(`ğŸ“Š ë¹„ë””ì˜¤ ì •ë³´: totalFrames=${totalFrames}, ì´ë™í•  í”„ë ˆì„=${frameNum}`);

                    // 6. í”„ë ˆì„ ë²”ìœ„ ê²€ì¦
                    if (totalFrames && frameNum >= totalFrames) {
                        console.warn(`âš ï¸ í”„ë ˆì„ ë²ˆí˜¸ ì´ˆê³¼: ${frameNum} >= ${totalFrames}, ë§ˆì§€ë§‰ í”„ë ˆì„ìœ¼ë¡œ ì´ë™`);
                        frameNum = totalFrames - 1;
                    }

                    // 7. í”„ë ˆì„ìœ¼ë¡œ ì´ë™
                    console.log('ğŸ¯ í”„ë ˆì„ ì´ë™:', frameNum);
                    currentFrame = frameNum;
                    await loadFrame(currentFrame);

                    // 8. UI ì—…ë°ì´íŠ¸ (ì–´ë…¸í…Œì´ì…˜ ë¦¬ìŠ¤íŠ¸ ë° í†µê³„)
                    updateAnnotationList();
                    updateStatistics();

                    // 9. íƒ€ê²Ÿ ë¼ë²¨ì´ ì§€ì •ëœ ê²½ìš° í•´ë‹¹ ì–´ë…¸í…Œì´ì…˜ ì„ íƒ
                    if (targetLabel) {
                        const allAnnotations = frameAnnotations[currentFrame] || [];

                        // ì „ì²´ í”„ë ˆì„ ë§ˆìŠ¤í¬ë¥¼ ì œì™¸í•œ ì–´ë…¸í…Œì´ì…˜ë“¤ (updateAnnotationListì™€ ë™ì¼í•œ í•„í„°)
                        const visibleAnnotations = allAnnotations.filter(anno => !anno.is_full_frame);

                        // Box ì¢Œí‘œê°€ ì œê³µëœ ê²½ìš° ì •í™•í•œ ë§¤ì¹­, ì—†ìœ¼ë©´ ë¼ë²¨ë§Œìœ¼ë¡œ ë§¤ì¹­
                        let targetIndex = -1;

                        if (targetBox) {
                            // Box ì¢Œí‘œë¡œ ì •í™•í•˜ê²Œ ë§¤ì¹­ (ì¢Œí‘œê°€ ê±°ì˜ ì¼ì¹˜í•˜ëŠ” ê²ƒ ì°¾ê¸°)
                            targetIndex = visibleAnnotations.findIndex(anno => {
                                if (!anno.box) return false;

                                // ì¢Œí‘œ ì°¨ì´ í—ˆìš© ë²”ìœ„ (ì†Œìˆ˜ì  ì˜¤ì°¨ ê³ ë ¤)
                                const tolerance = 0.1;
                                return anno.label === targetLabel &&
                                    Math.abs(anno.box.x - targetBox.x) < tolerance &&
                                    Math.abs(anno.box.y - targetBox.y) < tolerance &&
                                    Math.abs(anno.box.width - targetBox.width) < tolerance &&
                                    Math.abs(anno.box.height - targetBox.height) < tolerance;
                            });

                            if (targetIndex === -1) {
                                console.warn(`âš ï¸ Box ì¢Œí‘œë¡œ ì •í™•í•œ ë§¤ì¹­ ì‹¤íŒ¨, ë¼ë²¨ë§Œìœ¼ë¡œ ì¬ì‹œë„`);
                            }
                        }

                        // Boxë¡œ ëª» ì°¾ì•˜ê±°ë‚˜ Boxê°€ ì—†ìœ¼ë©´ ë¼ë²¨ë§Œìœ¼ë¡œ ì°¾ê¸°
                        if (targetIndex === -1) {
                            targetIndex = visibleAnnotations.findIndex(anno => anno.label === targetLabel);
                        }

                        if (targetIndex !== -1) {
                            selectedAnnotationIndex = targetIndex;
                            console.log(`âœ… ì–´ë…¸í…Œì´ì…˜ ì„ íƒë¨: ${targetLabel} (ì¸ë±ìŠ¤: ${targetIndex})`);

                            // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ í•˜ì´ë¼ì´íŠ¸)
                            drawFrameWithMasks();

                            // ì–´ë…¸í…Œì´ì…˜ ë¦¬ìŠ¤íŠ¸ ë‹¤ì‹œ ì—…ë°ì´íŠ¸ (ì„ íƒ ìƒíƒœ ë°˜ì˜)
                            updateAnnotationList();

                            // ì½”ë©˜íŠ¸ ì„¹ì…˜ ì—…ë°ì´íŠ¸
                            updateCommentSection();
                        } else {
                            console.warn(`âš ï¸ íƒ€ê²Ÿ ì–´ë…¸í…Œì´ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${targetLabel}`);
                        }
                    }

                    // 10. í™”ë©´ì„ Video Annotation ì„¹ì…˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤
                    const videoSection = document.getElementById('videoAnnotationSection');
                    if (videoSection) {
                        videoSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }

                    console.log('âœ… ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì´ë™ ì™„ë£Œ (í”„ë ˆì„, ë¦¬ìŠ¤íŠ¸, í†µê³„ ì—…ë°ì´íŠ¸ë¨)');
                } else {
                    console.error('ë¹„ë””ì˜¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', videoId);
                    alert('í•´ë‹¹ ë¹„ë””ì˜¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\ní”„ë¡œì íŠ¸ì— ë¹„ë””ì˜¤ê°€ í¬í•¨ë˜ì–´ ìˆì§€ ì•Šê±°ë‚˜ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('ì–´ë…¸í…Œì´ì…˜ ì´ë™ ì˜¤ë¥˜:', error);
                alert('ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì´ë™í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ë‹µê¸€ ì‚­ì œ
        async function deleteReply(commentId, replyIndex, originalCommentId) {
            if (!confirm('ì •ë§ë¡œ ì´ ë‹µê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            const replies = repliesData.get(commentId);
            if (!replies || !replies[replyIndex]) {
                console.error('Reply not found');
                return;
            }

            const reply = replies[replyIndex];

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/reply`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        comment_id: originalCommentId,
                        reply_index: replyIndex,
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full
                    })
                });

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    alert('ë‹µê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ë‹µê¸€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await loadReplies(commentId);
                } else {
                    throw new Error(data.error || 'ë‹µê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ë‹µê¸€ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert('ë‹µê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ë‹µê¸€ í¸ì§‘
        async function editReply(commentId, replyIndex, originalCommentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            const replies = repliesData.get(commentId);
            if (!replies || !replies[replyIndex]) {
                console.error('Reply not found');
                return;
            }

            const reply = replies[replyIndex];
            const contentDiv = document.getElementById(`reply-content-${commentId}-${replyIndex}`);
            if (!contentDiv) return;

            // í˜„ì¬ ë‚´ìš© ì €ì¥
            const originalContent = reply.comment;

            // í¸ì§‘ ëª¨ë“œë¡œ ì „í™˜
            contentDiv.innerHTML = `
                <textarea id="edit-reply-input-${commentId}-${replyIndex}"
                          style="width: 100%; min-height: 60px; background: #1a1a1a; color: white; border: 1px solid #555; padding: 8px; border-radius: 3px; resize: vertical; font-family: inherit; box-sizing: border-box;">${originalContent}</textarea>
                <div style="margin-top: 8px; display: flex; gap: 8px;">
                    <button onclick="saveEditedReply('${commentId}', ${replyIndex}, '${originalCommentId}')" style="background: #4a9eff; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">ğŸ’¾ ì €ì¥</button>
                    <button onclick="cancelEditReply('${commentId}', ${replyIndex}, \`${originalContent.replace(/`/g, '\\`')}\`)" style="background: #555; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">âœ– ì·¨ì†Œ</button>
                </div>
            `;

            // í¸ì§‘ ì¤‘ì—ëŠ” í¸ì§‘/ì‚­ì œ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
            const replyDiv = document.getElementById(`reply-${commentId}-${replyIndex}`);
            const buttons = replyDiv.querySelectorAll('button[onclick^="editReply"], button[onclick^="deleteReply"]');
            buttons.forEach(btn => btn.style.display = 'none');
        }

        // í¸ì§‘ ì·¨ì†Œ
        function cancelEditReply(commentId, replyIndex, originalContent) {
            const contentDiv = document.getElementById(`reply-content-${commentId}-${replyIndex}`);
            if (!contentDiv) return;

            // ì›ë˜ ë‚´ìš©ìœ¼ë¡œ ë³µì›
            contentDiv.innerHTML = originalContent;

            // í¸ì§‘/ì‚­ì œ ë²„íŠ¼ ë‹¤ì‹œ í‘œì‹œ
            const replyDiv = document.getElementById(`reply-${commentId}-${replyIndex}`);
            const buttons = replyDiv.querySelectorAll('button[onclick^="editReply"], button[onclick^="deleteReply"]');
            buttons.forEach(btn => btn.style.display = '');
        }

        // í¸ì§‘ëœ ë‹µê¸€ ì €ì¥
        async function saveEditedReply(commentId, replyIndex, originalCommentId) {
            const comment = allComments.find(c => c.comment_id === commentId);
            if (!comment) {
                console.error('Comment not found:', commentId);
                return;
            }

            const textarea = document.getElementById(`edit-reply-input-${commentId}-${replyIndex}`);
            if (!textarea) return;

            const newContent = textarea.value.trim();

            if (!newContent) {
                alert('ë‹µê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/discussions/reply`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('session_id')}`
                    },
                    body: JSON.stringify({
                        comment_id: originalCommentId,
                        reply_index: replyIndex,
                        new_comment: newContent,
                        project_owner: comment.project_owner,
                        project_name: comment.project_name_full
                    })
                });

                if (!response.ok) {
                    throw new Error('ë‹µê¸€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    alert('ë‹µê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ë‹µê¸€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await loadReplies(commentId);
                } else {
                    throw new Error(data.error || 'ë‹µê¸€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('ë‹µê¸€ ìˆ˜ì • ì˜¤ë¥˜:', error);
                alert('ë‹µê¸€ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
        function drawAnnotationOnCanvas(comment, index) {
            const canvas = document.getElementById(`annotation-canvas-${index}`);
            if (!canvas) return;

            const card = document.getElementById(`comment-card-${index}`);
            if (!card) return;

            const img = card.querySelector('img');
            if (!img) return;

            // ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
            const drawOnLoad = () => {
                const ctx = canvas.getContext('2d');

                // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì´ë¯¸ì§€ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                // ìº”ë²„ìŠ¤ë¥¼ ì´ˆê¸°í™”
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ì–´ë…¸í…Œì´ì…˜ì´ ìˆ¨ê¹€ ìƒíƒœë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (!showAnnotations) {
                    return;
                }

                // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
                if (comment.polygon && Array.isArray(comment.polygon) && comment.polygon.length > 0) {
                    ctx.strokeStyle = '#00ff00';  // ì´ˆë¡ìƒ‰
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';  // ë°˜íˆ¬ëª… ì´ˆë¡ìƒ‰

                    ctx.beginPath();
                    ctx.moveTo(comment.polygon[0].x, comment.polygon[0].y);

                    for (let i = 1; i < comment.polygon.length; i++) {
                        ctx.lineTo(comment.polygon[i].x, comment.polygon[i].y);
                    }

                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                // ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸° (í´ë¦¬ê³¤ì´ ì—†ì„ ë•Œë§Œ)
                else if (comment.box) {
                    ctx.strokeStyle = '#ffff00';  // ë…¸ë€ìƒ‰
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';  // ë°˜íˆ¬ëª… ë…¸ë€ìƒ‰

                    const { x, y, width, height } = comment.box;
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeRect(x, y, width, height);
                }
            };

            // ì´ë¯¸ì§€ê°€ ì´ë¯¸ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (img.complete && img.naturalWidth > 0) {
                drawOnLoad();
            } else {
                // ì´ë¯¸ì§€ ë¡œë“œ ëŒ€ê¸°
                img.addEventListener('load', drawOnLoad, { once: true });
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ/ìˆ¨ê¹€ í† ê¸€
        // í•„í„° ì´ˆê¸°í™”
        function resetCommentFilters() {
            // ë“œë¡­ë‹¤ìš´ ì´ˆê¸°í™”
            document.getElementById('commentFilterProject').value = '';
            document.getElementById('commentFilterUser').value = '';
            document.getElementById('commentFilterLabel').value = '';
            document.getElementById('commentFilterStatus').value = '';

            // ë‚ ì§œ í•„í„° ì´ˆê¸°í™”
            document.getElementById('commentFilterDateFrom').value = '';
            document.getElementById('commentFilterDateTo').value = '';

            // ì²´í¬ë°•ìŠ¤ ì´ˆê¸°í™”
            document.getElementById('commentFilterMyOnly').checked = false;

            // ì •ë ¬ ì´ˆê¸°í™”
            document.getElementById('commentSortBy').value = 'recent';

            // í•„í„° ì¬ì ìš©
            filterComments();
        }

        function toggleAnnotationsDisplay() {
            showAnnotations = !showAnnotations;

            const btn = document.getElementById('toggleAnnotationsBtn');
            if (showAnnotations) {
                btn.innerHTML = 'ğŸ‘ï¸ ì–´ë…¸í…Œì´ì…˜ ìˆ¨ê¹€';
                btn.style.background = '#4a9eff';
            } else {
                btn.innerHTML = 'ğŸ‘ï¸â€ğŸ—¨ï¸ ì–´ë…¸í…Œì´ì…˜ ë³´ê¸°';
                btn.style.background = '#555';
            }

            // í™”ë©´ì— í‘œì‹œëœ ëª¨ë“  ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            const dashboard = document.getElementById('commentsDashboard');
            const canvases = dashboard.querySelectorAll('[id^="annotation-canvas-"]');
            canvases.forEach(canvas => {
                const index = parseInt(canvas.id.replace('annotation-canvas-', ''));
                const comment = allComments[index];
                if (comment) {
                    drawAnnotationOnCanvas(comment, index);
                }
            });
        }

        // í”„ë¡œì íŠ¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (2ì—´ êµ¬ì¡°)
        async function loadProjects() {
            const myProjectList = document.getElementById('myProjectList');
            const sharedProjectList = document.getElementById('sharedProjectList');

            myProjectList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';
            sharedProjectList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                // 1. ë‚´ í”„ë¡œì íŠ¸ ë¡œë“œ
                const myResponse = await authFetch('/api/projects');
                const myData = await myResponse.json();

                console.log('My projects data:', myData);

                if (myData.success && myData.projects && myData.projects.length > 0) {
                    myProjectList.innerHTML = myData.projects.map(p => {
                        return '<div style="position: relative; padding: 10px; margin-bottom: 10px; border: 1px solid #007bff; border-radius: 4px; padding-right: 50px; background: #1e1e1e;">' +
                            '<div onclick="openProject(\'' + p.id + '\')" style="cursor: pointer;">' +
                                '<strong style="color: #fff;">' + p.name + '</strong><br>' +
                                '<small style="color: #888;">ID: ' + p.id + '</small><br>' +
                                '<small style="color: #888;">Path: ' + p.path + '</small>' +
                            '</div>' +
                            '<button onclick="event.stopPropagation(); deleteProject(\'' + p.id + '\', \'' + p.name.replace(/'/g, "\\'") + '\')" ' +
                                'style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; ' +
                                'border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">' +
                                'ğŸ—‘ï¸ ì‚­ì œ' +
                            '</button>' +
                        '</div>';
                    }).join('');
                } else {
                    myProjectList.innerHTML = '<p style="color: #999;">ë‚´ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }

                // 2. ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ ë¡œë“œ
                const sharedResponse = await authFetch('/api/projects/shared');
                const sharedData = await sharedResponse.json();

                console.log('Shared projects data:', sharedData);

                if (sharedData.success && sharedData.projects && sharedData.projects.length > 0) {
                    sharedProjectList.innerHTML = sharedData.projects.map(p => {
                        return '<div style="position: relative; padding: 10px; margin-bottom: 10px; border: 1px solid #555; border-radius: 4px; background: #252525;">' +
                            '<div onclick="openProject(\'' + p.id + '\')" style="cursor: pointer;">' +
                                '<strong style="color: #ddd;">' + p.name + '</strong><br>' +
                                '<small style="color: #4a9eff;">ğŸ‘¤ ' + p.owner_name + ' (' + p.owner_id + ')</small><br>' +
                                '<small style="color: #888;">ID: ' + p.id + '</small><br>' +
                                '<small style="color: #888;">Path: ' + p.path + '</small>' +
                            '</div>' +
                            '<div style="position: absolute; top: 10px; right: 10px; font-size: 12px; color: #ffa500;">ğŸ‘ï¸ ì½ê¸° ì „ìš©</div>' +
                        '</div>';
                    }).join('');
                } else {
                    sharedProjectList.innerHTML = '<p style="color: #666;">ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }

            } catch (error) {
                console.error('Load projects error:', error);
                myProjectList.innerHTML =
                    '<p style="color: red;">[ERROR] ' + error.message + '</p>';
                sharedProjectList.innerHTML =
                    '<p style="color: red;">[ERROR] ' + error.message + '</p>';
            }
        }

        // í”„ë¡œì íŠ¸ ì—´ê¸°
        async function openProject(projectId) {
            try {
                // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ í™•ì¸
                const currentUser = getCurrentUser();
                const isAdmin = currentUser && currentUser.role === 'admin';

                // ê´€ë¦¬ìëŠ” /api/admin/projects, ì¼ë°˜ ì‚¬ìš©ìëŠ” /api/projects ì‚¬ìš©
                const endpoint = isAdmin
                    ? '/api/admin/projects/' + projectId
                    : '/api/projects/' + projectId;

                const response = await authFetch(endpoint);
                const data = await response.json();

                if (data.success) {
                    currentProject = data.project;
                    displayCurrentProject();

                    // í´ë˜ìŠ¤ ë¼ë””ì˜¤ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                    updateClassRadioButtons();
                    selectedClassIndex = 0;  // ì²« ë²ˆì§¸ í´ë˜ìŠ¤ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ

                    // í”„ë ˆì„-í´ë˜ìŠ¤ ì½”ë©˜íŠ¸ ë¡œë“œ
                    loadFrameClassComments();

                    // ëŒ€ì‹œë³´ë“œë¥¼ í”„ë¡œì íŠ¸ë³„ í†µê³„ë¡œ ì „í™˜
                    loadAnnotationDashboard();
                } else {
                    alert('[ERROR] Error: ' + data.error);
                }
            } catch (error) {
                console.error('Open project error:', error);
                alert('[ERROR] Error: ' + error.message);
            }
        }

        // í”„ë¡œì íŠ¸ ì‚­ì œ
        async function deleteProject(projectId, projectName) {
            // ì‚­ì œ í™•ì¸
            if (!confirm('í”„ë¡œì íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\ní”„ë¡œì íŠ¸: ' + projectName + '\nID: ' + projectId + '\n\nâš ï¸ ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!')) {
                return;
            }

            try {
                // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ í™•ì¸
                const currentUser = getCurrentUser();
                const isAdmin = currentUser && currentUser.role === 'admin';

                // ê´€ë¦¬ìëŠ” /api/admin/projects, ì¼ë°˜ ì‚¬ìš©ìëŠ” /api/projects ì‚¬ìš©
                const endpoint = isAdmin
                    ? '/api/admin/projects/' + projectId
                    : '/api/projects/' + projectId;

                const response = await authFetch(endpoint, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.success) {
                    alert('âœ… í”„ë¡œì íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!\n\ní”„ë¡œì íŠ¸: ' + projectName);

                    // í˜„ì¬ ì—´ë¦° í”„ë¡œì íŠ¸ê°€ ì‚­ì œëœ í”„ë¡œì íŠ¸ì¸ ê²½ìš° ì´ˆê¸°í™”
                    if (currentProject && currentProject.id === projectId) {
                        currentProject = null;
                        displayCurrentProject();
                    }

                    // í”„ë¡œì íŠ¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    loadProjects();
                } else {
                    alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('Delete project error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ê´€ë¦¬ììš©: ì „ì²´ í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
        async function loadAllProjects() {
            const allProjectsList = document.getElementById('allProjectsList');
            allProjectsList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                // ëª¨ë“  ì‚¬ìš©ìì˜ í”„ë¡œì íŠ¸ ì¡°íšŒ
                const response = await authFetch('/api/admin/projects');
                const data = await response.json();

                console.log('[ADMIN] All projects data:', data);

                if (data.success && data.projects && data.projects.length > 0) {
                    // í”„ë¡œì íŠ¸ë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ í‘œì‹œ
                    const projectsHtml = data.projects.map(p => {
                        const createdDate = p.created_at ? new Date(p.created_at).toLocaleString('ko-KR') : 'N/A';
                        const videoCount = p.video_count || 0;
                        const annotationCount = p.annotation_count || 0;

                        return `
                            <div style="background: #2d2d2d; padding: 15px; margin-bottom: 10px; border-radius: 4px; border-left: 4px solid #007bff;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <h4 style="margin: 0 0 10px 0; color: #58a6ff;">ğŸ“ ${p.name}</h4>
                                        <div style="display: grid; grid-template-columns: 150px 1fr; gap: 5px; font-size: 13px;">
                                            <span style="color: #8b949e;">í”„ë¡œì íŠ¸ ID:</span><span>${p.id}</span>
                                            <span style="color: #8b949e;">ì†Œìœ ì:</span><span>${p.owner_id} (${p.owner_name || 'N/A'})</span>
                                            <span style="color: #8b949e;">ê²½ë¡œ:</span><span style="font-family: monospace; color: #a5d6ff;">${p.path}</span>
                                            <span style="color: #8b949e;">ìƒì„±ì¼:</span><span>${createdDate}</span>
                                            <span style="color: #8b949e;">ë¹„ë””ì˜¤:</span><span style="color: #79c0ff; font-weight: bold;">${videoCount}ê°œ</span>
                                            <span style="color: #8b949e;">ì–´ë…¸í…Œì´ì…˜:</span><span style="color: #56d364; font-weight: bold;">${annotationCount}ê°œ</span>
                                            <span style="color: #8b949e;">í´ë˜ìŠ¤:</span><span>${(p.classes || []).length}ê°œ ${p.classes && p.classes.length > 0 ? '(' + p.classes.slice(0, 3).join(', ') + (p.classes.length > 3 ? '...' : '') + ')' : ''}</span>
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 5px; flex-direction: column;">
                                        <button onclick="viewProjectDetails('${p.id}')"
                                            style="background: #238636; color: white; border: none; padding: 6px 12px;
                                            border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                            ğŸ‘ï¸ ìƒì„¸ë³´ê¸°
                                        </button>
                                        <button onclick="adminDeleteProject('${p.id}', '${p.name.replace(/'/g, "\\'")}', '${p.owner_id}')"
                                            style="background: #da3633; color: white; border: none; padding: 6px 12px;
                                            border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                                            ğŸ—‘ï¸ ì‚­ì œ
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // í†µê³„ ìš”ì•½
                    const totalProjects = data.projects.length;
                    const totalVideos = data.projects.reduce((sum, p) => sum + (p.video_count || 0), 0);
                    const totalAnnotations = data.projects.reduce((sum, p) => sum + (p.annotation_count || 0), 0);
                    const uniqueUsers = [...new Set(data.projects.map(p => p.owner_id))].length;

                    const summaryHtml = `
                        <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                            padding: 20px; margin-bottom: 15px; border-radius: 8px; color: white;">
                            <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ“Š ì „ì²´ í†µê³„</h3>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; text-align: center;">
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${totalProjects}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ í”„ë¡œì íŠ¸</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${uniqueUsers}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í™œì„± ì‚¬ìš©ì</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${totalVideos}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ ë¹„ë””ì˜¤</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${totalAnnotations}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                                </div>
                            </div>
                        </div>
                    `;

                    allProjectsList.innerHTML = summaryHtml + projectsHtml;
                } else {
                    allProjectsList.innerHTML = '<p style="color: #999;">ë“±ë¡ëœ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }

            } catch (error) {
                console.error('[ADMIN] Load all projects error:', error);
                allProjectsList.innerHTML =
                    '<p style="color: red;">[ERROR] ì „ì²´ í”„ë¡œì íŠ¸ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ê´€ë¦¬ììš©: ì™„ë£Œëœ ë¹„ë””ì˜¤ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (í”„ë¡œì íŠ¸ íƒ­ì— í‘œì‹œ)
        async function loadAdminCompletedVideos() {
            console.log('[ADMIN] loadAdminCompletedVideos called');
            const projectList = document.getElementById('projectList');
            const currentProjectSection = document.getElementById('currentProjectSection');

            if (!projectList) {
                console.error('[ADMIN] projectList element not found!');
                return;
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ ì„¹ì…˜ê³¼ ìƒì„± ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            if (currentProjectSection) {
                currentProjectSection.style.display = 'none';
            }

            projectList.innerHTML = '<p style="color: #999;">ì „ì²´ í”„ë¡œì íŠ¸ í˜„í™© ë¡œë”© ì¤‘...</p>';

            try {
                console.log('[ADMIN] Fetching completed videos...');
                const response = await authFetch('/api/admin/completed-videos');

                console.log('[ADMIN] Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[ADMIN] Completed videos data:', data);

                if (!data.success) {
                    throw new Error(data.error || 'Unknown error from server');
                }

                if (!data.users || data.users.length === 0) {
                    console.log('[ADMIN] No completed videos found');
                    projectList.innerHTML = '<p style="color: #999;">ì™„ë£Œëœ ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }

                // ì•ˆì „í•˜ê²Œ ì´ ì–´ë…¸í…Œì´ì…˜ ìˆ˜ ê³„ì‚°
                let totalAnnotations = 0;
                try {
                    totalAnnotations = data.users.reduce((sum, u) => {
                        const userVideos = u.videos || [];
                        return sum + userVideos.reduce((vsum, v) => vsum + (v.annotations || 0), 0);
                    }, 0);
                } catch (e) {
                    console.warn('[ADMIN] Error calculating annotations:', e);
                }

                console.log('[ADMIN] Building summary HTML...');
                // ì „ì²´ í†µê³„ ìš”ì•½
                const summaryHtml = `
                    <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                        padding: 20px; margin-bottom: 15px; border-radius: 8px; color: white;">
                        <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ“Š ì™„ë£Œëœ ë¹„ë””ì˜¤ í†µê³„</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div>
                                <div style="font-size: 28px; font-weight: bold;">${data.total_users || 0}</div>
                                <div style="font-size: 12px; opacity: 0.9;">ì‘ì—… ì¤‘ì¸ ì‚¬ìš©ì</div>
                            </div>
                            <div>
                                <div style="font-size: 28px; font-weight: bold;">${data.total_completed_videos || 0}</div>
                                <div style="font-size: 12px; opacity: 0.9;">ì™„ë£Œëœ ë¹„ë””ì˜¤</div>
                            </div>
                            <div>
                                <div style="font-size: 28px; font-weight: bold;">${totalAnnotations}</div>
                                <div style="font-size: 12px; opacity: 0.9;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                            </div>
                        </div>
                    </div>
                `;

                console.log('[ADMIN] Building users HTML...');
                // ì‚¬ìš©ìë³„ ì™„ë£Œëœ ë¹„ë””ì˜¤ ëª©ë¡
                const usersHtml = data.users.map(user => {
                    const videos = user.videos || [];
                    const videosHtml = videos.map(video => `
                        <tr style="border-bottom: 1px solid #404040;">
                            <td style="padding: 8px;">${video.video_name || 'N/A'}</td>
                            <td style="padding: 8px;">${video.project_name || 'N/A'}</td>
                            <td style="padding: 8px; text-align: center;">${video.annotations || 0}</td>
                            <td style="padding: 8px; text-align: center;">${video.frame_count || 0}</td>
                            <td style="padding: 8px; text-align: center;">${video.complete ? 'âœ…' : 'â³'}</td>
                        </tr>
                    `).join('');

                    return `
                        <div style="background: #2d2d2d; padding: 15px; margin-bottom: 15px; border-radius: 4px; border-left: 4px solid #28a745;">
                            <h4 style="margin: 0 0 10px 0; color: #58a6ff;">
                                ğŸ‘¤ ${user.user_name || user.user_id} (${user.user_id}) - ${user.completed_videos_count || 0}ê°œ ì™„ë£Œ
                            </h4>
                            <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                <thead>
                                    <tr style="background: #1e1e1e; color: #8b949e;">
                                        <th style="padding: 8px; text-align: left;">ë¹„ë””ì˜¤</th>
                                        <th style="padding: 8px; text-align: left;">í”„ë¡œì íŠ¸</th>
                                        <th style="padding: 8px; text-align: center;">ì–´ë…¸í…Œì´ì…˜</th>
                                        <th style="padding: 8px; text-align: center;">í”„ë ˆì„</th>
                                        <th style="padding: 8px; text-align: center;">ì™„ë£Œ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${videosHtml}
                                </tbody>
                            </table>
                        </div>
                    `;
                }).join('');

                console.log('[ADMIN] Setting innerHTML...');
                projectList.innerHTML = summaryHtml + usersHtml;
                console.log('[ADMIN] Completed videos loaded successfully');

            } catch (error) {
                console.error('[ADMIN] Load completed videos error:', error);
                console.error('[ADMIN] Error stack:', error.stack);
                projectList.innerHTML =
                    '<p style="color: red;">[ERROR] ì™„ë£Œëœ ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ê´€ë¦¬ììš©: ì–´ë…¸í…Œì´ì…˜ í†µê³„ ë¶ˆëŸ¬ì˜¤ê¸° (ì–´ë…¸í…Œì´ì…˜ íƒ­ì— í‘œì‹œ)
        async function loadAdminAnnotationStats() {
            // ì–´ë…¸í…Œì´ì…˜ íƒ­ì˜ ê¸°ì¡´ ì»¨í…ì¸  ëŒ€ì‹  í†µê³„ í‘œì‹œ
            const annotationTab = document.getElementById('annotation-tab');

            // ì„ì‹œ ì»¨í…Œì´ë„ˆ ìƒì„± (ê¸°ì¡´ UIë¥¼ ìˆ¨ê¸°ì§€ ì•Šê³  ìƒë‹¨ì— ì¶”ê°€)
            let statsContainer = document.getElementById('admin-annotation-stats-container');
            if (!statsContainer) {
                statsContainer = document.createElement('div');
                statsContainer.id = 'admin-annotation-stats-container';
                statsContainer.style.cssText = 'padding: 20px; background: #1e1e1e; margin-bottom: 20px; border-radius: 8px;';
                annotationTab.insertBefore(statsContainer, annotationTab.firstChild);
            }

            statsContainer.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                const response = await authFetch('/api/admin/annotation-stats');
                const data = await response.json();

                console.log('[ADMIN] Annotation stats data:', data);

                if (data.success) {
                    const stats = data.total_stats;
                    const userStats = data.user_stats;

                    // ì „ì²´ í†µê³„ ìš”ì•½
                    const summaryHtml = `
                        <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
                            padding: 20px; margin-bottom: 15px; border-radius: 8px; color: white;">
                            <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ“Š ì „ì²´ ì–´ë…¸í…Œì´ì…˜ í˜„í™©</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_users}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í™œì„± ì‚¬ìš©ì</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_projects}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í”„ë¡œì íŠ¸</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_videos}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ë¹„ë””ì˜¤</div>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_annotated_videos}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì™„ë£Œëœ ë¹„ë””ì˜¤</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_annotations}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: bold;">${stats.total_annotated_frames}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">í”„ë ˆì„</div>
                                </div>
                            </div>
                        </div>
                    `;

                    // ì‚¬ìš©ìë³„ í†µê³„
                    const userStatsHtml = userStats.length > 0 ? `
                        <div style="background: #2d2d2d; padding: 15px; border-radius: 4px;">
                            <h4 style="margin: 0 0 10px 0; color: #58a6ff;">ğŸ“ˆ ì‚¬ìš©ìë³„ ì‘ì—… í˜„í™©</h4>
                            <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                <thead>
                                    <tr style="background: #1e1e1e; color: #8b949e;">
                                        <th style="padding: 8px; text-align: left;">ì‚¬ìš©ì</th>
                                        <th style="padding: 8px; text-align: center;">í”„ë¡œì íŠ¸</th>
                                        <th style="padding: 8px; text-align: center;">ë¹„ë””ì˜¤</th>
                                        <th style="padding: 8px; text-align: center;">ì™„ë£Œ</th>
                                        <th style="padding: 8px; text-align: center;">ì–´ë…¸í…Œì´ì…˜</th>
                                        <th style="padding: 8px; text-align: center;">í”„ë ˆì„</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${userStats.map(u => `
                                        <tr style="border-bottom: 1px solid #404040;">
                                            <td style="padding: 8px;">${u.user_name} (${u.user_id})</td>
                                            <td style="padding: 8px; text-align: center;">${u.projects}</td>
                                            <td style="padding: 8px; text-align: center;">${u.videos}</td>
                                            <td style="padding: 8px; text-align: center;">${u.annotated_videos}</td>
                                            <td style="padding: 8px; text-align: center; color: #56d364; font-weight: bold;">${u.annotations}</td>
                                            <td style="padding: 8px; text-align: center;">${u.annotated_frames}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    ` : '<p style="color: #999;">ì‚¬ìš©ì í†µê³„ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';

                    // í†µê³„ ìˆ¨ê¹€ ì²˜ë¦¬
                    statsContainer.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">í†µê³„ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.</p>';
                    // statsContainer.innerHTML = summaryHtml + userStatsHtml;
                } else {
                    statsContainer.innerHTML = '<p style="color: red;">[ERROR] í†µê³„ ë¡œë“œ ì‹¤íŒ¨</p>';
                }

            } catch (error) {
                console.error('[ADMIN] Load annotation stats error:', error);
                statsContainer.innerHTML =
                    '<p style="color: red;">[ERROR] í†µê³„ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ê´€ë¦¬ììš©: í”„ë¡œì íŠ¸ ìƒì„¸ë³´ê¸° (ëª¨ë‹¬ ë˜ëŠ” í™•ì¥)
        async function viewProjectDetails(projectId) {
            try {
                const response = await authFetch('/api/admin/projects/' + projectId);
                const data = await response.json();

                if (data.success) {
                    const project = data.project;
                    const details = `
í”„ë¡œì íŠ¸ ìƒì„¸ ì •ë³´
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ ì´ë¦„: ${project.name}
ğŸ†” ID: ${project.id}
ğŸ‘¤ ì†Œìœ ì: ${project.owner_id}
ğŸ“‚ ê²½ë¡œ: ${project.path}
ğŸ“… ìƒì„±ì¼: ${project.created_at ? new Date(project.created_at).toLocaleString('ko-KR') : 'N/A'}

ğŸ“Š í†µê³„:
  â€¢ í´ë˜ìŠ¤: ${(project.classes || []).length}ê°œ
  â€¢ ë¹„ë””ì˜¤: ${project.video_count || 0}ê°œ
  â€¢ ì–´ë…¸í…Œì´ì…˜: ${project.annotation_count || 0}ê°œ

ğŸ·ï¸ í´ë˜ìŠ¤ ëª©ë¡:
${(project.classes || []).map((c, i) => `  ${i + 1}. ${c}`).join('\n') || '  (í´ë˜ìŠ¤ ì—†ìŒ)'}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    `;
                    alert(details);
                } else {
                    alert('âŒ í”„ë¡œì íŠ¸ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] View project details error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì •ë³´ ë¡œë“œ ì˜¤ë¥˜: ' + error.message);
            }
        }

        // ê´€ë¦¬ììš©: í”„ë¡œì íŠ¸ ì‚­ì œ
        async function adminDeleteProject(projectId, projectName, ownerId) {
            if (!confirm(`âš ï¸ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ í”„ë¡œì íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\ní”„ë¡œì íŠ¸: ${projectName}\nID: ${projectId}\nì†Œìœ ì: ${ownerId}\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)) {
                return;
            }

            try {
                const response = await authFetch('/api/admin/projects/' + projectId, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.success) {
                    alert('âœ… í”„ë¡œì íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!\n\ní”„ë¡œì íŠ¸: ' + projectName);
                    loadAllProjects();  // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Delete project error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì‚­ì œ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // í˜„ì¬ í”„ë¡œì íŠ¸ í‘œì‹œ
        function displayCurrentProject() {
            if (!currentProject) {
                document.getElementById('currentProjectSection').style.display = 'none';
                return;
            }

            document.getElementById('currentProjectSection').style.display = 'block';
            document.getElementById('currentProjectName').textContent = currentProject.name;

            // ê¸°ë³¸ê°’ ì„¤ì •
            const classes = currentProject.classes || [];
            const stats = currentProject.stats || {
                total_videos: 0,
                annotated_videos: 0,
                total_annotations: 0,
                annotated_frames: 0,
                datasets: 0
            };

            document.getElementById('currentProjectStats').innerHTML =
                'ID: ' + currentProject.id + '<br>' +
                'í´ë˜ìŠ¤: ' + (classes.length > 0 ? classes.map(c => getClassDisplayName(c)).join(', ') : 'ì—†ìŒ') + '<br>' +
                'ë¹„ë””ì˜¤: ' + stats.total_videos + ' (ì™„ë£Œ ' + stats.annotated_videos + ')<br>' +
                'ì´ ì–´ë…¸í…Œì´ì…˜: ' + stats.total_annotations + ' (' + stats.annotated_frames + ' í”„ë ˆì„)<br>' +
                'ë°ì´í„°ì…‹: ' + stats.datasets;

            // ì½”ë©˜íŠ¸ ê°œìˆ˜ë¥¼ ë¨¼ì € ê°€ì ¸ì˜¨ í›„ ë¹„ë””ì˜¤ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
            // fetchCommentCounts()ê°€ ë‚´ë¶€ì—ì„œ displayVideos()ë¥¼ í˜¸ì¶œí•¨
            fetchCommentCounts();
        }

        // ì „ì—­ ë³€ìˆ˜ë¡œ ì½”ë©˜íŠ¸ ê°œìˆ˜ ì €ì¥
        let videoCommentCounts = {};

        // ë¹„ë””ì˜¤ë³„ ì½”ë©˜íŠ¸ ê°œìˆ˜ ê°€ì ¸ì˜¤ê¸°
        async function fetchCommentCounts() {
            if (!currentProject) return;

            try {
                const response = await fetch(`/api/projects/${encodeURIComponent(currentProject.id)}/comments/counts`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        videoCommentCounts = data.counts || {};
                        console.log('[COMMENT_COUNTS] Loaded comment counts:', videoCommentCounts);
                        console.log('[COMMENT_COUNTS] Refreshing video list with comment counts...');
                        // ì½”ë©˜íŠ¸ ê°œìˆ˜ë¥¼ ë°›ì•„ì˜¨ í›„ ë¹„ë””ì˜¤ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                        displayVideos();
                        console.log('[COMMENT_COUNTS] Video list refreshed');
                    }
                }
            } catch (error) {
                console.error('[COMMENT_COUNTS] Error fetching comment counts:', error);
            }
        }

        // ë¹„ë””ì˜¤ ëª©ë¡ í‘œì‹œ
        function displayVideos() {
            const videosList = document.getElementById('videosList');

            if (!currentProject || !currentProject.videos || currentProject.videos.length === 0) {
                videosList.innerHTML = '<p style="color: #999;">ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            videosList.innerHTML = currentProject.videos.map((v, index) => {
                // ë””ë ‰í† ë¦¬ ë©”íƒ€ë°ì´í„° íŒŒì‹± (í•˜ì´í”ˆìœ¼ë¡œ êµ¬ë¶„ëœ ë¶€ë¶„ë“¤)
                let dirMetaDisplay = '';
                if (v.nas_metadata && v.nas_metadata.parent_dir) {
                    const parts = v.nas_metadata.parent_dir.split('-').map(p => p.trim()).filter(p => p);
                    dirMetaDisplay = parts.length > 0 ? parts.join(' - ') : v.nas_metadata.parent_dir;
                }

                // ë¹„ë””ì˜¤ ìƒíƒœ (ê¸°ë³¸ê°’: in_progress)
                const status = v.status || 'in_progress';
                const isCompleted = status === 'completed';

                // ìƒíƒœì— ë”°ë¥¸ ìŠ¤íƒ€ì¼
                const borderColor = isCompleted ? '#28a745' : '#ffa500';
                const statusBadge = isCompleted
                    ? '<span style="background: #28a745; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; margin-left: 10px;">âœ“ ì™„ë£Œ</span>'
                    : '<span style="background: #ffa500; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; margin-left: 10px;">â³ ì§„í–‰ì¤‘</span>';

                // ìƒíƒœ í† ê¸€ ë²„íŠ¼
                const statusToggleBtn = isCompleted
                    ? '<button onclick="toggleVideoStatus(\'' + v.video_id + '\', \'in_progress\')" style="background: #6c757d; font-size: 12px; padding: 5px 10px; margin-right: 5px;" title="ì§„í–‰ì¤‘ìœ¼ë¡œ ë³€ê²½">[ì§„í–‰ì¤‘ìœ¼ë¡œ]</button>'
                    : '<button onclick="toggleVideoStatus(\'' + v.video_id + '\', \'completed\')" style="background: #28a745; font-size: 12px; padding: 5px 10px; margin-right: 5px;" title="ì™„ë£Œë¡œ ë³€ê²½">[ì™„ë£Œë¡œ í‘œì‹œ]</button>';

                // ì½”ë©˜íŠ¸ ê°œìˆ˜ í™•ì¸
                const commentCount = videoCommentCounts[v.video_id] || 0;
                const commentIcon = commentCount > 0
                    ? ' <span style="display: inline-block; background: #ffa500; color: white; padding: 6px 12px; border-radius: 4px; font-size: 14px; font-weight: bold; margin-left: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" title="ì½”ë©˜íŠ¸ ê°œìˆ˜">ğŸ’¬ ' + commentCount + '</span>'
                    : '';

                // ë¹„ë””ì˜¤ ë²ˆí˜¸ ë±ƒì§€
                const videoNumber = '<span style="display: inline-block; background: #555; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-right: 8px;">#' + (index + 1) + '</span>';

                return '<div data-video-id="' + v.video_id + '" style="padding: 10px; margin: 5px 0; background: #2d2d2d; border-radius: 4px; border-left: 4px solid ' + borderColor + ';">' +
                    '<div style="margin-bottom: 8px;">' +
                        videoNumber +
                        '<strong style="color: #4a9eff; font-size: 14px;">ğŸ“¹ ' + v.filename + '</strong>' +
                        commentIcon +
                        statusBadge +
                        '<br>' +
                        (dirMetaDisplay ? '<small style="color: #4a9eff; margin-left: 34px;">ğŸ“‹ ' + dirMetaDisplay + '</small>' : '') +
                    '</div>' +
                    '<div style="margin-bottom: 5px;">' +
                        '<button onclick="startAnnotation(\'' + v.video_id + '\')" style="background: #4a9eff; font-size: 12px; padding: 5px 10px; margin-right: 5px;">[Start Annotation]</button>' +
                        '<button onclick="startVideoInference(\'' + v.video_id + '\')" style="background: #ffa500; font-size: 12px; padding: 5px 10px; margin-right: 5px;">[Start Inference]</button>' +
                        statusToggleBtn +
                        '<button onclick="removeVideo(\'' + v.video_id + '\')" style="background: #dc3545; font-size: 12px; padding: 5px 10px;">[Remove]</button>' +
                    '</div>' +
                    '<small style="color: #999;">Frames: ' + (v.total_frames || v.frame_count || 0) +
                        (v.width && v.height ? ' | Resolution: ' + v.width + 'x' + v.height : '') +
                        ' | Annotations: ' + (v.annotations || 0) + '</small>' +
                '</div>';
            }).join('');
        }

        // ì–´ë…¸í…Œì´ì…˜ ì‹œì‘
        async function startAnnotation(videoId) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                // ë¹„ë””ì˜¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId);
                const data = await response.json();

                if (data.success && data.video) {
                    // annotation íƒ­ìœ¼ë¡œ ì „í™˜
                    showTab('annotation');

                    // ë¹„ë””ì˜¤ ì •ë³´ ì €ì¥
                    currentProjectId = currentProject.id;
                    currentVideoId = videoId;
                    console.log('[VIDEO STATUS] Full video data:', JSON.stringify(data.video));
                    console.log('[VIDEO STATUS] Status field:', data.video.status);
                    currentVideoStatus = data.video.status || 'in_progress';
                    console.log('[VIDEO STATUS] Current video status set to:', currentVideoStatus);
                    totalFrames = data.video.total_frames || data.video.frame_count;

                    // ì™¼ìª½ íŒ¨ë„ì— í”„ë¡œì íŠ¸ ë° ë¹„ë””ì˜¤ ì •ë³´ í‘œì‹œ
                    document.getElementById('currentProjectDisplay').innerHTML =
                        '<strong>' + currentProject.name + '</strong><br>' +
                        '<small style="color: #888;">ID: ' + currentProject.id + '</small>';

                    // ìƒìœ„ í´ë” ì •ë³´ êµ¬ì„±
                    let folderInfo = '';
                    if (data.video.nas_metadata && data.video.nas_metadata.parent_dir) {
                        const parentDir = data.video.nas_metadata.parent_dir;
                        const nasFolder = data.video.nas_metadata.nas_folder || '';

                        // ë””ë ‰í† ë¦¬ ë©”íƒ€ë°ì´í„° íŒŒì‹± (í•˜ì´í”ˆìœ¼ë¡œ êµ¬ë¶„)
                        const parts = parentDir.split('-').map(p => p.trim()).filter(p => p);
                        const dirDisplay = parts.length > 0 ? parts.join(' - ') : parentDir;

                        folderInfo = '<small style="color: #888;">ğŸ“ ' +
                            (nasFolder ? nasFolder + ' / ' : '') +
                            dirDisplay + '</small><br>';
                    }

                    document.getElementById('currentVideoDisplay').innerHTML =
                        '<strong style="color: #4a9eff;">' + data.video.filename + '</strong><br>' +
                        folderInfo +
                        '<small>Total Frames: ' + totalFrames + '</small><br>' +
                        '<small>Current: <span id="currentFrameInfo">0</span></small>';

                    // ë¹„ë””ì˜¤ ë³€ê²½ ì‹œ ì–´ë…¸í…Œì´ì…˜ ì´ˆê¸°í™”
                    frameAnnotations = {};
                    savedFrameAnnotations = {};
                    updateStatistics(); // Statistics ì´ˆê¸°í™”

                    console.log('[INFO] Video info loaded:', data.video);
                    console.log('[INFO] Total frames:', totalFrames);
                    console.log('[INFO] Annotations cleared for new video');

                    // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ì´ˆê¸°í™”
                    await initVideoPlayer();

                    // ë¹„ë””ì˜¤ ìƒíƒœì— ë”°ë¥¸ UI ì—…ë°ì´íŠ¸
                    updateAnnotationUIForStatus();

                } else {
                    alert('[ERROR] ë¹„ë””ì˜¤ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
                }
            } catch (error) {
                console.error('Start annotation error:', error);
                alert('[ERROR] ì–´ë…¸í…Œì´ì…˜ ì‹œì‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ë¡  ì‹œì‘
        async function startVideoInference(videoId) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                // ë¹„ë””ì˜¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId);
                const data = await response.json();

                if (data.success && data.video) {
                    // Inference íƒ­ìœ¼ë¡œ ì „í™˜
                    showTab('inference');

                    // ë¹„ë””ì˜¤ ì •ë³´ ì €ì¥
                    currentProjectId = currentProject.id;
                    currentVideoId = videoId;

                    // Inference íƒ­ì˜ ì„¤ì • ìë™ ì…ë ¥
                    document.getElementById('inferenceModelType').value = 'segformer';

                    // API ì‘ë‹µì—ì„œ ë°›ì€ ì ˆëŒ€ ê²½ë¡œ ì‚¬ìš© (Synology ë§ˆìš´íŠ¸ ê²½ë¡œ í¬í•¨)
                    const videoPath = data.video.path;
                    document.getElementById('inferenceVideoPath').value = videoPath;

                    // ëª¨ë¸ ê²½ë¡œëŠ” ë¹„ì›Œë‘  (ìë™ìœ¼ë¡œ í”„ë¡œì íŠ¸ ëª¨ë¸ ì‚¬ìš©)
                    document.getElementById('inferenceModelPath').value = '';

                    // ì¶œë ¥ ê²½ë¡œ ì„¤ì • (ë¹„ë””ì˜¤ì™€ ê°™ì€ ë””ë ‰í† ë¦¬ì— inference_results í´ë”)
                    const videoDir = videoPath.substring(0, videoPath.lastIndexOf('/'));
                    document.getElementById('inferenceOutputPath').value = `${videoDir}/inference_results`;

                    console.log('[INFO] Video inference setup:', {
                        videoId: videoId,
                        filename: data.video.filename,
                        videoPath: videoPath,
                        outputPath: `${videoDir}/inference_results`
                    });

                    alert('Inference íƒ­ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.\n\në¹„ë””ì˜¤: ' + data.video.filename + '\n\nì„¤ì •ì„ í™•ì¸í•˜ê³  "Start Inference" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.');
                } else {
                    alert('[ERROR] ë¹„ë””ì˜¤ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
                }
            } catch (error) {
                console.error('Start video inference error:', error);
                alert('[ERROR] Inference ì‹œì‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // í”„ë¡œì íŠ¸ ë‹«ê¸°
        // ì–´ë…¸í…Œì´ì…˜ ëŒ€ì‹œë³´ë“œ ë¡œë“œ

        // ì–´ë…¸í…Œì´ì…˜ ëŒ€ì‹œë³´ë“œ ë¡œë“œ (ì „ì²´ ë˜ëŠ” í”„ë¡œì íŠ¸ë³„)
        async function loadAnnotationDashboard() {
            const dashboard = document.getElementById('globalAnnotationDashboard');
            const titleEl = document.getElementById('annotationDashboardTitle');
            dashboard.innerHTML = '<span style="color: #888;">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>';

            try {
                let apiUrl, titleText;

                // í”„ë¡œì íŠ¸ê°€ ì—´ë ¤ìˆìœ¼ë©´ í”„ë¡œì íŠ¸ë³„ í†µê³„, ì•„ë‹ˆë©´ ì „ì²´ í†µê³„
                if (currentProject) {
                    apiUrl = `/api/projects/${encodeURIComponent(currentProject.id)}/annotations/summary`;
                    titleText = `ğŸ“Š ${currentProject.name} - ì–´ë…¸í…Œì´ì…˜ í˜„í™©`;
                } else {
                    apiUrl = `/api/annotations/global-summary`;
                    titleText = 'ğŸ“Š ì „ì²´ ì–´ë…¸í…Œì´ì…˜ í˜„í™©';
                }

                // ì œëª© ì—…ë°ì´íŠ¸
                titleEl.innerHTML = titleText + '<button onclick="refreshAnnotationDashboard()" style="font-size: 12px; padding: 5px 10px; margin-left: 10px; background: #555;">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>';

                const response = await fetch(apiUrl, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('ëŒ€ì‹œë³´ë“œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤');
                }

                const data = await response.json();

                if (data.success) {
                    displayAnnotationDashboard(data.summary, !!currentProject);
                } else {
                    dashboard.innerHTML = '<span style="color: #f44;">ì˜¤ë¥˜: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜') + '</span>';
                }
            } catch (error) {
                console.error('ëŒ€ì‹œë³´ë“œ ë¡œë“œ ì˜¤ë¥˜:', error);
                dashboard.innerHTML = '<span style="color: #f44;">ëŒ€ì‹œë³´ë“œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</span>';
            }
        }

        // ë ˆê±°ì‹œ í•¨ìˆ˜ (í•˜ìœ„ í˜¸í™˜ì„±)
        async function loadGlobalAnnotationDashboard() {
            await loadAnnotationDashboard();
        }

        // ì–´ë…¸í…Œì´ì…˜ ëŒ€ì‹œë³´ë“œ í‘œì‹œ (ì „ì²´ ë˜ëŠ” í”„ë¡œì íŠ¸ë³„)
        function displayAnnotationDashboard(summary, isProjectView) {
            const dashboard = document.getElementById('globalAnnotationDashboard');

            if (!summary) {
                dashboard.innerHTML = '<span style="color: #888;">ì–´ë…¸í…Œì´ì…˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤</span>';
                return;
            }

            const totalAnnotations = summary.total_annotations || 0;
            const totalFrames = summary.total_frames || 0;
            const totalProjects = summary.total_projects;
            const totalVideos = summary.total_videos;

            let html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px;">`;

            // ì „ì²´ í˜„í™©ì´ë©´ í”„ë¡œì íŠ¸ ìˆ˜ í‘œì‹œ, í”„ë¡œì íŠ¸ë³„ì´ë©´ ë¹„ë””ì˜¤ ìˆ˜ í‘œì‹œ
            if (!isProjectView && totalProjects !== undefined) {
                html += `
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #4a9eff;">${totalProjects.toLocaleString()}</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">ì´ í”„ë¡œì íŠ¸</div>
                    </div>`;
            } else if (isProjectView && totalVideos !== undefined) {
                html += `
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #4a9eff;">${totalVideos.toLocaleString()}</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">ì´ ë¹„ë””ì˜¤</div>
                    </div>`;
            }

            html += `
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745;">${totalFrames.toLocaleString()}</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">ì–´ë…¸í…Œì´ì…˜ëœ í”„ë ˆì„</div>
                    </div>
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #ffa500;">${totalAnnotations.toLocaleString()}</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- í´ë˜ìŠ¤ë³„ í†µê³„ -->
                    <div>
                        <h4 style="margin-top: 0; margin-bottom: 10px; color: #ccc; font-size: 14px;">í´ë˜ìŠ¤ë³„ ì–´ë…¸í…Œì´ì…˜</h4>
                        <div style="background: #2a2a2a; padding: 12px; border-radius: 4px; max-height: 250px; overflow-y: auto;">
            `;

            // í´ë˜ìŠ¤ë³„ í†µê³„ í‘œì‹œ
            const classesByCount = summary.by_class || {};
            const sortedClasses = Object.entries(classesByCount).sort((a, b) => b[1] - a[1]);

            if (sortedClasses.length > 0) {
                sortedClasses.forEach(([className, count]) => {
                    const percentage = totalAnnotations > 0 ? ((count / totalAnnotations) * 100).toFixed(1) : 0;
                    html += `
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                                <span style="font-size: 13px; color: #ccc;">${className}</span>
                                <span style="font-size: 13px; color: #4a9eff; font-weight: bold;">${count.toLocaleString()} (${percentage}%)</span>
                            </div>
                            <div style="width: 100%; height: 6px; background: #1a1a1a; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${percentage}%; height: 100%; background: #4a9eff; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<span style="color: #888; font-size: 12px;">ë°ì´í„° ì—†ìŒ</span>';
            }

            html += `
                        </div>
                    </div>

                    <!-- ì‘ì—…ìë³„ í†µê³„ -->
                    <div>
                        <h4 style="margin-top: 0; margin-bottom: 10px; color: #ccc; font-size: 14px;">ì‘ì—…ìë³„ ì–´ë…¸í…Œì´ì…˜</h4>
                        <div style="background: #2a2a2a; padding: 12px; border-radius: 4px; max-height: 250px; overflow-y: auto;">
            `;

            // ì‘ì—…ìë³„ í†µê³„ í‘œì‹œ
            const workersByCount = summary.by_worker || {};
            const sortedWorkers = Object.entries(workersByCount).sort((a, b) => b[1] - a[1]);

            if (sortedWorkers.length > 0) {
                sortedWorkers.forEach(([workerName, count]) => {
                    const percentage = totalAnnotations > 0 ? ((count / totalAnnotations) * 100).toFixed(1) : 0;
                    html += `
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                                <span style="font-size: 13px; color: #ccc;">${workerName || 'ì•Œ ìˆ˜ ì—†ìŒ'}</span>
                                <span style="font-size: 13px; color: #28a745; font-weight: bold;">${count.toLocaleString()} (${percentage}%)</span>
                            </div>
                            <div style="width: 100%; height: 6px; background: #1a1a1a; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${percentage}%; height: 100%; background: #28a745; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<span style="color: #888; font-size: 12px;">ë°ì´í„° ì—†ìŒ</span>';
            }

            html += `
                        </div>
                    </div>
                </div>
            `;

            dashboard.innerHTML = html;
        }

        // ëŒ€ì‹œë³´ë“œ ìƒˆë¡œê³ ì¹¨
        function refreshAnnotationDashboard() {
            loadAnnotationDashboard();
        }

        // ë ˆê±°ì‹œ í•¨ìˆ˜ (í•˜ìœ„ í˜¸í™˜ì„±)
        function refreshGlobalDashboard() {
            refreshAnnotationDashboard();
        }

        // ë ˆê±°ì‹œ í•¨ìˆ˜ (í•˜ìœ„ í˜¸í™˜ì„±)
        function displayGlobalAnnotationDashboard(summary) {
            displayAnnotationDashboard(summary, false);
        }

        function closeProject() {
            currentProject = null;
            document.getElementById('currentProjectSection').style.display = 'none';

            // í”„ë¡œì íŠ¸ë¥¼ ë‹«ìœ¼ë©´ ì „ì²´ í†µê³„ë¡œ ë³µì›
            loadAnnotationDashboard();
        }

        // í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ ì—´ê¸°
        function openProjectSettings() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            // ì„ì‹œ í´ë˜ìŠ¤ ëª©ë¡ ì´ˆê¸°í™”
            let classes = currentProject.classes;
            if (typeof classes === 'string') {
                // ë¬¸ìì—´ì¸ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)
                classes = classes.split(',').map(c => c.trim()).filter(c => c.length > 0);
                tempClassList = classes.map(name => ({ name: name, description: '' }));
            } else if (Array.isArray(classes)) {
                // ë°°ì—´ì¸ ê²½ìš°
                tempClassList = classes.map(cls => {
                    if (typeof cls === 'string') {
                        // ë¬¸ìì—´ ë°°ì—´ (í•˜ìœ„ í˜¸í™˜ì„±)
                        return { name: cls, description: '' };
                    } else if (cls.name) {
                        // ê°ì²´ ë°°ì—´
                        return { name: cls.name, description: cls.description || '' };
                    }
                    return { name: '', description: '' };
                }).filter(cls => cls.name.length > 0);
            } else {
                tempClassList = [];
            }

            // ëª¨ë‹¬ ì •ë³´ ì—…ë°ì´íŠ¸
            document.getElementById('settingsProjectName').value = currentProject.name;
            document.getElementById('settingsProjectId').textContent = currentProject.id;

            // í´ë˜ìŠ¤ ëª©ë¡ í‘œì‹œ
            updateSettingsClassList();

            // ëª¨ë‹¬ í‘œì‹œ
            document.getElementById('projectSettingsModal').classList.add('show');
        }

        // í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ ë‹«ê¸°
        function closeProjectSettings() {
            document.getElementById('projectSettingsModal').classList.remove('show');
            document.getElementById('newClassName').value = '';
            document.getElementById('newClassDescription').value = '';
        }

        // ì–´ë…¸í…Œì´ì…˜ ë„ì›€ë§ ëª¨ë‹¬ ì—´ê¸°/ë‹«ê¸°
        function showAnnotationHelp() {
            document.getElementById('annotationHelpModal').classList.add('show');
        }

        function closeAnnotationHelp() {
            document.getElementById('annotationHelpModal').classList.remove('show');
        }

        // ì„¤ì • ëª¨ë‹¬ì˜ í´ë˜ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateSettingsClassList() {
            const container = document.getElementById('settingsClassList');

            if (tempClassList.length === 0) {
                container.innerHTML = '<p style="color: #888; font-size: 12px;">í´ë˜ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            container.innerHTML = '';

            tempClassList.forEach((classObj, index) => {
                const item = document.createElement('div');
                item.className = 'class-item';
                item.style.display = 'flex';
                item.style.flexDirection = 'column';
                item.style.gap = '5px';
                item.style.marginBottom = '10px';
                item.style.padding = '10px';
                item.style.background = '#1e1e1e';
                item.style.borderRadius = '4px';

                const headerDiv = document.createElement('div');
                headerDiv.style.display = 'flex';
                headerDiv.style.justifyContent = 'space-between';
                headerDiv.style.alignItems = 'center';

                const nameSpan = document.createElement('span');
                // í´ë˜ìŠ¤ ì´ë¦„ê³¼ ì„¤ëª…ì„ ëª…í™•íˆ êµ¬ë¶„í•˜ì—¬ í‘œì‹œ
                const displayText = classObj.description
                    ? `${index + 1}. ${classObj.name} (${classObj.description})`
                    : `${index + 1}. ${classObj.name}`;
                nameSpan.textContent = displayText;
                nameSpan.style.fontWeight = '600';
                nameSpan.style.color = '#4a9eff';
                nameSpan.style.cursor = 'pointer';
                nameSpan.title = 'ìš°í´ë¦­í•˜ì—¬ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½';

                // ìš°í´ë¦­ìœ¼ë¡œ í´ë˜ìŠ¤ ì´ë¦„ ìˆ˜ì •
                nameSpan.oncontextmenu = function(e) {
                    e.preventDefault();
                    const newName = prompt('ìƒˆ í´ë˜ìŠ¤ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', classObj.name);
                    if (newName && newName.trim() && newName.trim() !== classObj.name) {
                        const trimmedName = newName.trim();
                        // ì¤‘ë³µ ì²´í¬
                        const exists = tempClassList.some((cls, idx) => idx !== index && cls.name === trimmedName);
                        if (exists) {
                            alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í´ë˜ìŠ¤ ì´ë¦„ì…ë‹ˆë‹¤.');
                            return;
                        }
                        tempClassList[index].name = trimmedName;
                        updateSettingsClassList();
                        console.log('[SETTINGS] Renamed class to:', trimmedName);
                    }
                };

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'ğŸ—‘ï¸ ì‚­ì œ';
                deleteBtn.style.padding = '4px 8px';
                deleteBtn.style.fontSize = '11px';
                deleteBtn.onclick = function() {
                    removeClass(index);
                };

                headerDiv.appendChild(nameSpan);
                headerDiv.appendChild(deleteBtn);

                // ì„¤ëª… í¸ì§‘ ë²„íŠ¼ ì¶”ê°€
                if (classObj.description || true) { // í•­ìƒ í‘œì‹œ
                    const editDescBtn = document.createElement('button');
                    editDescBtn.textContent = classObj.description ? 'âœï¸ ì„¤ëª… í¸ì§‘' : 'â• ì„¤ëª… ì¶”ê°€';
                    editDescBtn.style.padding = '4px 8px';
                    editDescBtn.style.fontSize = '11px';
                    editDescBtn.style.marginLeft = '8px';
                    editDescBtn.style.background = '#555';
                    editDescBtn.onclick = function() {
                        const newDesc = prompt('í´ë˜ìŠ¤ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”:', classObj.description || '');
                        if (newDesc !== null) {
                            tempClassList[index].description = newDesc.trim();
                            updateSettingsClassList();
                            console.log('[SETTINGS] Updated description for', classObj.name);
                        }
                    };
                    headerDiv.appendChild(editDescBtn);
                }

                item.appendChild(headerDiv);
                container.appendChild(item);
            });
        }

        // í´ë˜ìŠ¤ ì¶”ê°€
        function addClass() {
            const nameInput = document.getElementById('newClassName');
            const descInput = document.getElementById('newClassDescription');
            const className = nameInput.value.trim();
            const classDescription = descInput.value.trim();

            if (!className) {
                alert('í´ë˜ìŠ¤ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            // ì¤‘ë³µ ì²´í¬
            const exists = tempClassList.some(cls => cls.name === className);
            if (exists) {
                alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í´ë˜ìŠ¤ ì´ë¦„ì…ë‹ˆë‹¤.');
                return;
            }

            tempClassList.push({
                name: className,
                description: classDescription
            });

            nameInput.value = '';
            descInput.value = '';
            updateSettingsClassList();

            console.log('[SETTINGS] Added class:', className, 'with description:', classDescription);
        }

        // í´ë˜ìŠ¤ ì‚­ì œ
        function removeClass(index) {
            const classObj = tempClassList[index];
            if (!confirm(`'${classObj.name}' í´ë˜ìŠ¤ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            const removed = tempClassList.splice(index, 1);
            updateSettingsClassList();

            console.log('[SETTINGS] Removed class:', removed[0].name);
        }

        // í”„ë¡œì íŠ¸ ì„¤ì • ì €ì¥
        async function saveProjectSettings() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            if (tempClassList.length === 0) {
                alert('ìµœì†Œ 1ê°œ ì´ìƒì˜ í´ë˜ìŠ¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }

            // í”„ë¡œì íŠ¸ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
            const newProjectName = document.getElementById('settingsProjectName').value.trim();
            if (!newProjectName) {
                alert('í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProject.id, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: newProjectName,
                        classes: tempClassList
                    })
                });

                const data = await response.json();

                if (data.success) {
                    alert('í”„ë¡œì íŠ¸ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');

                    // currentProject ì—…ë°ì´íŠ¸
                    currentProject.name = newProjectName;
                    currentProject.classes = [...tempClassList];

                    // í”„ë¡œì íŠ¸ ì •ë³´ í‘œì‹œ ì˜ì—­ ì—…ë°ì´íŠ¸
                    document.getElementById('currentProjectName').textContent = newProjectName;

                    // í´ë˜ìŠ¤ ì •ë³´ ì—…ë°ì´íŠ¸
                    const stats = currentProject.stats || {
                        total_videos: 0,
                        annotated_videos: 0,
                        total_annotations: 0,
                        annotated_frames: 0,
                        datasets: 0
                    };
                    document.getElementById('currentProjectStats').innerHTML =
                        'ID: ' + currentProject.id + '<br>' +
                        'í´ë˜ìŠ¤: ' + (tempClassList.length > 0 ? tempClassList.map(c => getClassDisplayName(c)).join(', ') : 'ì—†ìŒ') + '<br>' +
                        'ë¹„ë””ì˜¤: ' + stats.total_videos + ' (ì™„ë£Œ ' + stats.annotated_videos + ')<br>' +
                        'ì´ ì–´ë…¸í…Œì´ì…˜: ' + stats.total_annotations + ' (' + stats.annotated_frames + ' í”„ë ˆì„)<br>' +
                        'ë°ì´í„°ì…‹: ' + stats.datasets;

                    // ë¼ë””ì˜¤ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                    updateClassRadioButtons();

                    // ì„ íƒëœ í´ë˜ìŠ¤ ì¸ë±ìŠ¤ ì¬ì¡°ì •
                    if (selectedClassIndex >= tempClassList.length) {
                        selectedClassIndex = 0;
                    }

                    // í”„ë¡œì íŠ¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    loadAllProjects();

                    // ëª¨ë‹¬ ë‹«ê¸°
                    closeProjectSettings();

                    console.log('[SETTINGS] Project settings saved successfully');
                } else {
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[SETTINGS] Error saving settings:', error);
                alert('ì„¤ì • ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸
        async function showAddVideoDialog() {
            // Electron í™˜ê²½ ì²´í¬
            if (window.electronAPI && window.electronAPI.openFileDialog) {
                // ì„ íƒ ë°©ë²• í™•ì¸
                const choice = confirm(
                    'ë¹„ë””ì˜¤ ì¶”ê°€ ë°©ë²•:\n\n' +
                    '[í™•ì¸] ë””ë ‰í† ë¦¬ ì„ íƒ (NAS í´ë”ì— ë§ì€ íŒŒì¼ì´ ìˆì„ ë•Œ ë¹ ë¦„)\n' +
                    '[ì·¨ì†Œ] íŒŒì¼ ì§ì ‘ ì„ íƒ (ê°œë³„ íŒŒì¼ ì„ íƒ)'
                );

                if (choice) {
                    // ë°©ë²• 1: ë””ë ‰í† ë¦¬ ì„ íƒ (ë” ë¹ ë¦„)
                    const result = await window.electronAPI.openFileDialog({
                        properties: ['openDirectory'],
                        title: 'ë¹„ë””ì˜¤ê°€ ìˆëŠ” ë””ë ‰í† ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”'
                    });

                    if (!result.canceled && result.filePaths.length > 0) {
                        const dirPath = result.filePaths[0];
                        console.log(`[VIDEO] Scanning directory: ${dirPath}`);

                        // ë°±ì—”ë“œì— ë””ë ‰í† ë¦¬ ê²½ë¡œ ì „ë‹¬í•˜ì—¬ ë¹„ë””ì˜¤ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                        try {
                            const response = await authFetch('/api/scan-videos', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ directory: dirPath })
                            });

                            const data = await response.json();

                            if (data.success && data.videos.length > 0) {
                                // ë°œê²¬ëœ ë¹„ë””ì˜¤ ëª©ë¡ í‘œì‹œ ë° ì„ íƒ
                                const videoList = data.videos.map((v, i) => `${i + 1}. ${v.name}`).join('\n');
                                const confirmAdd = confirm(
                                    `${data.videos.length}ê°œì˜ ë¹„ë””ì˜¤ íŒŒì¼ì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤:\n\n` +
                                    videoList.slice(0, 500) + (videoList.length > 500 ? '\n...' : '') +
                                    `\n\nëª¨ë‘ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
                                );

                                if (confirmAdd) {
                                    let successCount = 0;
                                    let failCount = 0;

                                    for (const video of data.videos) {
                                        const success = await addVideo(video.path);
                                        if (success) successCount++;
                                        else failCount++;
                                    }

                                    await openProject(currentProject.id);

                                    if (failCount === 0) {
                                        alert(`âœ… ${successCount}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                                    } else {
                                        alert(`âš ï¸ ì¶”ê°€ ì™„ë£Œ:\nì„±ê³µ: ${successCount}ê°œ\nì‹¤íŒ¨: ${failCount}ê°œ`);
                                    }
                                }
                            } else {
                                alert('ì„ íƒí•œ ë””ë ‰í† ë¦¬ì—ì„œ ë¹„ë””ì˜¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                            }
                        } catch (error) {
                            console.error('[VIDEO] Directory scan error:', error);
                            alert('ë””ë ‰í† ë¦¬ ìŠ¤ìº” ì˜¤ë¥˜: ' + error.message);
                        }
                    }
                } else {
                    // ë°©ë²• 2: íŒŒì¼ ì§ì ‘ ì„ íƒ (ê¸°ì¡´ ë°©ì‹)
                    const result = await window.electronAPI.openFileDialog({
                        properties: ['openFile', 'multiSelections'],
                        filters: [
                            { name: 'Videos', extensions: ['mp4', 'avi', 'mov', 'mkv'] }
                        ]
                    });

                    if (!result.canceled && result.filePaths.length > 0) {
                        console.log(`[VIDEO] Adding ${result.filePaths.length} video(s)...`);
                        let successCount = 0;
                        let failCount = 0;

                        for (const videoPath of result.filePaths) {
                            const success = await addVideo(videoPath);
                            if (success) successCount++;
                            else failCount++;
                        }

                        await openProject(currentProject.id);

                        if (failCount === 0) {
                            alert(`âœ… ${successCount}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                        } else {
                            alert(`âš ï¸ ì¶”ê°€ ì™„ë£Œ:\nì„±ê³µ: ${successCount}ê°œ\nì‹¤íŒ¨: ${failCount}ê°œ`);
                        }
                    }
                }
            } else {
                // ì›¹ ë¸Œë¼ìš°ì € í™˜ê²½: ì„ íƒ ì˜µì…˜ í‘œì‹œ
                const choice = confirm(
                    'ë¹„ë””ì˜¤ ì¶”ê°€ ë°©ë²•:\n\n' +
                    '[í™•ì¸] NAS ë¹„ë””ì˜¤ ì„ íƒ (ì„œë²„ì˜ NAS í´ë”ì—ì„œ ì„ íƒ)\n' +
                    '[ì·¨ì†Œ] íŒŒì¼ ì—…ë¡œë“œ (ë¡œì»¬ PCì—ì„œ íŒŒì¼ ì„ íƒ)'
                );

                if (choice) {
                    // NAS ë¹„ë””ì˜¤ ì„ íƒ
                    showNasVideoSelectionDialog();
                } else {
                    // íŒŒì¼ ì—…ë¡œë“œ (ê¸°ì¡´ ë°©ì‹)
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'video/mp4,video/avi,video/mov,video/x-matroska';
                    input.multiple = true; // ë‹¤ì¤‘ ì„ íƒ í™œì„±í™”
                    input.onchange = async (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length > 0) {
                            // ë¶€ëª¨ ë””ë ‰í† ë¦¬ëª… ì…ë ¥ë°›ê¸°
                            const parentDir = prompt(`${files.length}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì†í•œ ë””ë ‰í† ë¦¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­):\nì˜ˆ: 359-ì§‘ë°©-100MM-HIVP`, '');

                            console.log(`[VIDEO] Uploading ${files.length} video(s)...`);
                            let successCount = 0;
                            let failCount = 0;

                            // ì—¬ëŸ¬ íŒŒì¼ ìˆœì°¨ ì—…ë¡œë“œ
                            for (const file of files) {
                                const success = await addVideoFile(file, parentDir);
                                if (success) successCount++;
                                else failCount++;
                            }

                            // ì™„ë£Œ í›„ í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
                            await openProject(currentProject.id);

                            // ê²°ê³¼ ìš”ì•½ í‘œì‹œ
                            if (failCount === 0) {
                                alert(`âœ… ${successCount}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!`);
                            } else {
                                alert(`âš ï¸ ì—…ë¡œë“œ ì™„ë£Œ:\nì„±ê³µ: ${successCount}ê°œ\nì‹¤íŒ¨: ${failCount}ê°œ`);
                            }
                        }
                    };
                    input.click();
                }
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ê°€ (Electron í™˜ê²½ - íŒŒì¼ ê²½ë¡œ)
        async function addVideo(videoPath) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return false;
            }

            const fileName = videoPath.split('/').pop();
            console.log(`[VIDEO] Adding video: ${fileName}`);

            try {
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ video_path: videoPath })
                });

                const data = await response.json();

                if (data.success) {
                    console.log(`[VIDEO] âœ… Video added: ${fileName} (ID: ${data.video_id})`);
                    return true;
                } else {
                    console.error(`[VIDEO] âŒ Failed to add ${fileName}:`, data.error);
                    return false;
                }
            } catch (error) {
                console.error('[VIDEO] Add video error:', error);
                return false;
            }
        }

        // ë¹„ë””ì˜¤ ì¶”ê°€ (ì›¹ ë¸Œë¼ìš°ì € í™˜ê²½ - File ê°ì²´)
        async function addVideoFile(file, parentDir) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return false;
            }

            // ì§„í–‰ ë°” í‘œì‹œ
            const progressDiv = document.getElementById('uploadProgress');
            const progressBar = document.getElementById('uploadProgressBar');
            const progressPercent = document.getElementById('uploadPercent');
            const fileName = document.getElementById('uploadFileName');
            const statusText = document.getElementById('uploadStatus');

            progressDiv.style.display = 'block';
            fileName.textContent = file.name;
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            statusText.textContent = 'ì—…ë¡œë“œ ì¤€ë¹„ ì¤‘...';

            return new Promise((resolve) => {
                const formData = new FormData();
                formData.append('video', file);
                // ë¶€ëª¨ ë””ë ‰í† ë¦¬ëª… ì¶”ê°€ (ìˆì„ ê²½ìš°)
                if (parentDir && parentDir.trim()) {
                    formData.append('parent_dir', parentDir.trim());
                }

                const xhr = new XMLHttpRequest();
                const sessionId = getSessionId();

                // ì—…ë¡œë“œ ì§„í–‰ë¥  ì¶”ì 
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percentComplete + '%';
                        progressPercent.textContent = percentComplete + '%';

                        const uploadedMB = (e.loaded / 1024 / 1024).toFixed(2);
                        const totalMB = (e.total / 1024 / 1024).toFixed(2);
                        statusText.textContent = `ì—…ë¡œë“œ ì¤‘... ${uploadedMB} MB / ${totalMB} MB`;
                    }
                });

                // ì—…ë¡œë“œ ì™„ë£Œ
                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        try {
                            const data = JSON.parse(xhr.responseText);

                            if (data.success) {
                                progressBar.style.background = 'linear-gradient(90deg, #4caf50, #45a049)';
                                statusText.textContent = 'âœ… ì—…ë¡œë“œ ì™„ë£Œ!';
                                console.log(`[VIDEO] âœ… Video uploaded: ${file.name} (ID: ${data.video_id})`);

                                setTimeout(() => {
                                    progressDiv.style.display = 'none';
                                    progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                                    resolve(true);
                                }, 1000);
                            } else {
                                progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                                statusText.textContent = 'âŒ ì˜¤ë¥˜: ' + data.error;
                                console.error(`[VIDEO] âŒ Failed to upload ${file.name}:`, data.error);
                                setTimeout(() => {
                                    progressDiv.style.display = 'none';
                                    progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                                    resolve(false);
                                }, 2000);
                            }
                        } catch (error) {
                            console.error('Parse error:', error);
                            progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                            statusText.textContent = 'âŒ ì‘ë‹µ ì²˜ë¦¬ ì˜¤ë¥˜';
                            setTimeout(() => {
                                progressDiv.style.display = 'none';
                                progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                                resolve(false);
                            }, 2000);
                        }
                    } else {
                        progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                        statusText.textContent = `âŒ ì—…ë¡œë“œ ì‹¤íŒ¨ (HTTP ${xhr.status})`;
                        console.error(`[VIDEO] âŒ Upload failed: HTTP ${xhr.status}`);
                        setTimeout(() => {
                            progressDiv.style.display = 'none';
                            progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                            resolve(false);
                        }, 2000);
                    }
                });

                // ì—…ë¡œë“œ ì—ëŸ¬
                xhr.addEventListener('error', () => {
                    progressBar.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
                    statusText.textContent = 'âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜';
                    console.error(`[VIDEO] âŒ Network error while uploading ${file.name}`);
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                        progressBar.style.background = 'linear-gradient(90deg, #4a9eff, #2e7bd4)';
                        resolve(false);
                    }, 2000);
                });

                // ì—…ë¡œë“œ ì·¨ì†Œ
                xhr.addEventListener('abort', () => {
                    progressBar.style.background = 'linear-gradient(90deg, #ff9800, #f57c00)';
                    statusText.textContent = 'âš ï¸ ì—…ë¡œë“œ ì·¨ì†Œë¨';
                    setTimeout(() => progressDiv.style.display = 'none', 2000);
                    reject(new Error('Upload cancelled'));
                });

                // ìš”ì²­ ì „ì†¡
                xhr.open('POST', API_BASE_URL + '/api/projects/' + currentProject.id + '/videos');
                xhr.setRequestHeader('X-Session-ID', sessionId);
                xhr.send(formData);
            });
        }

        // NAS ë¹„ë””ì˜¤ ì„ íƒ ê´€ë ¨ í•¨ìˆ˜ë“¤
        let nasVideos = [];
        let nasSelectedVideos = new Set();
        let nasCurrentPage = 1;
        let nasTotalPages = 1;
        let nasIsLoading = false;
        let nasCacheStats = null;
        let allUserCompletedVideos = new Set();  // ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ì™„ë£Œëœ ë¹„ë””ì˜¤

        // ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ì™„ë£Œëœ ë¹„ë””ì˜¤ ë¡œë“œ
        async function loadAllUserCompletedVideos() {
            console.log('[NAS] Loading all user completed videos...');
            allUserCompletedVideos.clear();

            try {
                // í˜„ì¬ ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch('/api/projects');
                const data = await response.json();

                if (data.success && data.projects) {
                    console.log(`[NAS] Found ${data.projects.length} projects`);

                    // ê° í”„ë¡œì íŠ¸ì˜ ì™„ë£Œëœ ë¹„ë””ì˜¤ ìˆ˜ì§‘
                    for (const project of data.projects) {
                        try {
                            const projectResponse = await authFetch(`/api/projects/${project.id}`);
                            const projectData = await projectResponse.json();

                            if (projectData.success && projectData.project.videos) {
                                projectData.project.videos.forEach(v => {
                                    if (v.status === 'completed') {
                                        // nas_video_pathì™€ filename ëª¨ë‘ ì €ì¥
                                        if (v.nas_video_path) {
                                            allUserCompletedVideos.add(v.nas_video_path);
                                        }
                                        if (v.filename) {
                                            allUserCompletedVideos.add(v.filename);
                                        }
                                    }
                                });
                            }
                        } catch (error) {
                            console.error(`[NAS] Error loading project ${project.id}:`, error);
                        }
                    }

                    console.log(`[NAS] Total completed videos: ${allUserCompletedVideos.size}`);
                }
            } catch (error) {
                console.error('[NAS] Error loading user projects:', error);
            }
        }

        async function showNasVideoSelectionDialog() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            console.log('[NAS] Opening NAS video selection dialog...');

            // ëª¨ë‹¬ í‘œì‹œ
            document.getElementById('nasVideoSelectionModal').classList.add('show');

            // ì´ˆê¸°í™”
            nasVideos = [];
            nasSelectedVideos.clear();
            nasCurrentPage = 1;

            // ì‚¬ìš©ìì˜ ëª¨ë“  ì™„ë£Œëœ ë¹„ë””ì˜¤ ë¡œë“œ
            await loadAllUserCompletedVideos();

            console.log('[NAS] Starting to load videos...');
            // ë¹„ë””ì˜¤ ëª©ë¡ì„ ë¨¼ì € ë¡œë“œ (ë¹ ë¦„)
            loadNasVideos(true);

            console.log('[NAS] Starting to load filter options...');
            // í•„í„° ì˜µì…˜ì€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¡œë“œ (ëŠë¦¼, ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ë¹„ë””ì˜¤ ëª©ë¡ì€ í‘œì‹œë¨)
            loadFilterOptions().catch(error => {
                console.error('[NAS] Error loading filter options:', error);
            });
        }

        async function loadFilterOptions() {
            try {
                const response = await authFetch('/api/nas-videos/filter-options');
                const data = await response.json();

                if (data.success) {
                    const options = data.options;

                    // ì§€ì—­ ì˜µì…˜ ì—…ë°ì´íŠ¸
                    const regionSelect = document.getElementById('nasRegionFilter');
                    regionSelect.innerHTML = '<option value="">ì „ì²´</option>';
                    options.regions.forEach(region => {
                        const option = document.createElement('option');
                        option.value = region;
                        option.textContent = region;
                        regionSelect.appendChild(option);
                    });

                    // í¬ê¸° ì˜µì…˜ ì—…ë°ì´íŠ¸
                    const sizeSelect = document.getElementById('nasPipeSizeFilter');
                    sizeSelect.innerHTML = '<option value="">ì „ì²´</option>';
                    options.pipe_sizes.forEach(size => {
                        const option = document.createElement('option');
                        option.value = size;
                        option.textContent = size;
                        sizeSelect.appendChild(option);
                    });

                    // ë°©ë²• ì˜µì…˜ ì—…ë°ì´íŠ¸
                    const methodSelect = document.getElementById('nasMethodFilter');
                    methodSelect.innerHTML = '<option value="">ì „ì²´</option>';
                    options.methods.forEach(method => {
                        const option = document.createElement('option');
                        option.value = method;
                        option.textContent = method;
                        methodSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('[NAS] Error loading filter options:', error);
            }
        }

        async function loadNasVideos(reset = false) {
            console.log('[NAS] loadNasVideos() called, reset:', reset, 'nasIsLoading:', nasIsLoading);
            if (nasIsLoading) {
                console.log('[NAS] Already loading, skipping...');
                return;
            }

            const loadingDiv = document.getElementById('nasLoading');
            const gridDiv = document.getElementById('nasVideoGrid');

            if (reset) {
                nasCurrentPage = 1;
                nasVideos = [];
                gridDiv.innerHTML = '';
            }

            nasIsLoading = true;
            loadingDiv.style.display = 'block';

            try {
                const folderFilter = document.getElementById('nasFolderFilter').value;
                const regionFilter = document.getElementById('nasRegionFilter').value;
                const pipeSizeFilter = document.getElementById('nasPipeSizeFilter').value;
                const methodFilter = document.getElementById('nasMethodFilter').value;

                // í˜ì´ì§€ë„¤ì´ì…˜ íŒŒë¼ë¯¸í„°
                const params = new URLSearchParams({
                    page: nasCurrentPage,
                    page_size: 50
                });

                if (folderFilter) {
                    params.append('folder', folderFilter);
                }
                if (regionFilter) {
                    params.append('region', regionFilter);
                }
                if (pipeSizeFilter) {
                    params.append('pipe_size', pipeSizeFilter);
                }
                if (methodFilter) {
                    params.append('method', methodFilter);
                }

                const url = `/api/nas-videos/list?${params}`;
                console.log('[NAS] Fetching:', url);
                const response = await authFetch(url);
                console.log('[NAS] Response received:', response.status);
                const data = await response.json();
                console.log('[NAS] Data:', data.success, data.videos?.length, 'videos');

                if (data.success) {
                    // ìƒˆ ë¹„ë””ì˜¤ ì¶”ê°€
                    nasVideos.push(...data.videos);

                    // í˜ì´ì§€ë„¤ì´ì…˜ ì •ë³´
                    const pagination = data.pagination;
                    nasTotalPages = pagination.total_pages;
                    nasCacheStats = data.cache_stats;

                    // ìºì‹œ í†µê³„ í‘œì‹œ
                    if (reset) {
                        // í´ë” í•„í„° ì˜µì…˜ ì—…ë°ì´íŠ¸
                        const folderSelect = document.getElementById('nasFolderFilter');
                        if (data.cache_stats && data.cache_stats.by_folder) {
                            // í˜„ì¬ ì„ íƒëœ ê°’ ì €ì¥
                            const currentValue = folderSelect.value;
                            const folders = Object.keys(data.cache_stats.by_folder);
                            folderSelect.innerHTML = '<option value="">ì „ì²´</option>';
                            folders.forEach(folder => {
                                const option = document.createElement('option');
                                option.value = folder;
                                option.textContent = `${folder} (${data.cache_stats.by_folder[folder]})`;
                                folderSelect.appendChild(option);
                            });
                            // ì´ì „ ì„ íƒ ê°’ ë³µì›
                            if (currentValue && folders.includes(currentValue)) {
                                folderSelect.value = currentValue;
                            }
                        }
                    }

                    // ë¹„ë””ì˜¤ ì¹´ë“œ ì¶”ê°€
                    data.videos.forEach(video => {
                        const card = createNasVideoCard(video);
                        gridDiv.appendChild(card);
                    });

                    // ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
                    const countSpan = document.getElementById('nasVideoCount');
                    countSpan.textContent = `${pagination.total_count}ê°œ ë¹„ë””ì˜¤ (${nasCurrentPage}/${pagination.total_pages} í˜ì´ì§€)`;

                    // "ë” ë³´ê¸°" ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
                    updateLoadMoreButton(pagination.has_next);

                } else {
                    throw new Error(data.error || 'Failed to load NAS videos');
                }
            } catch (error) {
                console.error('[NAS] Error loading videos:', error);
                console.error('[NAS] Error stack:', error.stack);
                alert('ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
                if (reset) {
                    gridDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #f44336;">âŒ ë¹„ë””ì˜¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + error.message + '</div>';
                }
            } finally {
                nasIsLoading = false;
                loadingDiv.style.display = 'none';
            }
        }

        function updateLoadMoreButton(hasNext) {
            let loadMoreBtn = document.getElementById('nasLoadMoreButton');

            if (!loadMoreBtn) {
                // "ë” ë³´ê¸°" ë²„íŠ¼ ìƒì„±
                loadMoreBtn = document.createElement('div');
                loadMoreBtn.id = 'nasLoadMoreButton';
                loadMoreBtn.style.cssText = 'text-align: center; padding: 20px;';
                loadMoreBtn.innerHTML = '<button onclick="loadMoreNasVideos()" style="padding: 10px 30px; background: #4a9eff;">ë” ë³´ê¸°</button>';
                document.getElementById('nasVideoGrid').insertAdjacentElement('afterend', loadMoreBtn);
            }

            loadMoreBtn.style.display = hasNext ? 'block' : 'none';
        }

        async function loadMoreNasVideos() {
            nasCurrentPage++;
            await loadNasVideos(false);
        }

        function filterNasVideos() {
            // í•„í„° ë³€ê²½ ì‹œ í˜ì´ì§€ ë¦¬ì…‹í•˜ê³  ë‹¤ì‹œ ë¡œë“œ
            loadNasVideos(true);
        }

        function createNasVideoCard(video) {
            const card = document.createElement('div');
            card.className = 'nas-video-card';
            card.dataset.videoPath = video.path;

            // ì„ íƒ ìƒíƒœ í™•ì¸
            if (nasSelectedVideos.has(video.path)) {
                card.classList.add('selected');
            }

            // ì‚¬ìš©ìì˜ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ì™„ë£Œëœ ë¹„ë””ì˜¤ì¸ì§€ í™•ì¸
            const isCompleted = allUserCompletedVideos.has(video.path) || allUserCompletedVideos.has(video.name);

            // ì¸ë„¤ì¼ ë˜í¼ (ì™„ë£Œ ì˜¤ë²„ë ˆì´ë¥¼ ìœ„í•œ ì»¨í…Œì´ë„ˆ)
            const thumbnailWrapper = document.createElement('div');
            thumbnailWrapper.className = 'nas-video-thumbnail-wrapper';

            // ì¸ë„¤ì¼ (original_path ì‚¬ìš©, ì—†ìœ¼ë©´ path ì‚¬ìš©)
            const thumbnail = document.createElement('img');
            thumbnail.className = 'nas-video-thumbnail';
            const thumbnailPath = video.original_path || video.path;
            thumbnail.src = `${API_BASE_URL}/api/nas-videos/thumbnail?path=${encodeURIComponent(thumbnailPath)}`;
            thumbnail.alt = video.name;
            thumbnail.onerror = () => {
                thumbnail.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect fill="%23333" width="100" height="100"/><text x="50%" y="50%" text-anchor="middle" fill="%23888" font-size="12">No Preview</text></svg>';
            };

            thumbnailWrapper.appendChild(thumbnail);

            // ì™„ë£Œ ì˜¤ë²„ë ˆì´ ì¶”ê°€
            if (isCompleted) {
                const overlay = document.createElement('div');
                overlay.className = 'nas-video-completed-overlay';
                overlay.innerHTML = `
                    <div class="checkmark">âœ“</div>
                    <div>ì™„ë£Œ</div>
                `;
                thumbnailWrapper.appendChild(overlay);
            }

            // ë¹„ë””ì˜¤ ì •ë³´
            const info = document.createElement('div');
            info.className = 'nas-video-info';

            // ë””ë ‰í† ë¦¬ ë©”íƒ€ë°ì´í„° í‘œì‹œ (í•˜ì´í”ˆìœ¼ë¡œ êµ¬ë¶„ëœ ë¶€ë¶„ë“¤)
            const dirMetaParts = video.dir_metadata.parts || [];
            const dirMetaText = dirMetaParts.length > 0 ? dirMetaParts.join(' - ') : video.parent_dir;

            info.innerHTML = `
                <div class="nas-video-name" title="${video.name}">${video.name}</div>
                <div class="nas-video-meta">
                    <div>ğŸ“ ${video.nas_folder}</div>
                    ${dirMetaText ? `<div style="color: #4a9eff;">ğŸ“‹ ${dirMetaText}</div>` : ''}
                    <div>ğŸ“ ${video.size_mb} MB | â±ï¸ ${video.duration_str}</div>
                    <div>ğŸï¸ ${video.total_frames} frames | ${video.fps} fps</div>
                </div>
            `;

            card.appendChild(thumbnailWrapper);
            card.appendChild(info);

            // í´ë¦­ ì´ë²¤íŠ¸
            card.addEventListener('click', () => toggleNasVideoSelection(video.path, card));

            return card;
        }

        function toggleNasVideoSelection(videoPath, cardElement) {
            if (nasSelectedVideos.has(videoPath)) {
                nasSelectedVideos.delete(videoPath);
                cardElement.classList.remove('selected');
            } else {
                nasSelectedVideos.add(videoPath);
                cardElement.classList.add('selected');
            }

            updateNasSelectedCount();
        }

        function updateNasSelectedCount() {
            const countSpan = document.getElementById('nasSelectedCount');
            countSpan.textContent = `${nasSelectedVideos.size}ê°œ ì„ íƒë¨`;
        }

        // í˜„ì¬ í™”ë©´ì— í‘œì‹œëœ (í•„í„°ë§ëœ) ë¹„ë””ì˜¤ ì „ì²´ ì„ íƒ
        function selectAllFilteredNasVideos() {
            const grid = document.getElementById('nasVideoGrid');
            const cards = grid.querySelectorAll('.nas-video-card');

            cards.forEach(card => {
                const videoPath = card.dataset.videoPath;
                if (videoPath && !nasSelectedVideos.has(videoPath)) {
                    nasSelectedVideos.add(videoPath);
                    card.classList.add('selected');
                }
            });

            updateNasSelectedCount();
            console.log(`[NAS] Selected all ${cards.length} filtered videos`);
        }

        // ëª¨ë“  ì„ íƒ í•´ì œ
        function deselectAllNasVideos() {
            const grid = document.getElementById('nasVideoGrid');
            const cards = grid.querySelectorAll('.nas-video-card');

            cards.forEach(card => {
                card.classList.remove('selected');
            });

            nasSelectedVideos.clear();
            updateNasSelectedCount();
            console.log('[NAS] Deselected all videos');
        }

        // í•„í„°ë§ëœ ì½”ë©˜íŠ¸ë¥¼ CSVë¡œ ë‚´ë³´ë‚´ê¸°
        function exportFilteredCommentsCSV() {
            if (!filteredComments || filteredComments.length === 0) {
                alert('ë‚´ë³´ë‚¼ ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € í•„í„°ë¥¼ ì ìš©í•˜ì„¸ìš”.');
                return;
            }

            // CSV í—¤ë”
            const headers = ['í”„ë¡œì íŠ¸', 'ë¹„ë””ì˜¤', 'í”„ë ˆì„', 'ë¼ë²¨', 'ì½”ë©˜íŠ¸', 'ì‘ì„±ì', 'ìƒíƒœ', 'ì‘ì„±ì¼'];

            // CSV í–‰ ë°ì´í„° ìƒì„±
            const rows = filteredComments.map(comment => {
                const projectName = comment.project_name || '';
                const videoName = comment.video_name || '';
                const frame = comment.frame_number || '';
                const label = comment.label || '';
                // ì½”ë©˜íŠ¸ ë‚´ìš©ì—ì„œ ì¤„ë°”ê¿ˆê³¼ ì‰¼í‘œ ì²˜ë¦¬
                const commentText = (comment.content || '').replace(/"/g, '""').replace(/\n/g, ' ');
                const author = comment.created_by || '';
                const status = comment.status === 'resolved' ? 'í•´ê²°ë¨' : 'ë¯¸í•´ê²°';
                const date = comment.created_at ? new Date(comment.created_at).toLocaleString('ko-KR') : '';

                return [projectName, videoName, frame, label, `"${commentText}"`, author, status, date];
            });

            // CSV ë¬¸ìì—´ ìƒì„± (UTF-8 BOM ì¶”ê°€)
            const BOM = '\uFEFF';
            const csvContent = BOM + headers.join(',') + '\n' + rows.map(row => row.join(',')).join('\n');

            // íŒŒì¼ ë‹¤ìš´ë¡œë“œ
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().slice(0, 10);
            link.download = `comments_export_${timestamp}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log(`[Export] CSV ë‚´ë³´ë‚´ê¸° ì™„ë£Œ: ${filteredComments.length}ê°œ ì½”ë©˜íŠ¸`);
        }

        // í•„í„°ë§ëœ ì½”ë©˜íŠ¸ë¥¼ JSONìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°
        function exportFilteredCommentsJSON() {
            if (!filteredComments || filteredComments.length === 0) {
                alert('ë‚´ë³´ë‚¼ ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € í•„í„°ë¥¼ ì ìš©í•˜ì„¸ìš”.');
                return;
            }

            // JSON ë°ì´í„° êµ¬ì¡°í™”
            const exportData = {
                export_date: new Date().toISOString(),
                total_count: filteredComments.length,
                comments: filteredComments.map(comment => ({
                    project_name: comment.project_name || '',
                    video_name: comment.video_name || '',
                    frame_number: comment.frame_number || 0,
                    label: comment.label || '',
                    content: comment.content || '',
                    created_by: comment.created_by || '',
                    status: comment.status || 'open',
                    created_at: comment.created_at || '',
                    annotation: comment.annotation || null
                }))
            };

            // JSON ë¬¸ìì—´ ìƒì„± (ë³´ê¸° ì¢‹ê²Œ í¬ë§·íŒ…)
            const jsonContent = JSON.stringify(exportData, null, 2);

            // íŒŒì¼ ë‹¤ìš´ë¡œë“œ
            const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().slice(0, 10);
            link.download = `comments_export_${timestamp}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log(`[Export] JSON ë‚´ë³´ë‚´ê¸° ì™„ë£Œ: ${filteredComments.length}ê°œ ì½”ë©˜íŠ¸`);
        }

        async function addSelectedNasVideos() {
            if (nasSelectedVideos.size === 0) {
                alert('ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            // ì¤‘ë³µ ì²´í¬ - ì´ë¯¸ í”„ë¡œì íŠ¸ì— ìˆëŠ” ë¹„ë””ì˜¤ ê²½ë¡œ ìˆ˜ì§‘
            const existingPaths = new Set();
            if (currentProject.videos) {
                currentProject.videos.forEach(v => {
                    // NAS ë¹„ë””ì˜¤ ê²½ë¡œë¡œ ì²´í¬
                    if (v.nas_video_path) {
                        existingPaths.add(v.nas_video_path);
                    }
                    // íŒŒì¼ëª…ìœ¼ë¡œë„ ì²´í¬ (fallback)
                    if (v.filename) {
                        existingPaths.add(v.filename);
                    }
                });
            }

            // ì„ íƒëœ ë¹„ë””ì˜¤ë¥¼ ì‹ ê·œ/ì¤‘ë³µìœ¼ë¡œ ë¶„ë¥˜
            const videosToAdd = [];
            const duplicates = [];
            for (const videoPath of nasSelectedVideos) {
                const videoInfo = nasVideos.find(v => v.path === videoPath);
                const videoName = videoInfo?.name || videoPath.split('/').pop();

                if (existingPaths.has(videoPath) || existingPaths.has(videoName)) {
                    duplicates.push(videoName);
                } else {
                    videosToAdd.push(videoPath);
                }
            }

            // ì¤‘ë³µ ì•Œë¦¼ ë° í™•ì¸
            if (duplicates.length > 0) {
                const duplicateList = duplicates.slice(0, 5).join('\n  - ');
                const moreMsg = duplicates.length > 5 ? `\n  ... ì™¸ ${duplicates.length - 5}ê°œ` : '';

                if (videosToAdd.length === 0) {
                    alert(`ì„ íƒí•œ ëª¨ë“  ë¹„ë””ì˜¤ê°€ ì´ë¯¸ í”„ë¡œì íŠ¸ì— ìˆìŠµë‹ˆë‹¤.\n\nì¤‘ë³µëœ ë¹„ë””ì˜¤:\n  - ${duplicateList}${moreMsg}`);
                    return;
                }

                const confirmMsg = `${duplicates.length}ê°œì˜ ë¹„ë””ì˜¤ê°€ ì´ë¯¸ í”„ë¡œì íŠ¸ì— ìˆìŠµë‹ˆë‹¤.\n\nì¤‘ë³µëœ ë¹„ë””ì˜¤:\n  - ${duplicateList}${moreMsg}\n\në‚˜ë¨¸ì§€ ${videosToAdd.length}ê°œì˜ ìƒˆ ë¹„ë””ì˜¤ë¥¼ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                if (!confirm(confirmMsg)) return;
            } else {
                const confirmAdd = confirm(`ì„ íƒí•œ ${videosToAdd.length}ê°œì˜ NAS ë¹„ë””ì˜¤ë¥¼ í”„ë¡œì íŠ¸ì— ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`);
                if (!confirmAdd) return;
            }

            console.log(`[NAS] Adding ${videosToAdd.length} NAS videos (${duplicates.length} duplicates skipped)...`);
            let successCount = 0;
            let failCount = 0;

            for (const videoPath of videosToAdd) {
                // í•´ë‹¹ ë¹„ë””ì˜¤ì˜ ë©”íƒ€ë°ì´í„° ì°¾ê¸°
                const videoInfo = nasVideos.find(v => v.path === videoPath);

                try {
                    const response = await authFetch(`/api/projects/${currentProject.id}/videos`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            nas_video_path: videoPath,
                            nas_metadata: videoInfo ? {
                                nas_folder: videoInfo.nas_folder,
                                parent_dir: videoInfo.parent_dir,
                                dir_metadata: videoInfo.dir_metadata,
                                size_mb: videoInfo.size_mb,
                                duration: videoInfo.duration,
                                fps: videoInfo.fps
                            } : {}
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        console.log(`[NAS] âœ… Added: ${videoInfo?.name || videoPath}`);
                        successCount++;
                    } else {
                        console.error(`[NAS] âŒ Failed: ${videoInfo?.name || videoPath}:`, data.error);
                        failCount++;
                    }
                } catch (error) {
                    console.error(`[NAS] âŒ Error adding ${videoInfo?.name || videoPath}:`, error);
                    failCount++;
                }
            }

            // ëª¨ë‹¬ ë‹«ê¸°
            closeNasVideoSelection();

            // í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
            await openProject(currentProject.id);

            // ê²°ê³¼ í‘œì‹œ
            let resultMsg = '';
            if (successCount > 0) {
                resultMsg = `âœ… ${successCount}ê°œì˜ NAS ë¹„ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`;
            }
            if (duplicates.length > 0) {
                resultMsg += (resultMsg ? '\n' : '') + `âš ï¸ ${duplicates.length}ê°œëŠ” ì´ë¯¸ ì¡´ì¬í•˜ì—¬ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤.`;
            }
            if (failCount > 0) {
                resultMsg += (resultMsg ? '\n' : '') + `âŒ ${failCount}ê°œ ì¶”ê°€ ì‹¤íŒ¨`;
            }

            if (resultMsg) {
                alert(resultMsg);
            }
        }

        function closeNasVideoSelection() {
            document.getElementById('nasVideoSelectionModal').classList.remove('show');
            nasSelectedVideos.clear();
        }

        // ë¹„ë””ì˜¤ ìƒíƒœ í† ê¸€
        async function toggleVideoStatus(videoId, newStatus) {
            if (!currentProject) return;

            try {
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId + '/status', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status: newStatus })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[VIDEO STATUS] Status updated:', videoId, '->', newStatus);

                    // currentProjectì˜ ë¹„ë””ì˜¤ ìƒíƒœ ì—…ë°ì´íŠ¸
                    const video = currentProject.videos.find(v => v.video_id === videoId);
                    if (video) {
                        video.status = newStatus;
                    }

                    // í˜„ì¬ ì–´ë…¸í…Œì´ì…˜ ì¤‘ì¸ ë¹„ë””ì˜¤ë¼ë©´ ì „ì—­ ìƒíƒœë„ ì—…ë°ì´íŠ¸
                    if (currentVideoId === videoId) {
                        currentVideoStatus = newStatus;
                        updateAnnotationUIForStatus();
                    }

                    // UI ì—…ë°ì´íŠ¸
                    displayVideos();

                    // í”¼ë“œë°± ë©”ì‹œì§€
                    const msg = newStatus === 'completed' ? 'ë¹„ë””ì˜¤ê°€ ì™„ë£Œë¡œ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.' : 'ë¹„ë””ì˜¤ê°€ ì§„í–‰ì¤‘ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    console.log('[VIDEO STATUS]', msg);
                } else {
                    alert('ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[VIDEO STATUS] Error:', error);
                alert('ìƒíƒœ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ë¹„ë””ì˜¤ ì œê±°
        async function removeVideo(videoId) {
            if (!currentProject) return;

            if (!confirm('Are you sure you want to remove this video?\nAll video files and annotations will be deleted.')) {
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProject.id + '/videos/' + videoId, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    alert('[OK] Video removed successfully.');
                    // í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
                    await openProject(currentProject.id);
                } else {
                    alert('[ERROR] Error: ' + data.error);
                }
            } catch (error) {
                console.error('Remove video error:', error);
                alert('[ERROR] Error: ' + error.message);
            }
        }

        // í”„ë¡œì íŠ¸ ìƒì„±
        async function createProject() {
            const nameInput = document.getElementById('projectName');
            const workerInput = document.getElementById('projectWorker');
            const name = nameInput.value.trim();
            const worker = workerInput.value.trim();

            console.log('Creating project:', { name, worker });  // ë””ë²„ê¹…ìš©

            if (!name) {
                alert('í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const requestBody = {
                    name,
                    classes: [
                        { name: 'normal', description: 'ì •ìƒë¶€' },
                        { name: 'deformation', description: 'ë³€í˜•' },
                        { name: 'crack', description: 'ê· ì—´' },
                        { name: 'corrosion', description: 'ë¶€ì‹' },
                        { name: 'sediment_soil', description: 'ì¹¨ì „ë¬¼(í™)' },
                        { name: 'sediment_sand', description: 'ì¹¨ì „ë¬¼(ëª¨ë˜)' },
                        { name: 'sediment_corrosion', description: 'ì¹¨ì „ë¬¼(ë¶€ì‹ ìƒì„±ë¬¼)' },
                        { name: 'sediment_coating', description: 'ì¹¨ì „ë¬¼(íƒˆë¦¬, ë„ì¥ì¬)' },
                        { name: 'sediment_other', description: 'ì¹¨ì „ë¬¼(ê¸°íƒ€)' },
                        { name: 'slime', description: 'ìŠ¬ë¼ì„(ë¬¼ë•Œ)' },
                        { name: 'vanishing_point', description: 'ì†Œì‹¤ì ' },
                        { name: 'needs_discussion', description: 'ë…¼ì˜í•„ìš”' }
                    ]  // ê¸°ë³¸ í´ë˜ìŠ¤
                };

                // ì‘ì—…ìê°€ ì…ë ¥ëœ ê²½ìš°ì—ë§Œ í¬í•¨
                if (worker) {
                    requestBody.worker = worker;
                }

                const response = await authFetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();
                console.log('Create project response:', data);  // ë””ë²„ê¹…ìš©

                if (data.success) {
                    const workerInfo = worker ? '\nì‘ì—…ì: ' + worker : '';
                    alert('[OK] í”„ë¡œì íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nID: ' + data.project.id + '\nì´ë¦„: ' + data.project.name + workerInfo + '\nê²½ë¡œ: ' + data.project.path);
                    nameInput.value = '';
                    workerInput.value = '';

                    // í”„ë¡œì íŠ¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì•½ê°„ì˜ ì§€ì—° í›„)
                    setTimeout(() => {
                        loadProjects();
                    }, 500);
                } else {
                    alert('[ERROR] Error: ' + data.error);
                }
            } catch (error) {
                console.error('Create project error:', error);
                alert('[ERROR] Error: ' + error.message);
            }
        }

        // ===== Annotation Tab Functions =====
        let videoElement = null;  // HTML5 video element for smooth playback
        let videoCanvas = null;
        let videoContext = null;
        let previewCanvas = null;
        let previewContext = null;
        let currentFrame = 0;
        let totalFrames = 0;
        let isPlaying = false;
        let renderLoopActive = false;  // Flag for video-to-canvas rendering loop
        let videoFPS = 30;  // Video FPS (will be updated on load)
        let useVideoElement = false;  // Flag to determine if video element can be used
        let frameAnnotations = {};  // {frameNum: [{box, label}, ...]} - í˜„ì¬ ì‘ì—… ì¤‘ì¸ ì–´ë…¸í…Œì´ì…˜
        let savedFrameAnnotations = {};  // Saveëœ ì–´ë…¸í…Œì´ì…˜ë§Œ (Statistics í‘œì‹œìš©)
        let annotationContributors = [];  // ì–´ë…¸í…Œì´ì…˜ ê¸°ì—¬ì ëª©ë¡
        let currentVideoPath = null;
        let currentVideoId = null;
        let currentProjectId = null;
        let currentVideoStatus = 'in_progress';  // í˜„ì¬ ë¹„ë””ì˜¤ ìƒíƒœ (in_progress, completed)
        let frameLoadAbortController = null;  // í”„ë ˆì„ ë¡œë“œ ìš”ì²­ ì·¨ì†Œìš© AbortController
        let sliderDebounceTimer = null;  // ìŠ¬ë¼ì´ë” ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸
        let lastSliderUpdate = 0;  // ë§ˆì§€ë§‰ ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸ ì‹œê°„ (throttleìš©)
        let isDrawing = false;
        let startX, startY;
        let currentBox = null;
        let currentFrameImage = null;  // í˜„ì¬ í”„ë ˆì„ ì´ë¯¸ì§€ (AI ì¶”ë¡  ê²°ê³¼ í¬í•¨)
        let originalFrameImage = null;  // ì›ë³¸ í”„ë ˆì„ ì´ë¯¸ì§€ (AI ì¶”ë¡  ì „)
        let aiInitialized = false;  // AI ì´ˆê¸°í™” ìƒíƒœ
        let aiAutoInferenceEnabled = false;  // AI ìë™ ì¶”ë¡  í™œì„±í™” ì—¬ë¶€ (ì‚¬ìš©ì ì„¤ì •)
        let selectedAnnotationIndex = -1;  // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ ì¸ë±ìŠ¤
        let isDraggingPoint = false;  // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘
        let draggingPointIndex = -1;  // ë“œë˜ê·¸ ì¤‘ì¸ í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        let editMode = 'select';  // í¸ì§‘ ëª¨ë“œ: 'select', 'draw', 'edit_polygon'

        // í´ë¦¬ê³¤ ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ëª¨ë“œ
        let isPolygonDrawMode = true;  // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ í™œì„±í™” ì—¬ë¶€ (ê¸°ë³¸ê°’: ON)
        let isCrosshairEnabled = false; // ì‹­ìì„  í‘œì‹œ ì—¬ë¶€
        let animationFrameId = null;  // requestAnimationFrame ID
        let needsRedraw = false;  // ë‹¤ì‹œ ê·¸ë ¤ì•¼ í•˜ëŠ”ì§€ í”Œë˜ê·¸
        let isDrawingPolygon = false;   // í´ë¦¬ê³¤ ë“œë˜ê·¸ ì¤‘
        let currentPolygonPoints = [];  // í˜„ì¬ ê·¸ë¦¬ê³  ìˆëŠ” í´ë¦¬ê³¤ ì ë“¤
        let selectedClassIndex = 0;     // ì„ íƒëœ í´ë˜ìŠ¤ ì¸ë±ìŠ¤ (ê¸°ë³¸ê°’: ì²« ë²ˆì§¸ í´ë˜ìŠ¤)
        let previewPolygon = null;      // ë“œë˜ê·¸ ì¤‘ í”„ë¦¬ë·° í´ë¦¬ê³¤
        let previewBox = null;          // ë°•ìŠ¤ ê·¸ë¦¬ê¸° í”„ë¦¬ë·°
        let isDraggingPolygonPoint = false;  // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘ í”„ë¦¬ë·°
        let draggedPolygon = null;      // ë“œë˜ê·¸ ì¤‘ì¸ í´ë¦¬ê³¤

        // Annotation Mode: 'polygon' or 'point'
        let annotationMode = 'polygon'; // Default to polygon mode
        let pointAnnotations = [];      // Point annotations for current frame

        // í”„ë¡œì íŠ¸ ì„¤ì • ëª¨ë‹¬ ì„ì‹œ í´ë˜ìŠ¤ ëª©ë¡
        let tempClassList = [];

        // í´ë˜ìŠ¤ë³„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (êµ¬ë¶„í•˜ê¸° ì‰¬ìš´ ë°ì€ ìƒ‰ìƒë“¤)
        const CLASS_COLORS = [
            '#FF6B6B', // ë¹¨ê°•
            '#4ECDC4', // ì²­ë¡
            '#45B7D1', // í•˜ëŠ˜ìƒ‰
            '#FFA07A', // ì—°ì–´ìƒ‰
            '#98D8C8', // ë¯¼íŠ¸
            '#F7DC6F', // ë…¸ë‘
            '#BB8FCE', // ë³´ë¼
            '#85C1E2', // íŒŒë‘
            '#F8B88B', // ì£¼í™©
            '#F06292', // í•‘í¬
            '#AED581', // ì—°ë‘
            '#FFD54F', // í™©ê¸ˆìƒ‰
            '#81C784', // ì´ˆë¡
            '#64B5F6', // ë°ì€ íŒŒë‘
            '#E57373', // ë°ì€ ë¹¨ê°•
            '#FFB74D', // í™©í† ìƒ‰
            '#BA68C8', // ë°ì€ ë³´ë¼
            '#4DB6AC', // ì²­ë¡2
            '#DCE775', // ë¼ì„
            '#A1887F'  // ê°ˆìƒ‰
        ];

        // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
        function getColorForClass(className) {
            if (!className) return '#00FF00'; // ê¸°ë³¸ ìƒ‰ìƒ

            if (!currentProject || !currentProject.classes) {
                // í´ë˜ìŠ¤ ì •ë³´ê°€ ì—†ìœ¼ë©´ í•´ì‹œë¡œ ìƒ‰ìƒ ê²°ì •
                let hash = 0;
                for (let i = 0; i < className.length; i++) {
                    hash = className.charCodeAt(i) + ((hash << 5) - hash);
                }
                return CLASS_COLORS[Math.abs(hash) % CLASS_COLORS.length];
            }

            // í´ë˜ìŠ¤ ì¸ë±ìŠ¤ ì°¾ê¸°
            const classIndex = currentProject.classes.findIndex(c => {
                const name = (typeof c === 'string') ? c : c.name;
                return name === className;
            });

            if (classIndex === -1) {
                // í´ë˜ìŠ¤ë¥¼ ì°¾ì§€ ëª»í•˜ë©´ í•´ì‹œë¡œ ìƒ‰ìƒ ê²°ì •
                let hash = 0;
                for (let i = 0; i < className.length; i++) {
                    hash = className.charCodeAt(i) + ((hash << 5) - hash);
                }
                return CLASS_COLORS[Math.abs(hash) % CLASS_COLORS.length];
            }

            return CLASS_COLORS[classIndex % CLASS_COLORS.length];
        }

        // ë¹„ë””ì˜¤ ë¡œë“œ
        async function loadAnnotationVideo() {
            const result = await window.electronAPI.openFileDialog({
                properties: ['openFile'],
                filters: [
                    { name: 'Videos', extensions: ['mp4', 'avi', 'mov', 'mkv'] }
                ]
            });

            if (!result.canceled && result.filePaths.length > 0) {
                currentVideoPath = result.filePaths[0];
                await initVideoPlayer(currentVideoPath);
            }
        }

        // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ì´ˆê¸°í™” (í•˜ì´ë¸Œë¦¬ë“œ: video + canvas)
        async function initVideoPlayer() {
            console.log('[VIDEO] Initializing hybrid video player');
            console.log('[VIDEO] Project ID:', currentProjectId);
            console.log('[VIDEO] Video ID:', currentVideoId);
            console.log('[VIDEO] Total frames:', totalFrames);

            // Get video element and canvases
            videoElement = document.getElementById('videoElement');
            videoCanvas = document.getElementById('videoCanvas');
            videoContext = videoCanvas.getContext('2d');
            previewCanvas = document.getElementById('previewCanvas');
            previewContext = previewCanvas.getContext('2d');

            currentFrame = 0;

            // Load video source from streaming endpoint
            // Add session_id as query parameter for HTML5 video tag
            const sessionId = getSessionId();
            const videoStreamUrl = `/api/projects/${currentProjectId}/videos/${currentVideoId}/stream?session_id=${sessionId}`;
            console.log('[VIDEO] Loading video from:', videoStreamUrl);

            // Set video source with session_id in URL
            videoElement.src = videoStreamUrl;

            // Wait for video metadata to load
            await new Promise((resolve, reject) => {
                videoElement.onloadedmetadata = () => {
                    console.log('[VIDEO] Video metadata loaded');
                    console.log('[VIDEO] Duration:', videoElement.duration, 'seconds');
                    console.log('[VIDEO] Video size:', videoElement.videoWidth, 'x', videoElement.videoHeight);

                    // Calculate FPS
                    videoFPS = totalFrames / videoElement.duration;
                    console.log('[VIDEO] Calculated FPS:', videoFPS);

                    // Set canvas size to match video
                    videoCanvas.width = videoElement.videoWidth;
                    videoCanvas.height = videoElement.videoHeight;
                    previewCanvas.width = videoElement.videoWidth;
                    previewCanvas.height = videoElement.videoHeight;

                    resolve();
                };

                videoElement.onerror = (error) => {
                    console.error('[VIDEO] Error loading video:', error);
                    reject(error);
                };
            });

            // Draw first frame to canvas
            videoContext.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);

            // Load first frame's precise image for annotation
            await loadFrame(0);

            // Set up video event listeners
            videoElement.ontimeupdate = () => {
                if (isPlaying) {
                    // Update current frame based on video time
                    currentFrame = Math.floor(videoElement.currentTime * videoFPS);
                    // Clamp currentFrame to valid range
                    currentFrame = Math.min(currentFrame, totalFrames - 1);
                    currentFrame = Math.max(currentFrame, 0);
                    updateFrameLabel();
                }
            };

            // Handle video end event
            videoElement.onended = () => {
                console.log('[VIDEO] Video playback ended');
                // Stop playback
                isPlaying = false;
                renderLoopActive = false;
                // Set to last frame
                currentFrame = totalFrames - 1;
                videoElement.currentTime = currentFrame / videoFPS;
                // Update button state
                document.getElementById('playBtn').textContent = 'â–¶ ì¬ìƒ';
                // Load last frame for annotation
                loadFrame(currentFrame);
                updateFrameLabel();
            };

            // ì»¨íŠ¸ë¡¤ í™œì„±í™”
            document.getElementById('playBtn').disabled = false;
            document.getElementById('prevFrameBtn').disabled = false;
            document.getElementById('nextFrameBtn').disabled = false;
            document.getElementById('skip15BackBtn').disabled = false;
            document.getElementById('skip15ForwardBtn').disabled = false;
            document.getElementById('frameSlider').disabled = false;
            document.getElementById('frameSlider').max = totalFrames - 1;

            updateFrameLabel();

            // ìº”ë²„ìŠ¤ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë“±ë¡
            setupCanvasEvents();

            // ê¸°ì¡´ ì–´ë…¸í…Œì´ì…˜ ìë™ ë¡œë“œ
            await autoLoadAnnotations();

            // AI ìƒíƒœ í™•ì¸
            await checkAIStatus();

            console.log('[VIDEO] Hybrid video player initialized');
        }

        // ë¹„ë””ì˜¤ë¥¼ ìº”ë²„ìŠ¤ë¡œ ë Œë”ë§ (ì¬ìƒ ì¤‘ ì‹¤ì‹œê°„ ë Œë”ë§)
        function renderVideoToCanvas() {
            if (!renderLoopActive) {
                return;
            }

            // Draw current video frame to canvas
            videoContext.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);

            // Draw annotations for current frame on top
            drawAnnotationsOnCanvas();

            // Continue rendering loop
            requestAnimationFrame(renderVideoToCanvas);
        }

        // ìº”ë²„ìŠ¤ì— í˜„ì¬ í”„ë ˆì„ì˜ ì–´ë…¸í…Œì´ì…˜ ê·¸ë¦¬ê¸° (ì¬ìƒ ì¤‘)
        function drawAnnotationsOnCanvas() {
            const annotations = frameAnnotations[currentFrame] || [];

            annotations.forEach((anno, index) => {
                const isSelected = index === selectedAnnotationIndex;
                const className = anno.category || anno.label || 'Unknown';
                const classColor = getColorForClass(className);

                if (anno.segmentation && anno.segmentation.length > 0) {
                    // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
                    const polygon = anno.segmentation[0];
                    videoContext.beginPath();
                    videoContext.moveTo(polygon[0], polygon[1]);
                    for (let i = 2; i < polygon.length; i += 2) {
                        videoContext.lineTo(polygon[i], polygon[i + 1]);
                    }
                    videoContext.closePath();
                    videoContext.strokeStyle = isSelected ? '#ffff00' : classColor;
                    videoContext.lineWidth = isSelected ? 3 : 2;
                    videoContext.stroke();

                    // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
                    if (isSelected) {
                        for (let i = 0; i < polygon.length; i += 2) {
                            videoContext.beginPath();
                            videoContext.arc(polygon[i], polygon[i + 1], 5, 0, 2 * Math.PI);
                            videoContext.fillStyle = '#ffff00';
                            videoContext.fill();
                        }
                    }

                    // ë ˆì´ë¸” í‘œì‹œ
                    const label = getDisplayLabel(className);
                    const minX = Math.min(...polygon.filter((_, i) => i % 2 === 0));
                    const minY = Math.min(...polygon.filter((_, i) => i % 2 === 1));

                    videoContext.fillStyle = isSelected ? '#ffff00' : classColor;
                    videoContext.fillRect(minX, minY - 40, 200, 40);
                    videoContext.fillStyle = '#000';
                    videoContext.font = '28px Arial';
                    videoContext.fillText(label, minX + 5, minY - 10);
                } else if (anno.bbox) {
                    // ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                    const box = anno.bbox;
                    const label = getDisplayLabel(className);
                    const color = isSelected ? '#ffff00' : classColor;
                    const lineWidth = isSelected ? 3 : 2;

                    videoContext.strokeStyle = color;
                    videoContext.lineWidth = lineWidth;
                    videoContext.strokeRect(box.x, box.y, box.width, box.height);

                    // ë ˆì´ë¸” í‘œì‹œ
                    videoContext.fillStyle = color;
                    videoContext.fillRect(box.x, box.y - 40, 200, 40);
                    videoContext.fillStyle = '#000';
                    videoContext.font = '28px Arial';
                    videoContext.fillText(label, box.x + 5, box.y - 10);
                }
            });
        }

        // í”„ë ˆì„ ë¡œë“œ
        async function loadFrame(frameNumber, abortSignal = null) {
            try {
                // í”„ë ˆì„ ë³€ê²½ ì‹œ ì„ íƒ í•´ì œ
                selectedAnnotationIndex = -1;

                // authFetchë¥¼ ì‚¬ìš©í•˜ì—¬ ì¸ì¦ëœ ìš”ì²­ìœ¼ë¡œ í”„ë ˆì„ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
                const frameUrl = '/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/frame/' + frameNumber;
                console.log('[FRAME] Loading frame:', frameNumber, 'using authFetch');

                // AbortSignalì„ authFetchì— ì „ë‹¬
                const fetchOptions = abortSignal ? { signal: abortSignal } : {};
                const response = await authFetch(frameUrl, fetchOptions);

                if (!response.ok) {
                    throw new Error('Failed to load frame: ' + response.status);
                }

                // ì‘ë‹µì„ Blobìœ¼ë¡œ ë³€í™˜
                const blob = await response.blob();

                // Blobì„ data URLë¡œ ë³€í™˜
                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });

                currentFrameImage = new Image();

                return new Promise((resolve, reject) => {
                    currentFrameImage.onload = async () => {
                        console.log('[FRAME] Frame loaded:', frameNumber);
                        console.log('[FRAME] Image size:', currentFrameImage.width, 'x', currentFrameImage.height);

                        // ì›ë³¸ í”„ë ˆì„ ì´ë¯¸ì§€ ì €ì¥ (AI ì¶”ë¡  ê²°ê³¼ë¥¼ ëˆ„ì í•˜ê¸° ìœ„í•´)
                        originalFrameImage = new Image();
                        originalFrameImage.src = currentFrameImage.src;

                        // ì²« í”„ë ˆì„ì—ì„œ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                        if (frameNumber === 0) {
                            videoCanvas.width = currentFrameImage.width;
                            videoCanvas.height = currentFrameImage.height;
                            previewCanvas.width = currentFrameImage.width;
                            previewCanvas.height = currentFrameImage.height;
                            console.log('[FRAME] Canvas size set to:', videoCanvas.width, 'x', videoCanvas.height);
                        }

                        // ì €ì¥ëœ ì–´ë…¸í…Œì´ì…˜ì´ ìˆê³  ë§ˆìŠ¤í¬ê°€ ìˆìœ¼ë©´ ë§ˆìŠ¤í¬ í‘œì‹œ, ì•„ë‹ˆë©´ ê¸°ë³¸ drawFrame
                        const savedAnnotations = frameAnnotations[frameNumber] || [];
                        const hasMasks = savedAnnotations.some(anno => anno.has_segmentation && anno.mask);

                        if (hasMasks) {
                            console.log('[FRAME] Drawing frame with masks');
                            await drawFrameWithMasks();
                        } else {
                            drawFrame();
                        }

                        // AI ìë™ ì¶”ë¡  ê¸°ëŠ¥ ë¹„í™œì„±í™”ë¨
                        // (ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ë¡  ì œê±°)

                        resolve();
                    };

                    currentFrameImage.onerror = (error) => {
                        console.error('[FRAME] Error loading frame:', error);
                        reject(error);
                    };

                    // data URLì„ ì´ë¯¸ì§€ srcë¡œ ì„¤ì •
                    currentFrameImage.src = dataUrl;
                });
            } catch (error) {
                // AbortErrorëŠ” ì •ìƒì ì¸ ìš”ì²­ ì·¨ì†Œì´ë¯€ë¡œ ì¡°ìš©íˆ ë¬´ì‹œ
                if (error.name === 'AbortError') {
                    console.log('[FRAME] Frame load aborted (ìŠ¬ë¼ì´ë” ì´ë™ ì¤‘):', frameNumber);
                    return;
                }
                console.error('[FRAME] Failed to load frame:', error);
                throw error;
            }
        }

        // í´ë˜ìŠ¤ ë¼ë””ì˜¤ ë²„íŠ¼ ìƒì„± (UI ì œê±°ë¨ - ë¹„í™œì„±í™”)
        function updateClassRadioButtons() {
            const container = document.getElementById('classRadioButtons');

            // UI ìš”ì†Œê°€ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ í•¨ìˆ˜ ë¹„í™œì„±í™”
            if (!container) {
                return;
            }

            if (!currentProject || !currentProject.classes) {
                container.innerHTML = '<p style="color: #888; font-size: 11px;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
                return;
            }

            // classes ë°ì´í„° ì •ê·œí™”
            let classes = currentProject.classes;
            if (typeof classes === 'string') {
                // ë¬¸ìì—´ì¸ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)
                classes = classes.split(',').map(c => c.trim()).filter(c => c.length > 0);
                classes = classes.map(name => ({ name: name, description: '' }));
                currentProject.classes = classes;
            } else if (Array.isArray(classes)) {
                // ë°°ì—´ ìš”ì†Œ ì •ê·œí™”
                classes = classes.map(cls => {
                    if (typeof cls === 'string') {
                        return { name: cls, description: '' };
                    } else if (cls.name) {
                        return { name: cls.name, description: cls.description || '' };
                    }
                    return null;
                }).filter(cls => cls !== null);
                currentProject.classes = classes;
            } else {
                classes = [];
                currentProject.classes = [];
            }

            if (classes.length === 0) {
                container.innerHTML = '<p style="color: #888; font-size: 11px;">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
                return;
            }
            container.innerHTML = '';

            classes.forEach((classObj, index) => {
                const label = document.createElement('label');
                label.style.display = 'block';
                label.style.padding = '5px';
                label.style.cursor = 'pointer';
                label.style.fontSize = '12px';
                label.style.color = '#ddd';
                // Tooltip: í•œê¸€ ëª¨ë“œë©´ ì˜ë¬¸ í‘œì‹œ, ì˜ë¬¸ ëª¨ë“œë©´ í•œê¸€ í‘œì‹œ
                label.title = (currentLanguage === 'ko' ? classObj.name : classObj.description) || '';

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'classSelection';
                radio.value = index;
                radio.checked = (index === selectedClassIndex);
                radio.style.marginRight = '8px';
                radio.onchange = function() {
                    selectedClassIndex = index;
                    console.log('[CLASS] Selected class:', classObj.name, 'index:', index);
                };

                label.appendChild(radio);
                label.appendChild(document.createTextNode(getClassDisplayName(classObj)));
                container.appendChild(label);
            });

            console.log('[CLASS] Created', classes.length, 'radio buttons');
        }

        // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ í† ê¸€
        function togglePolygonDrawMode() {
            isPolygonDrawMode = !isPolygonDrawMode;
            const btn = document.getElementById('polygonDrawBtn');

            if (isPolygonDrawMode) {
                btn.textContent = 'ğŸ–Šï¸ Manual Polygon (ON)';
                btn.style.background = '#4a9eff';
                btn.style.borderColor = '#4a9eff';

                // ì»¤ì„œë§Œ ë³€ê²½ (ì‹­ìì„ ì€ ë³„ë„ í† ê¸€)
                videoCanvas.classList.add('crosshair-cursor');

                console.log('[POLYGON] Draw mode enabled');
            } else {
                btn.textContent = 'ğŸ–Šï¸ Manual Polygon (OFF)';
                btn.style.background = '#2d2d2d';
                btn.style.borderColor = '#404040';

                // ì»¤ì„œ ë³µì›
                videoCanvas.classList.remove('crosshair-cursor');

                // ê·¸ë¦¬ê¸° ì¤‘ì´ì—ˆìœ¼ë©´ ì·¨ì†Œ
                if (isDrawingPolygon) {
                    isDrawingPolygon = false;
                    currentPolygonPoints = [];
                    drawFrameWithMasks();
                }
                console.log('[POLYGON] Draw mode disabled');
            }
        }

        // ì‹­ìì„  í† ê¸€
        function toggleCrosshair() {
            const checkbox = document.getElementById('crosshairToggle');
            isCrosshairEnabled = checkbox.checked;
            const crosshairLines = document.getElementById('crosshair-lines');

            if (isCrosshairEnabled) {
                crosshairLines.classList.add('active');
                // ì‹­ìì„ ì´ ì¼œì§€ë©´ ì»¤ì„œ ìˆ¨ê¹€
                if (isPolygonDrawMode) {
                    videoCanvas.classList.add('hide-cursor');
                }
                console.log('[CROSSHAIR] Enabled');
            } else {
                crosshairLines.classList.remove('active');
                // ì‹­ìì„ ì´ êº¼ì§€ë©´ ì»¤ì„œ í‘œì‹œ
                videoCanvas.classList.remove('hide-cursor');
                console.log('[CROSSHAIR] Disabled');
            }
        }

        // Annotation mode toggle function
        function setAnnotationMode(mode) {
            annotationMode = mode;

            // Update UI styling
            const polygonLabel = document.getElementById('polygonModeLabel');
            const pointLabel = document.getElementById('pointModeLabel');

            if (mode === 'polygon') {
                polygonLabel.style.borderColor = '#4a9eff';
                polygonLabel.style.background = '#2d2d2d';
                pointLabel.style.borderColor = '#404040';
                pointLabel.style.background = '#2d2d2d';
                console.log('[ANNOTATION] ëª¨ë“œ ë³€ê²½: í´ë¦¬ê³¤ ë“œë˜ê·¸');
            } else if (mode === 'point') {
                pointLabel.style.borderColor = '#4a9eff';
                pointLabel.style.background = '#2d2d2d';
                polygonLabel.style.borderColor = '#404040';
                polygonLabel.style.background = '#2d2d2d';
                console.log('[ANNOTATION] ëª¨ë“œ ë³€ê²½: í¬ì¸íŠ¸ í´ë¦­');
            }

            // Reset current drawing state
            if (currentPolygonPoints.length > 0) {
                currentPolygonPoints = [];
                isDrawingPolygon = false;
                renderCanvas();
            }
        }

        // Finish polygon annotation (for point click mode)
        async function finishPolygonAnnotation() {
            if (currentPolygonPoints.length < 3) {
                alert('í´ë¦¬ê³¤ì„ ì™„ì„±í•˜ë ¤ë©´ ìµœì†Œ 3ê°œì˜ ì ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }

            isDrawingPolygon = false;
            previewPolygon = null;
            previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

            const polygon = [...currentPolygonPoints];

            // ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            polygon.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });

            const box = {
                x: Math.floor(minX),
                y: Math.floor(minY),
                width: Math.ceil(maxX - minX),
                height: Math.ceil(maxY - minY)
            };

            // ë¼ë²¨ ì„ íƒ í”„ë¡¬í”„íŠ¸
            await promptForLabel(polygon, box, window.innerWidth / 2, window.innerHeight / 2);

            currentPolygonPoints = [];
        }

        // Cancel polygon annotation (for point click mode)
        function cancelPolygonAnnotation() {
            if (isDrawingPolygon) {
                currentPolygonPoints = [];
                isDrawingPolygon = false;
                previewPolygon = null;
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                renderCanvas();
                console.log('[POLYGON] Annotation cancelled');
            }
        }

        function toggleAutoInference() {
            const checkbox = document.getElementById('autoInferenceToggle');

            if (checkbox.checked) {
                // AI ì´ˆê¸°í™” ìƒíƒœ ì²´í¬
                if (!aiInitialized) {
                    alert('AI ëª¨ë¸ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\nGPU ì„œë²„ë¥¼ ì‹œì‘í•˜ê±°ë‚˜ AI ëª¨ë¸ì„ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                    checkbox.checked = false;
                    return;
                }

                // AI ìë™ ì¶”ë¡  í™œì„±í™” â†’ ë°•ìŠ¤ ëª¨ë“œë¡œ ì „í™˜
                aiAutoInferenceEnabled = true;
                isPolygonDrawMode = false;
                videoCanvas.classList.remove('crosshair-cursor');

                // ê·¸ë¦¬ê¸° ì¤‘ì´ì—ˆìœ¼ë©´ ì·¨ì†Œ
                if (isDrawingPolygon) {
                    isDrawingPolygon = false;
                    currentPolygonPoints = [];
                    drawFrameWithMasks();
                }

                console.log('[AI AUTO-INFERENCE] Enabled - Box mode');
            } else {
                // AI ìë™ ì¶”ë¡  ë¹„í™œì„±í™” â†’ í´ë¦¬ê³¤ ëª¨ë“œë¡œ ì „í™˜
                aiAutoInferenceEnabled = false;
                isPolygonDrawMode = true;
                videoCanvas.classList.add('crosshair-cursor');

                console.log('[AI AUTO-INFERENCE] Disabled - Polygon mode');
            }
        }

        // ì‹­ìì„  ìš”ì†Œ ìºì‹±
        let crosshairElements = null;
        let crosshairUpdateScheduled = false;
        let crosshairX = 0;
        let crosshairY = 0;

        function initCrosshairElements() {
            if (!crosshairElements) {
                const crosshairLines = document.getElementById('crosshair-lines');
                crosshairElements = {
                    hLine: crosshairLines.querySelector('.crosshair-h'),
                    vLine: crosshairLines.querySelector('.crosshair-v'),
                    container: document.getElementById('canvasContainer')
                };
            }
        }

        // ì‹­ìì„  ë§ˆìš°ìŠ¤ ì¶”ì 
        function updateCrosshair(e) {
            if (!isPolygonDrawMode || !isCrosshairEnabled) return;

            initCrosshairElements();

            const rect = crosshairElements.container.getBoundingClientRect();
            crosshairX = e.clientX - rect.left;
            crosshairY = e.clientY - rect.top;

            if (!crosshairUpdateScheduled) {
                crosshairUpdateScheduled = true;
                requestAnimationFrame(() => {
                    if (crosshairElements.hLine && crosshairElements.vLine) {
                        crosshairElements.hLine.style.top = crosshairY + 'px';
                        crosshairElements.vLine.style.left = crosshairX + 'px';
                    }
                    crosshairUpdateScheduled = false;
                });
            }
        }

        // í´ë¦¬ê³¤ ë³´ê°„ì„ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
        function getVideoScaleFactor() {
            const videoWidth = videoElement.videoWidth || 1920;
            const videoHeight = videoElement.videoHeight || 1080;
            return Math.sqrt((videoWidth * videoHeight) / (1920 * 1080));
        }

        function interpolatePolygonPoints(points, scaleFactor) {
            if (points.length < 2) return points;

            const segments = Math.max(6, Math.floor(20 * scaleFactor));
            const interpolated = [];

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];

                for (let j = 0; j < segments; j++) {
                    const t = j / segments;
                    interpolated.push({
                        x: p1.x + (p2.x - p1.x) * t,
                        y: p1.y + (p2.y - p1.y) * t
                    });
                }
            }
            return interpolated;
        }

        // requestAnimationFrameì„ ì‚¬ìš©í•œ ìµœì í™”ëœ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        function scheduleRedraw() {
            if (!needsRedraw) {
                needsRedraw = true;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                animationFrameId = requestAnimationFrame(() => {
                    // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                    previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

                    // í”„ë¦¬ë·° í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° (ë³´ê°„ ì ìš©)
                    if (previewPolygon && previewPolygon.length > 0) {
                        const scaleFactor = getVideoScaleFactor();
                        const smoothPreview = previewPolygon.length >= 3 ?
                            interpolatePolygonPoints(previewPolygon, scaleFactor) :
                            previewPolygon;

                        previewContext.strokeStyle = '#00ff00';
                        previewContext.lineWidth = 3;
                        previewContext.setLineDash([]);

                        previewContext.beginPath();
                        previewContext.moveTo(smoothPreview[0].x, smoothPreview[0].y);
                        for (let i = 1; i < smoothPreview.length; i++) {
                            previewContext.lineTo(smoothPreview[i].x, smoothPreview[i].y);
                        }
                        previewContext.stroke();

                        // ì  í‘œì‹œ
                        previewPolygon.forEach((point, idx) => {
                            previewContext.fillStyle = idx === 0 ? '#ff0000' : '#00ff00';
                            previewContext.beginPath();
                            previewContext.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                            previewContext.fill();
                        });
                    }

                    // í”„ë¦¬ë·° ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                    if (previewBox) {
                        previewContext.strokeStyle = '#ff0000';
                        previewContext.lineWidth = 2;
                        previewContext.setLineDash([5, 5]);
                        previewContext.strokeRect(previewBox.x, previewBox.y, previewBox.width, previewBox.height);
                        previewContext.setLineDash([]);
                    }

                    // ë“œë˜ê·¸ ì¤‘ì¸ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° (í¬ì¸íŠ¸ í¸ì§‘) - ë³´ê°„ ì ìš©
                    if (draggedPolygon && draggedPolygon.length > 0) {
                        const scaleFactor = getVideoScaleFactor();
                        const smoothDragged = draggedPolygon.length >= 3 ?
                            interpolatePolygonPoints(draggedPolygon, scaleFactor) :
                            draggedPolygon;

                        previewContext.strokeStyle = '#ffff00';  // ë…¸ë€ìƒ‰ìœ¼ë¡œ êµ¬ë¶„
                        previewContext.lineWidth = 3;
                        previewContext.setLineDash([]);

                        previewContext.beginPath();
                        previewContext.moveTo(smoothDragged[0].x, smoothDragged[0].y);
                        for (let i = 1; i < smoothDragged.length; i++) {
                            previewContext.lineTo(smoothDragged[i].x, smoothDragged[i].y);
                        }
                        previewContext.closePath();
                        previewContext.stroke();

                        // ì  í‘œì‹œ
                        draggedPolygon.forEach((point, idx) => {
                            previewContext.fillStyle = '#ffff00';
                            previewContext.beginPath();
                            previewContext.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                            previewContext.fill();
                        });
                    }

                    needsRedraw = false;
                    animationFrameId = null;
                });
            }
        }

        // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ì„¤ì •
        function setupCanvasEvents() {
            videoCanvas.addEventListener('mousedown', onCanvasMouseDown);
            videoCanvas.addEventListener('mousemove', onCanvasMouseMove);
            videoCanvas.addEventListener('mouseup', onCanvasMouseUp);
            videoCanvas.addEventListener('contextmenu', onCanvasRightClick);

            // ì‹­ìì„  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì´ë²¤íŠ¸
            const canvasContainer = document.getElementById('canvasContainer');
            canvasContainer.addEventListener('mousemove', updateCrosshair);

            // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
            document.addEventListener('click', hideContextMenu);

            // ESC í‚¤ë¡œ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë‹«ê¸°
            document.addEventListener('keydown', function(e) {
                // ESC: Cancel context menu or polygon annotation
                if (e.key === 'Escape' || e.key === 'Esc') {
                    const menu = document.getElementById('annotationContextMenu');
                    if (menu && menu.style.display === 'block') {
                        hideContextMenu();
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }

                    // Cancel polygon annotation in point click mode
                    if (annotationMode === 'point' && isDrawingPolygon && currentPolygonPoints.length > 0) {
                        cancelPolygonAnnotation();
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                }

                // ENTER: Finish polygon annotation in point click mode
                if (e.key === 'Enter') {
                    if (annotationMode === 'point' && isDrawingPolygon && currentPolygonPoints.length >= 3) {
                        finishPolygonAnnotation();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            });
        }

        // í¬ì¸íŠ¸ê°€ ë°•ìŠ¤ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
        function isPointInBox(x, y, box) {
            return x >= box.x && x <= box.x + box.width &&
                   y >= box.y && y <= box.y + box.height;
        }

        // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ê·¼ì²˜ì¸ì§€ í™•ì¸ (10px ë°˜ê²½)
        function findNearbyPolygonPoint(x, y, polygon, threshold = 10) {
            if (!polygon || polygon.length === 0) return -1;

            for (let i = 0; i < polygon.length; i++) {
                const dx = x - polygon[i].x;
                const dy = y - polygon[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= threshold) {
                    return i;
                }
            }
            return -1;
        }

        // í¬ì¸íŠ¸ê°€ í´ë¦¬ê³¤ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
        function isPointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;

            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // ë§ˆìš°ìŠ¤ ë‹¤ìš´
        function onCanvasMouseDown(e) {
            // ìš°í´ë¦­ì€ ë¬´ì‹œ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ìš©)
            if (e.button === 2) {
                console.log('[MOUSE] Right-click mousedown ignored');
                return;
            }

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                console.log('[VIDEO STATUS] Cannot draw on completed video');
                return;
            }

            const rect = videoCanvas.getBoundingClientRect();
            const scaleX = videoCanvas.width / rect.width;
            const scaleY = videoCanvas.height / rect.height;

            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ëª¨ë“œ
            if (isPolygonDrawMode) {
                if (annotationMode === 'polygon') {
                    // ë“œë˜ê·¸ ëª¨ë“œ: ë“œë˜ê·¸ ì‹œì‘
                    isDrawingPolygon = true;
                    currentPolygonPoints = [{x: clickX, y: clickY}];
                    console.log('[POLYGON] Start drawing polygon (drag mode)');
                    return;
                } else if (annotationMode === 'point') {
                    // í¬ì¸íŠ¸ í´ë¦­ ëª¨ë“œ: ì  ì¶”ê°€
                    if (!isDrawingPolygon) {
                        // ì²« ë²ˆì§¸ í´ë¦­: í´ë¦¬ê³¤ ì‹œì‘
                        isDrawingPolygon = true;
                        currentPolygonPoints = [{x: clickX, y: clickY}];
                        console.log('[POLYGON] Start drawing polygon (point click mode)');
                    } else {
                        // ì²« ë²ˆì§¸ ì  ê·¼ì²˜ë¥¼ í´ë¦­í•˜ë©´ í´ë¦¬ê³¤ ì™„ì„±
                        const firstPoint = currentPolygonPoints[0];
                        const dist = Math.sqrt(Math.pow(clickX - firstPoint.x, 2) + Math.pow(clickY - firstPoint.y, 2));

                        if (dist < 15 && currentPolygonPoints.length >= 3) {
                            // í´ë¦¬ê³¤ ì™„ì„±
                            finishPolygonAnnotation();
                            console.log('[POLYGON] Finished polygon by clicking first point');
                        } else {
                            // ìƒˆë¡œìš´ ì  ì¶”ê°€
                            currentPolygonPoints.push({x: clickX, y: clickY});
                            console.log('[POLYGON] Added point', currentPolygonPoints.length);
                            // í”„ë¦¬ë·° ì—…ë°ì´íŠ¸
                            previewPolygon = [...currentPolygonPoints];
                            scheduleRedraw();
                        }
                    }
                    return;
                }
            }

            // ê¸°ì¡´ ì–´ë…¸í…Œì´ì…˜ í´ë¦­ í™•ì¸
            const annotations = frameAnnotations[currentFrame] || [];
            let clickedIndex = -1;

            // ë¨¼ì € ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì˜ í´ë¦¬ê³¤ í¬ì¸íŠ¸ í´ë¦­ í™•ì¸
            if (selectedAnnotationIndex !== -1 && selectedAnnotationIndex < annotations.length) {
                const selectedAnno = annotations[selectedAnnotationIndex];
                if (selectedAnno.polygon && selectedAnno.polygon.length > 0) {
                    const pointIndex = findNearbyPolygonPoint(clickX, clickY, selectedAnno.polygon);
                    if (pointIndex !== -1) {
                        // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì‹œì‘
                        isDraggingPoint = true;
                        draggingPointIndex = pointIndex;
                        console.log('[POLYGON] Start dragging point', pointIndex);
                        return;
                    }
                }
            }

            // ì—­ìˆœìœ¼ë¡œ ê²€ìƒ‰ (ë‚˜ì¤‘ì— ê·¸ë ¤ì§„ ê²ƒì´ ìœ„ì— ìˆìœ¼ë¯€ë¡œ)
            for (let i = annotations.length - 1; i >= 0; i--) {
                const anno = annotations[i];

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ í´ë¦¬ê³¤ ë‚´ë¶€ ì²´í¬
                if (anno.polygon && anno.polygon.length > 0) {
                    if (isPointInPolygon(clickX, clickY, anno.polygon)) {
                        clickedIndex = i;
                        break;
                    }
                } else if (isPointInBox(clickX, clickY, anno.box)) {
                    // í´ë¦¬ê³¤ì´ ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ ì²´í¬
                    clickedIndex = i;
                    break;
                }
            }

            if (clickedIndex !== -1) {
                // ì–´ë…¸í…Œì´ì…˜ ì„ íƒ
                selectedAnnotationIndex = clickedIndex;
                drawFrameWithMasks();
                updateAnnotationList();
                console.log('[ANNOTATION] Selected annotation', clickedIndex);
                return;
            }

            // ìƒˆ ë°•ìŠ¤ ê·¸ë¦¬ê¸° ì‹œì‘
            selectedAnnotationIndex = -1;
            startX = clickX;
            startY = clickY;
            isDrawing = true;
        }

        // ë§ˆìš°ìŠ¤ ì´ë™
        function onCanvasMouseMove(e) {
            const rect = videoCanvas.getBoundingClientRect();
            const scaleX = videoCanvas.width / rect.width;
            const scaleY = videoCanvas.height / rect.height;

            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;

            // í´ë¦¬ê³¤ ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ì¤‘
            if (isDrawingPolygon) {
                // ë“œë˜ê·¸ ëª¨ë“œ: ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ ìë™ìœ¼ë¡œ ì  ì¶”ê°€
                if (annotationMode === 'polygon') {
                    // ë§ˆì§€ë§‰ ì ê³¼ì˜ ê±°ë¦¬ê°€ ì¼ì • ì´ìƒì´ë©´ ìƒˆ ì  ì¶”ê°€ (ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
                    const lastPoint = currentPolygonPoints[currentPolygonPoints.length - 1];
                    const dx = currentX - lastPoint.x;
                    const dy = currentY - lastPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // 20í”½ì…€ ì´ìƒ ì›€ì§ì´ë©´ ìƒˆ ì  ì¶”ê°€ (ì  ê°œìˆ˜ 25%ë¡œ ê°ì†Œ)
                    if (distance > 20) {
                        currentPolygonPoints.push({x: currentX, y: currentY});

                        // í”„ë¦¬ë·° í´ë¦¬ê³¤ ì—…ë°ì´íŠ¸
                        previewPolygon = [...currentPolygonPoints];
                        scheduleRedraw();
                    }
                } else if (annotationMode === 'point') {
                    // í¬ì¸íŠ¸ í´ë¦­ ëª¨ë“œ: ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ ë¯¸ë¦¬ë³´ê¸°ë§Œ ì—…ë°ì´íŠ¸ (ì  ì¶”ê°€ ì•ˆ í•¨)
                    // í˜„ì¬ ì ë“¤ê³¼ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì—°ê²°í•œ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
                    previewPolygon = [...currentPolygonPoints, {x: currentX, y: currentY}];
                    scheduleRedraw();
                }
                return;
            }

            // ì»¤ì„œ ìŠ¤íƒ€ì¼ ë³€ê²½ (í´ë¦¬ê³¤ í¬ì¸íŠ¸ ìœ„ì— ìˆì„ ë•Œ)
            if (!isDraggingPoint && !isDrawing && !isPolygonDrawMode) {
                const annotations = frameAnnotations[currentFrame] || [];
                if (selectedAnnotationIndex !== -1 && selectedAnnotationIndex < annotations.length) {
                    const selectedAnno = annotations[selectedAnnotationIndex];
                    if (selectedAnno.polygon && selectedAnno.polygon.length > 0) {
                        const nearbyPoint = findNearbyPolygonPoint(currentX, currentY, selectedAnno.polygon);
                        videoCanvas.style.cursor = nearbyPoint !== -1 ? 'move' : 'default';
                    } else {
                        videoCanvas.style.cursor = 'default';
                    }
                } else {
                    videoCanvas.style.cursor = 'crosshair';
                }
            }

            // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘
            if (isDraggingPoint) {
                const annotations = frameAnnotations[currentFrame] || [];
                if (selectedAnnotationIndex !== -1 && selectedAnnotationIndex < annotations.length) {
                    const anno = annotations[selectedAnnotationIndex];
                    if (anno.polygon && draggingPointIndex !== -1) {
                        // ë“œë˜ê·¸ ì¤‘ì¸ í´ë¦¬ê³¤ ë³µì‚¬ ë° í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸
                        draggedPolygon = anno.polygon.map((p, i) => ({
                            x: i === draggingPointIndex ? currentX : p.x,
                            y: i === draggingPointIndex ? currentY : p.y
                        }));

                        // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ì—ë§Œ ê·¸ë¦¬ê¸°
                        scheduleRedraw();
                    }
                }
                return;
            }

            // ë°•ìŠ¤ ê·¸ë¦¬ê¸° ì¤‘
            if (!isDrawing) return;

            // ë°•ìŠ¤ ê·¸ë¦¬ê¸° ë¯¸ë¦¬ë³´ê¸°
            previewBox = {
                x: startX,
                y: startY,
                width: currentX - startX,
                height: currentY - startY
            };
            scheduleRedraw();
        }

        // í´ë¦¬ê³¤ì—ì„œ ë°”ìš´ë”© ë°•ìŠ¤ ì¬ê³„ì‚°
        function updateBoundingBoxFromPolygon(annotation) {
            if (!annotation.polygon || annotation.polygon.length === 0) return;

            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            annotation.polygon.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });

            annotation.box = {
                x: Math.floor(minX),
                y: Math.floor(minY),
                width: Math.ceil(maxX - minX),
                height: Math.ceil(maxY - minY)
            };

            console.log('[POLYGON] Updated bounding box:', annotation.box);
        }

        // í´ë¦¬ê³¤ì—ì„œ ë§ˆìŠ¤í¬ ì¬ìƒì„±
        async function regenerateMaskFromPolygon(annotation) {
            if (!annotation.polygon || annotation.polygon.length < 3) {
                console.warn('[MASK] Cannot regenerate mask: invalid polygon');
                return false;
            }

            try {
                console.log('[MASK] Regenerating mask from edited polygon...');

                // ë°”ìš´ë”© ë°•ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
                const box = annotation.box;
                const relativePolygon = annotation.polygon.map(p => ({
                    x: p.x - box.x,
                    y: p.y - box.y
                }));

                const response = await fetch(API_BASE_URL + '/api/polygon/generate_mask', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        polygon: relativePolygon,
                        width: box.width,
                        height: box.height,
                        class_id: annotation.class_id || 1
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // ìƒˆ ë§ˆìŠ¤í¬ë¡œ ì—…ë°ì´íŠ¸
                    annotation.mask = data.mask;
                    console.log('[MASK] Mask regenerated successfully');
                    return true;
                } else {
                    console.error('[MASK] Failed to regenerate mask:', data.error);
                    return false;
                }
            } catch (error) {
                console.error('[MASK] Error regenerating mask:', error);
                return false;
            }
        }

        // í´ë˜ìŠ¤ ì„ íƒ íŒì—… ê´€ë ¨ í•¨ìˆ˜
        // í´ë˜ìŠ¤ ì„ íƒ íŒì—… ê´€ë ¨ ë³€ìˆ˜
        let classSelectionResolve = null;
        let popupEscHandler = null;
        let popupOutsideClickHandler = null;

        function showClassSelectionPopup(classes, mouseX, mouseY) {
            return new Promise((resolve) => {
                classSelectionResolve = resolve;

                const popup = document.getElementById('classSelectionPopup');
                const buttonsContainer = document.getElementById('classSelectionButtons');

                // ë²„íŠ¼ ìƒì„±
                buttonsContainer.innerHTML = '';
                classes.forEach((classObj, index) => {
                    const className = (typeof classObj === 'string') ? classObj : classObj.name;
                    const classDesc = (typeof classObj === 'string') ? '' : (classObj.description || '');

                    // ì–¸ì–´ì— ë”°ë¼ ì£¼ ì´ë¦„ê³¼ ë¶€ì œëª© ê²°ì •
                    const displayName = (typeof classObj === 'string') ? classObj : getClassDisplayName(classObj);
                    const displaySubtitle = (typeof classObj === 'string') ? '' :
                        (currentLanguage === 'ko' ? classObj.name : classObj.description) || '';

                    const button = document.createElement('button');
                    button.style.padding = '10px 15px';
                    button.style.fontSize = '13px';
                    button.style.textAlign = 'left';
                    button.style.background = '#2d2d2d';
                    button.style.border = '1px solid #404040';
                    button.style.borderRadius = '4px';
                    button.style.cursor = 'pointer';
                    button.style.transition = 'all 0.2s';
                    button.style.width = '100%';
                    button.style.color = '#ddd';

                    button.innerHTML = `
                        <div style="font-weight: 600; color: #4a9eff;">${displayName}</div>
                        ${displaySubtitle ? `<div style="font-size: 11px; color: #888; margin-top: 2px;">${displaySubtitle}</div>` : ''}
                    `;

                    button.onmouseover = () => {
                        button.style.background = '#4a9eff';
                        button.style.borderColor = '#4a9eff';
                        // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½í•˜ì—¬ ê°€ë…ì„± í–¥ìƒ
                        const titleDiv = button.querySelector('div:first-child');
                        const subtitleDiv = button.querySelector('div:nth-child(2)');
                        if (titleDiv) titleDiv.style.color = '#ffffff';
                        if (subtitleDiv) subtitleDiv.style.color = '#e0e0e0';
                    };

                    button.onmouseout = () => {
                        button.style.background = '#2d2d2d';
                        button.style.borderColor = '#404040';
                        // ì›ë˜ í…ìŠ¤íŠ¸ ìƒ‰ìƒìœ¼ë¡œ ë³µì›
                        const titleDiv = button.querySelector('div:first-child');
                        const subtitleDiv = button.querySelector('div:nth-child(2)');
                        if (titleDiv) titleDiv.style.color = '#4a9eff';
                        if (subtitleDiv) subtitleDiv.style.color = '#888';
                    };

                    button.onclick = () => {
                        popup.style.display = 'none';
                        classSelectionResolve({ name: className, index: index });
                        classSelectionResolve = null;
                    };

                    buttonsContainer.appendChild(button);
                });

                // í´ë˜ìŠ¤ ê°œìˆ˜ì— ë”°ë¼ Grid ë ˆì´ì•„ì›ƒ ì„¤ì • (1ì—´ ìµœëŒ€ 5ê°œ)
                const classCount = classes.length;
                if (classCount <= 5) {
                    // 5ê°œ ì´í•˜: 1ì—´
                    buttonsContainer.style.gridTemplateColumns = '1fr';
                } else if (classCount <= 10) {
                    // 6~10ê°œ: 2ì—´
                    buttonsContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
                } else {
                    // 11ê°œ ì´ìƒ: 3ì—´
                    buttonsContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
                }

                // íŒì—…ì„ ì¼ë‹¨ í‘œì‹œí•˜ì—¬ í¬ê¸° ê³„ì‚°
                popup.style.display = 'block';
                popup.style.visibility = 'hidden';

                // ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ìœ„ì¹˜ ê³„ì‚° (ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
                requestAnimationFrame(() => {
                    const popupWidth = popup.offsetWidth;
                    const popupHeight = popup.offsetHeight;

                    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ì¡°ì •
                    let x = mouseX;
                    let y = mouseY;

                    // ì˜¤ë¥¸ìª½ ê²½ê³„ ì²´í¬
                    if (x + popupWidth > window.innerWidth) {
                        x = window.innerWidth - popupWidth - 10;
                    }

                    // í•˜ë‹¨ ê²½ê³„ ì²´í¬
                    if (y + popupHeight > window.innerHeight) {
                        y = window.innerHeight - popupHeight - 10;
                    }

                    // ìµœì†Œ ìœ„ì¹˜ ë³´ì •
                    x = Math.max(10, x);
                    y = Math.max(10, y);

                    popup.style.left = x + 'px';
                    popup.style.top = y + 'px';
                    popup.style.visibility = 'visible';

                    console.log('[POPUP] Positioned at:', x, y);
                });

                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
                if (popupEscHandler) {
                    document.removeEventListener('keydown', popupEscHandler);
                }
                if (popupOutsideClickHandler) {
                    document.removeEventListener('click', popupOutsideClickHandler, true);
                }

                // ESC í‚¤ë¡œ ë‹«ê¸°
                popupEscHandler = (e) => {
                    if (e.key === 'Escape') {
                        closeClassSelectionPopup();
                    }
                };
                document.addEventListener('keydown', popupEscHandler);

                // íŒì—… ì™¸ë¶€ í´ë¦­ì‹œ ë‹«ê¸° (ìº”ë²„ìŠ¤ ì œì™¸)
                popupOutsideClickHandler = (e) => {
                    // ìº”ë²„ìŠ¤ë‚˜ íŒì—… ë‚´ë¶€ í´ë¦­ì€ ë¬´ì‹œ
                    const canvas = document.getElementById('videoCanvas');
                    if (!popup.contains(e.target) && e.target !== canvas) {
                        closeClassSelectionPopup();
                    }
                };
                // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (í˜„ì¬ í´ë¦­ ì´ë²¤íŠ¸ì™€ ì¶©ëŒ ë°©ì§€)
                setTimeout(() => {
                    document.addEventListener('click', popupOutsideClickHandler, true); // capture phaseì—ì„œ ì²˜ë¦¬
                }, 100);
            });
        }

        function closeClassSelectionPopup() {
            const popup = document.getElementById('classSelectionPopup');
            popup.style.display = 'none';
            if (classSelectionResolve) {
                classSelectionResolve(null); // ì·¨ì†Œ
                classSelectionResolve = null;
            }
        }

        // í´ë¦¬ê³¤ì— ëŒ€í•œ ë¼ë²¨ ì…ë ¥ ë°›ê¸°

        async function promptForLabel(polygon, box, mouseX, mouseY) {
            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                console.log('[VIDEO STATUS] Cannot add annotation to completed video');
                alert('ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                drawFrameWithMasks();
                return;
            }

            if (!currentProject || !currentProject.classes) {
                alert('í”„ë¡œì íŠ¸ í´ë˜ìŠ¤ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                drawFrameWithMasks();
                return;
            }

            let classes = currentProject.classes;
            if (!Array.isArray(classes)) {
                classes = [];
            }

            if (classes.length === 0) {
                alert('í”„ë¡œì íŠ¸ì— í´ë˜ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤. í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.');
                drawFrameWithMasks();
                return;
            }

            // í´ë˜ìŠ¤ ì„ íƒ íŒì—… ë„ìš°ê¸° (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì—)
            const selectedClass = await showClassSelectionPopup(classes, mouseX, mouseY);

            if (!selectedClass) {
                // ì·¨ì†Œë¨
                drawFrameWithMasks();
                return;
            }

            const label = selectedClass.name;
            const class_id = selectedClass.index + 1;

            console.log('[POLYGON] Selected label:', label, 'class_id:', class_id);

            // í´ë¦¬ê³¤ì—ì„œ ë§ˆìŠ¤í¬ ìƒì„±
            try {
                // ë°”ìš´ë”© ë°•ìŠ¤ ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
                const relativePolygon = polygon.map(p => ({
                    x: p.x - box.x,
                    y: p.y - box.y
                }));

                const response = await authFetch('/api/polygon/generate_mask', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        polygon: relativePolygon,
                        width: box.width,
                        height: box.height,
                        class_id: class_id
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const annotation = {
                        box: box,
                        label: label,
                        class_id: class_id,
                        polygon: polygon,
                        mask: data.mask,
                        has_segmentation: true,
                        manual_draw: true  // ìˆ˜ë™ìœ¼ë¡œ ê·¸ë¦° ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ
                    };

                    if (!frameAnnotations[currentFrame]) {
                        frameAnnotations[currentFrame] = [];
                    }
                    frameAnnotations[currentFrame].push(annotation);

                    console.log('[POLYGON] Added manual annotation:', label);

                    drawFrameWithMasks();
                    updateAnnotationList();
                    updateStatistics();
                } else {
                    console.error('[POLYGON] Failed to generate mask:', data.error);
                    alert('ë§ˆìŠ¤í¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + data.error);
                }
            } catch (error) {
                console.error('[POLYGON] Error generating mask:', error);
                alert('ë§ˆìŠ¤í¬ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ë§ˆìš°ìŠ¤ ì—…
        async function onCanvasMouseUp(e) {
            // ìš°í´ë¦­ì€ ë¬´ì‹œ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ìš©)
            if (e.button === 2) {
                console.log('[MOUSE] Right-click mouseup ignored');
                return;
            }

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                console.log('[VIDEO STATUS] Cannot complete drawing on completed video');
                // ê·¸ë¦¬ê¸° ìƒíƒœ ì´ˆê¸°í™”
                isDrawing = false;
                isDrawingPolygon = false;
                currentPolygonPoints = [];
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                return;
            }

            // í´ë¦¬ê³¤ ë“œë˜ê·¸ ê·¸ë¦¬ê¸° ì™„ë£Œ
            if (isDrawingPolygon) {
                // í¬ì¸íŠ¸ í´ë¦­ ëª¨ë“œì—ì„œëŠ” mouseupìœ¼ë¡œ ì¢…ë£Œí•˜ì§€ ì•ŠìŒ (í´ë¦­ìœ¼ë¡œë§Œ ì  ì¶”ê°€)
                if (annotationMode === 'point') {
                    console.log('[POLYGON] Point mode: mouseup ignored, use Enter or click first point to finish');
                    return;
                }

                // ë“œë˜ê·¸ ëª¨ë“œ: mouseup ì‹œ í´ë¦¬ê³¤ ì¢…ë£Œ
                isDrawingPolygon = false;
                previewPolygon = null;  // í”„ë¦¬ë·° ì´ˆê¸°í™”
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);  // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”

                // ìµœì†Œ 3ê°œ ì  ì´ìƒ í•„ìš”
                if (currentPolygonPoints.length < 3) {
                    console.warn('[POLYGON] Not enough points, need at least 3');
                    currentPolygonPoints = [];
                    drawFrameWithMasks();
                    alert('í´ë¦¬ê³¤ì´ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤. ë” í¬ê²Œ ê·¸ë ¤ì£¼ì„¸ìš”.');
                    return;
                }

                console.log('[POLYGON] Finished drawing polygon with', currentPolygonPoints.length, 'points');

                // í´ë¦¬ê³¤ ë‹¨ìˆœí™” (Douglas-Peucker ì•Œê³ ë¦¬ì¦˜ ì ìš© ê°€ëŠ¥í•˜ì§€ë§Œ ì¼ë‹¨ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
                // ë§ˆì§€ë§‰ ì ê³¼ ì²« ì ì„ ì—°ê²°í•˜ì—¬ í´ë¦¬ê³¤ ë‹«ê¸°
                const polygon = [...currentPolygonPoints];

                // ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                polygon.forEach(point => {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                });

                const box = {
                    x: Math.floor(minX),
                    y: Math.floor(minY),
                    width: Math.ceil(maxX - minX),
                    height: Math.ceil(maxY - minY)
                };

                // ì‚¬ìš©ìì—ê²Œ ë¼ë²¨ ì„ íƒ ë°›ê¸° (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— íŒì—… í‘œì‹œ)
                await promptForLabel(polygon, box, e.clientX, e.clientY);

                currentPolygonPoints = [];
                return;
            }

            // í´ë¦¬ê³¤ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¢…ë£Œ
            if (isDraggingPoint) {
                isDraggingPoint = false;
                console.log('[POLYGON] Finished dragging point');

                // ë“œë˜ê·¸í•œ í´ë¦¬ê³¤ì„ ì‹¤ì œ ì–´ë…¸í…Œì´ì…˜ì— ì ìš©
                const annotations = frameAnnotations[currentFrame] || [];
                if (selectedAnnotationIndex !== -1 && draggedPolygon) {
                    const anno = annotations[selectedAnnotationIndex];
                    anno.polygon = draggedPolygon;

                    // ë°”ìš´ë”© ë°•ìŠ¤ ì¬ê³„ì‚°
                    updateBoundingBoxFromPolygon(anno);

                    // í´ë¦¬ê³¤ í¸ì§‘ í›„ ë§ˆìŠ¤í¬ ì¬ìƒì„±
                    await regenerateMaskFromPolygon(anno);
                }

                // í”„ë¦¬ë·° ì´ˆê¸°í™”
                draggedPolygon = null;
                draggingPointIndex = -1;
                previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

                // í™”ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                drawFrameWithMasks();

                return;
            }

            if (!isDrawing) return;
            isDrawing = false;
            previewBox = null;  // í”„ë¦¬ë·° ì´ˆê¸°í™”
            previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);  // í”„ë¦¬ë·° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”

            const rect = videoCanvas.getBoundingClientRect();
            const scaleX = videoCanvas.width / rect.width;
            const scaleY = videoCanvas.height / rect.height;

            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            const box = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };

            // ë°•ìŠ¤ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ë¬´ì‹œ
            if (box.width < 10 || box.height < 10) {
                drawFrameWithMasks();
                return;
            }

            // AIê°€ ì´ˆê¸°í™”ë˜ì–´ ìˆê³  ìë™ ì¶”ë¡ ì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë°•ìŠ¤ ì˜ì—­ì— ëŒ€í•´ ì¶”ë¡  ì‹¤í–‰
            if (aiInitialized && aiAutoInferenceEnabled) {
                const annotation = { box, label: 'detecting...' };
                await runInferenceOnBox(annotation);
            } else {
                // AIê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ í´ë˜ìŠ¤ ì„ íƒ íŒì—… í‘œì‹œ
                const rect = videoCanvas.getBoundingClientRect();
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                const result = await showClassSelectionPopup(projectClasses, mouseX, mouseY);
                if (!result) {
                    drawFrame();
                    return;
                }

                const annotation = { box, label: result.name };
                if (!frameAnnotations[currentFrame]) {
                    frameAnnotations[currentFrame] = [];
                }
                frameAnnotations[currentFrame].push(annotation);
                drawFrame();
                updateAnnotationList();
                updateStatistics();
            }
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ê´€ë ¨ ë³€ìˆ˜
        let contextMenuAnnotationIndex = -1;

        // ìš°í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        function onCanvasRightClick(e) {
            e.preventDefault(); // ë¸Œë¼ìš°ì € ê¸°ë³¸ ë©”ë‰´ ì°¨ë‹¨

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ëŠ” í¸ì§‘ ë¶ˆê°€
            if (currentVideoStatus === 'completed') {
                return;
            }

            // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ì¤‘ì´ê±°ë‚˜ í¬ì¸íŠ¸ ë“œë˜ê·¸ ì¤‘ì´ë©´ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œí•˜ì§€ ì•ŠìŒ
            if (isDrawingPolygon || isDraggingPoint || isDrawing) {
                console.log('[CONTEXT MENU] Cannot show menu while drawing');
                return;
            }

            const rect = videoCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (videoCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (videoCanvas.height / rect.height);

            // í˜„ì¬ í”„ë ˆì„ì˜ ì–´ë…¸í…Œì´ì…˜ë“¤ í™•ì¸
            const annotations = frameAnnotations[currentFrame] || [];

            // í´ë¦­í•œ ìœ„ì¹˜ì˜ ì–´ë…¸í…Œì´ì…˜ ì°¾ê¸° (ë’¤ì—ì„œë¶€í„° ê²€ìƒ‰ - ìœ„ì— ìˆëŠ” ê²ƒë¶€í„°)
            let clickedAnnotationIndex = -1;
            for (let i = annotations.length - 1; i >= 0; i--) {
                const anno = annotations[i];
                if (anno.shape === 'polygon' || anno.polygon) {
                    const polygon = anno.polygon || (anno.shape === 'polygon' ? anno.points : null);
                    if (polygon && isPointInPolygon(x, y, polygon)) {
                        clickedAnnotationIndex = i;
                        break;
                    }
                } else if (anno.box) {
                    if (isPointInBox(x, y, anno.box)) {
                        clickedAnnotationIndex = i;
                        break;
                    }
                }
            }

            // ì–´ë…¸í…Œì´ì…˜ì„ ì°¾ì•˜ìœ¼ë©´ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
            if (clickedAnnotationIndex !== -1) {
                contextMenuAnnotationIndex = clickedAnnotationIndex;
                // ë§ˆìš°ìŠ¤ í´ë¦­ ìœ„ì¹˜ì—ì„œ ì•½ê°„ ì˜¤ë¥¸ìª½ ì•„ë˜ì— í‘œì‹œ (offset +5px)
                showContextMenu(e.clientX + 5, e.clientY + 5);
            } else {
                hideContextMenu();
            }
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
        function showContextMenu(x, y) {
            const menu = document.getElementById('annotationContextMenu');
            if (!menu) return;

            // í”„ë¡œì íŠ¸ì™€ í´ë˜ìŠ¤ ì •ë³´ í™•ì¸
            if (!currentProject || !currentProject.classes) {
                console.warn('[CONTEXT MENU] No project or classes available');
                return;
            }

            const classes = currentProject.classes;
            const classCount = classes.length;

            // ì»¬ëŸ¼ ìˆ˜ ê²°ì • (5ê°œ ì´í•˜: 1ì—´, 6-10ê°œ: 2ì—´, 11ê°œ ì´ìƒ: 3ì—´)
            let gridColumns = '1fr';
            if (classCount > 10) {
                gridColumns = 'repeat(3, 1fr)';
            } else if (classCount > 5) {
                gridColumns = 'repeat(2, 1fr)';
            }

            // ë©”ë‰´ ë‚´ìš© ìƒì„±
            let menuHTML = '<div style="padding: 4px 0; color: #fff; font-size: 12px; font-weight: bold; padding: 8px 12px; border-bottom: 1px solid #404040;">í´ë˜ìŠ¤ ë³€ê²½</div>';

            // ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ ì‹œì‘
            menuHTML += `<div style="display: grid; grid-template-columns: ${gridColumns}; gap: 4px; padding: 4px;">`;

            classes.forEach((cls, index) => {
                const annotation = (frameAnnotations[currentFrame] || [])[contextMenuAnnotationIndex];
                const isCurrentClass = annotation && annotation.label === cls.name;

                menuHTML += `
                    <div onclick="changeAnnotationClass('${cls.name}')" style="
                        padding: 8px 12px;
                        cursor: pointer;
                        background: ${isCurrentClass ? '#404040' : 'transparent'};
                        color: ${isCurrentClass ? '#4a9eff' : '#fff'};
                        transition: background 0.2s;
                        border-radius: 4px;
                    " onmouseover="this.style.background='#404040'" onmouseout="this.style.background='${isCurrentClass ? '#404040' : 'transparent'}'">
                        <span style="display: inline-block; width: 12px; height: 12px; background: ${cls.color || '#4a9eff'}; margin-right: 8px; vertical-align: middle;"></span>
                        ${getClassDisplayName(cls)}
                    </div>
                `;
            });

            // ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ ì¢…ë£Œ
            menuHTML += '</div>';

            menu.innerHTML = menuHTML;

            // ë©”ë‰´ë¥¼ ìˆ¨ê¸´ ìƒíƒœë¡œ í‘œì‹œí•˜ì—¬ í¬ê¸° ì¸¡ì •
            menu.style.visibility = 'hidden';
            menu.style.display = 'block';
            menu.style.left = '0px';
            menu.style.top = '0px';

            // ê°•ì œë¡œ ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° (reflow)
            menu.offsetHeight;

            // ë©”ë‰´ í¬ê¸° ì¸¡ì • í›„ ìœ„ì¹˜ ê³„ì‚°
            const menuRect = menu.getBoundingClientRect();
            const menuWidth = menuRect.width;
            const menuHeight = menuRect.height;

            // í™”ë©´ í¬ê¸°
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // ê¸°ë³¸ ì˜¤í”„ì…‹
            const offset = 5;

            // ìˆ˜í‰ ìœ„ì¹˜ ê²°ì •: í´ë¦­ ì§€ì ì´ í™”ë©´ ì˜¤ë¥¸ìª½ì— ê°€ê¹Œìš°ë©´ ë©”ë‰´ë¥¼ ì™¼ìª½ì— í‘œì‹œ
            let menuX;
            if (x + menuWidth + offset > viewportWidth) {
                // í™”ë©´ ì˜¤ë¥¸ìª½ì´ë©´ ë©”ë‰´ë¥¼ ë§ˆìš°ìŠ¤ ì™¼ìª½ì— í‘œì‹œ
                menuX = x - menuWidth - offset;
            } else {
                // í™”ë©´ ì™¼ìª½ì´ë©´ ë©”ë‰´ë¥¼ ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ì— í‘œì‹œ
                menuX = x + offset;
            }

            // ìˆ˜ì§ ìœ„ì¹˜ ê²°ì •: í´ë¦­ ì§€ì ì´ í™”ë©´ ì•„ë˜ìª½ì— ê°€ê¹Œìš°ë©´ ë©”ë‰´ë¥¼ ìœ„ìª½ì— í‘œì‹œ
            let menuY;
            if (y + menuHeight + offset > viewportHeight) {
                // í™”ë©´ ì•„ë˜ìª½ì´ë©´ ë©”ë‰´ë¥¼ ë§ˆìš°ìŠ¤ ìœ„ìª½ì— í‘œì‹œ
                menuY = y - menuHeight - offset;
            } else {
                // í™”ë©´ ìœ„ìª½ì´ë©´ ë©”ë‰´ë¥¼ ë§ˆìš°ìŠ¤ ì•„ë˜ìª½ì— í‘œì‹œ
                menuY = y + offset;
            }

            // ìµœì¢… ìœ„ì¹˜ê°€ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ë³´ì •
            menuX = Math.max(0, Math.min(menuX, viewportWidth - menuWidth));
            menuY = Math.max(0, Math.min(menuY, viewportHeight - menuHeight));

            // ìµœì¢… ìœ„ì¹˜ ì„¤ì • ë° í‘œì‹œ
            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            menu.style.visibility = 'visible';
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°
        function hideContextMenu() {
            const menu = document.getElementById('annotationContextMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            contextMenuAnnotationIndex = -1;
        }

        // ì–´ë…¸í…Œì´ì…˜ í´ë˜ìŠ¤ ë³€ê²½
        function changeAnnotationClass(newClassName) {
            if (contextMenuAnnotationIndex === -1 || !frameAnnotations[currentFrame]) {
                hideContextMenu();
                return;
            }

            const annotation = frameAnnotations[currentFrame][contextMenuAnnotationIndex];
            if (annotation) {
                annotation.label = newClassName;
                console.log(`[ANNOTATION] Changed class to: ${newClassName}`);

                // í™”ë©´ ì—…ë°ì´íŠ¸ (ë§ˆìŠ¤í¬/í´ë¦¬ê³¤ í¬í•¨)
                drawFrameWithMasks();
                updateAnnotationList();
                updateStatistics();
            }

            hideContextMenu();
        }

        // í´ë¦¬ê³¤ ë‚´ë¶€ í¬ì¸íŠ¸ í™•ì¸ (Ray Casting Algorithm)
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }


        // ì „ì²´ í”„ë ˆì„ì— ëŒ€í•´ AI ì¶”ë¡  ì‹¤í–‰
        // AI ì¶”ë¡  í•¨ìˆ˜ (ë¹„í™œì„±í™”ë¨)
        async function runFullFrameInference() {
            // ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ë¡  ê¸°ëŠ¥ ì œê±°ë¨
            console.log('[AI] runFullFrameInference is disabled');
            return;

            if (!currentProjectId || !currentVideoId || currentFrame === null) {
                return;
            }

            console.log('[AI] Running full frame inference...');

            try {
                const response = await authFetch('/api/ai/inference', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_dir: currentProject.project_dir,
                        video_id: currentVideoId,
                        frame_number: currentFrame
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[AI] Full frame inference completed');

                    // í”„ë ˆì„ ì–´ë…¸í…Œì´ì…˜ ì´ˆê¸°í™”
                    if (!frameAnnotations[currentFrame]) {
                        frameAnnotations[currentFrame] = [];
                    }

                    // ê¸°ì¡´ ìë™ ìƒì„± ì–´ë…¸í…Œì´ì…˜ ì œê±° (auto_detected í”Œë˜ê·¸)
                    frameAnnotations[currentFrame] = frameAnnotations[currentFrame].filter(anno => !anno.auto_detected);

                    // ë°”ìš´ë”© ë°•ìŠ¤ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë³€í™˜
                    if (data.bounding_boxes && data.bounding_boxes.length > 0) {
                        console.log('[AI] Found', data.bounding_boxes.length, 'objects');

                        // í•´ìƒë„ì˜ 10% ê³„ì‚° (ë©´ì  ê¸°ì¤€)
                        const frameWidth = currentFrameImage.width;
                        const frameHeight = currentFrameImage.height;
                        const frameArea = frameWidth * frameHeight;
                        const minArea = frameArea * 0.10; // 10%

                        let filteredCount = 0;
                        let addedCount = 0;

                        data.bounding_boxes.forEach(bbox => {
                            const bboxArea = bbox.width * bbox.height;

                            // ë°”ìš´ë”© ë°•ìŠ¤ ë©´ì ì´ í•´ìƒë„ì˜ 10% ì´ìƒì¸ ê²½ìš°ë§Œ ì¶”ê°€
                            if (bboxArea >= minArea) {
                                const annotation = {
                                    box: {
                                        x: bbox.x,
                                        y: bbox.y,
                                        width: bbox.width,
                                        height: bbox.height
                                    },
                                    label: bbox.label,
                                    class_id: bbox.class_id,
                                    confidence: bbox.confidence,
                                    mask: bbox.mask,  // ë°”ìš´ë”© ë°•ìŠ¤ ì˜ì—­ì˜ ë§ˆìŠ¤í¬
                                    polygon: bbox.polygon || [],  // ì„œë²„ì—ì„œ ì¶”ì¶œí•œ í´ë¦¬ê³¤
                                    has_segmentation: true,
                                    auto_detected: true  // ìë™ ê°ì§€ëœ ì–´ë…¸í…Œì´ì…˜ì„ì„ í‘œì‹œ
                                };

                                frameAnnotations[currentFrame].push(annotation);
                                addedCount++;
                            } else {
                                filteredCount++;
                                console.log('[AI] Filtered out small bbox:', bbox.label,
                                          `(${bbox.width}x${bbox.height} = ${bboxArea.toFixed(0)} < ${minArea.toFixed(0)})`);
                            }
                        });

                        console.log('[AI] Added', addedCount, 'annotations (filtered', filteredCount, 'small boxes)');
                    } else {
                        console.log('[AI] No objects detected in full frame');
                    }

                    // ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    drawFrameWithMasks();

                    updateAnnotationList();
                    updateStatistics();
                } else {
                    console.error('[AI] Full frame inference error:', data.error);
                }
            } catch (error) {
                console.error('[AI] Full frame inference failed:', error);
            }
        }

        // ë°•ìŠ¤ ì˜ì—­ì— ëŒ€í•´ AI ì¶”ë¡  ì‹¤í–‰
        async function runInferenceOnBox(annotation) {
            if (!currentProjectId || !currentVideoId || currentFrame === null) {
                return;
            }

            console.log('[AI] Running inference on box region:', annotation.box);

            try {
                const response = await authFetch('/api/ai/inference_box', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_dir: currentProject.project_dir,
                        video_id: currentVideoId,
                        frame_number: currentFrame,
                        box: annotation.box
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[AI] Box inference completed:', data.dominant_class_name, `(${(data.dominant_class_ratio*100).toFixed(1)}%)`);

                    // backgroundê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì–´ë…¸í…Œì´ì…˜ ì¶”ê°€
                    if (data.dominant_class_name !== 'background') {
                        // AIê°€ ê°ì§€í•œ í´ë˜ìŠ¤ë¥¼ ë¼ë²¨ë¡œ ì‚¬ìš©
                        annotation.label = data.dominant_class_name;
                        annotation.class_id = data.dominant_class;
                        annotation.confidence = data.dominant_class_ratio;

                        // ë§ˆìŠ¤í¬ ë°ì´í„° ì €ì¥ (Base64 PNG)
                        annotation.mask = data.mask;
                        annotation.has_segmentation = true;

                        // í´ë¦¬ê³¤ ë°ì´í„° ì €ì¥ (ìˆëŠ” ê²½ìš°)
                        if (data.polygon && data.polygon.length > 0) {
                            annotation.polygon = data.polygon;
                        }

                        // ì–´ë…¸í…Œì´ì…˜ ì¶”ê°€
                        if (!frameAnnotations[currentFrame]) {
                            frameAnnotations[currentFrame] = [];
                        }
                        frameAnnotations[currentFrame].push(annotation);

                        console.log('[AI] Added annotation:', data.dominant_class_name, 'with confidence', (data.dominant_class_ratio*100).toFixed(1) + '%');
                    } else {
                        console.log('[AI] Skipped - only background detected in the box');
                        alert('í•´ë‹¹ ì˜ì—­ì—ì„œ ë…¹(rust)ì´ë‚˜ ìŠ¤ì¼€ì¼(scale)ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n\në‹¤ë¥¸ ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    }

                    // ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ì›ë³¸ í”„ë ˆì„ ìœ„ì— ëª¨ë“  ë§ˆìŠ¤í¬ ì ìš©)
                    drawFrameWithMasks();

                    updateAnnotationList();
                    updateStatistics();
                } else {
                    console.error('[AI] Box inference error:', data.error);
                    // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ë°•ìŠ¤ëŠ” ì €ì¥
                    if (!frameAnnotations[currentFrame]) {
                        frameAnnotations[currentFrame] = [];
                    }
                    frameAnnotations[currentFrame].push(annotation);
                    drawFrame();
                    updateAnnotationList();
                    updateStatistics();
                }
            } catch (error) {
                console.error('[AI] Box inference failed:', error);
                // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ë°•ìŠ¤ëŠ” ì €ì¥
                if (!frameAnnotations[currentFrame]) {
                    frameAnnotations[currentFrame] = [];
                }
                frameAnnotations[currentFrame].push(annotation);
                drawFrame();
                updateAnnotationList();
                updateStatistics();
            }
        }

        // í”„ë ˆì„ ê·¸ë¦¬ê¸°
        function drawFrame() {
            if (!currentFrameImage || !videoContext) {
                console.warn('[VIDEO] Cannot draw frame: image or context is null');
                return;
            }

            console.log('[VIDEO] Drawing frame', currentFrame);

            videoContext.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoContext.drawImage(currentFrameImage, 0, 0, videoCanvas.width, videoCanvas.height);

            // í˜„ì¬ í”„ë ˆì„ì˜ ì£¼ì„ ê·¸ë¦¬ê¸°
            const annotations = frameAnnotations[currentFrame] || [];
            annotations.forEach((anno, idx) => {
                const isSelected = idx === selectedAnnotationIndex;
                const className = anno.category || anno.label || 'Unknown';

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°, ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ë§Œ
                if (anno.polygon && anno.polygon.length > 0) {
                    drawPolygon(anno.polygon, anno.class_id, getDisplayLabel(anno.label), isSelected, className);
                } else {
                    drawBox(anno.box, getDisplayLabel(anno.label), isSelected, className);
                }
            });
        }

        // ì›ë³¸ í”„ë ˆì„ ìœ„ì— ëª¨ë“  ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ê·¸ë¦¬ê¸°
        async function drawFrameWithMasks() {
            if (!originalFrameImage || !videoContext) {
                console.warn('[VIDEO] Cannot draw frame with masks: image or context is null');
                drawFrame();
                return;
            }

            // ì›ë³¸ í”„ë ˆì„ ê·¸ë¦¬ê¸°
            videoContext.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoContext.drawImage(originalFrameImage, 0, 0, videoCanvas.width, videoCanvas.height);

            // ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ì˜ ë§ˆìŠ¤í¬ë¥¼ ëˆ„ì í•´ì„œ ê·¸ë¦¬ê¸°
            const annotations = frameAnnotations[currentFrame] || [];

            for (const anno of annotations) {
                if (anno.has_segmentation && anno.mask) {
                    // ë§ˆìŠ¤í¬ ì´ë¯¸ì§€ ë¡œë“œ ë° ì˜¤ë²„ë ˆì´
                    await drawMaskOverlay(anno.mask, anno.class_id, anno.box);
                }
            }

            // í´ë¦¬ê³¤ ë° ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            annotations.forEach((anno, idx) => {
                const isSelected = idx === selectedAnnotationIndex;
                const className = anno.category || anno.label || 'Unknown';

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°, ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ë§Œ
                if (anno.polygon && anno.polygon.length > 0) {
                    drawPolygon(anno.polygon, anno.class_id, getDisplayLabel(anno.label), isSelected, className);
                } else {
                    drawBox(anno.box, getDisplayLabel(anno.label), isSelected, className);
                }
            });
        }

        // ë§ˆìŠ¤í¬ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        function drawMaskOverlay(maskBase64, classId, box) {
            return new Promise((resolve, reject) => {
                const maskImg = new Image();

                maskImg.onload = function() {
                    // ì„ì‹œ Canvas ìƒì„± (ë§ˆìŠ¤í¬ ì²˜ë¦¬ìš©)
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = maskImg.width;
                    tempCanvas.height = maskImg.height;
                    const tempCtx = tempCanvas.getContext('2d');

                    // ë§ˆìŠ¤í¬ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                    tempCtx.drawImage(maskImg, 0, 0);

                    // ë§ˆìŠ¤í¬ í”½ì…€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;

                    // í´ë˜ìŠ¤ë³„ ìƒ‰ìƒ ë§¤í•‘
                    const colors = {
                        0: { r: 0, g: 0, b: 0 },       // background (í‘œì‹œ ì•ˆë¨)
                        1: { r: 255, g: 0, b: 0 },     // rust (ë¹¨ê°„ìƒ‰)
                        2: { r: 255, g: 255, b: 0 }    // scale (ë…¸ë€ìƒ‰)
                    };

                    // ë§ˆìŠ¤í¬ë¥¼ ì»¬ëŸ¬ë¡œ ë³€í™˜
                    for (let i = 0; i < data.length; i += 4) {
                        const maskValue = data[i]; // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ê°’ (í´ë˜ìŠ¤ ID ë˜ëŠ” 0/1 ë§ˆìŠ¤í¬)

                        if (maskValue > 0) {  // ë°°ê²½ì´ ì•„ë‹Œ ê²½ìš°
                            const color = colors[classId] || colors[1];
                            data[i] = color.r;
                            data[i + 1] = color.g;
                            data[i + 2] = color.b;
                            data[i + 3] = 32; // ë°˜íˆ¬ëª… (12.5% - ì›ë³¸ ì´ë¯¸ì§€ê°€ ë” ì˜ ë³´ì„)
                        } else {
                            data[i + 3] = 0; // ë°°ê²½ì€ ì™„ì „ íˆ¬ëª…
                        }
                    }

                    // ë³€í™˜ëœ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ë‹¤ì‹œ Canvasì— ì ìš©
                    tempCtx.putImageData(imageData, 0, 0);

                    // ë©”ì¸ Canvasì— ì˜¤ë²„ë ˆì´ (ë°”ìš´ë”© ë°•ìŠ¤ ìœ„ì¹˜ì— ë§ì¶°ì„œ)
                    if (box) {
                        // Cropped mask: ë°”ìš´ë”© ë°•ìŠ¤ ìœ„ì¹˜ì— ê·¸ë¦¬ê¸°
                        videoContext.drawImage(tempCanvas, box.x, box.y, box.width, box.height);
                    } else {
                        // Full frame mask: ì „ì²´ í™”ë©´ì— ê·¸ë¦¬ê¸°
                        videoContext.drawImage(tempCanvas, 0, 0, videoCanvas.width, videoCanvas.height);
                    }

                    resolve();
                };

                maskImg.onerror = function() {
                    console.error('[MASK] Failed to load mask image');
                    reject();
                };

                maskImg.src = 'data:image/png;base64,' + maskBase64;
            });
        }

        // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
        function drawPolygon(polygon, classId, label, isSelected = false, className = null) {
            if (!polygon || polygon.length < 3) {
                return;
            }

            // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
            let baseColor;
            if (className) {
                baseColor = getColorForClass(className);
            } else {
                // í•˜ìœ„ í˜¸í™˜ì„±: classIdë¡œ ìƒ‰ìƒ ê²°ì • (ë ˆê±°ì‹œ)
                const classColors = {
                    1: '#FF0000',    // rust: ë¹¨ê°•
                    2: '#FFFF00'     // scale: ë…¸ë‘
                };
                baseColor = classColors[classId] || '#00FF00';
            }

            // hexë¥¼ rgbaë¡œ ë³€í™˜
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            const colors = {
                stroke: hexToRgba(baseColor, 1),
                fill: hexToRgba(baseColor, 0.3)
            };

            const lineWidth = isSelected ? 3 : 2;

            // ë¹„ë””ì˜¤ í•´ìƒë„ ê¸°ë°˜ ìŠ¤ì¼€ì¼ ê³„ì‚° (1920x1080 ê¸°ì¤€)
            const videoWidth = videoElement.videoWidth || 1920;
            const videoHeight = videoElement.videoHeight || 1080;
            const scaleFactor = Math.sqrt((videoWidth * videoHeight) / (1920 * 1080));

            // í´ë¦¬ê³¤ ë³´ê°„ (ì  ì‚¬ì´ë¥¼ ë¶€ë“œëŸ½ê²Œ ì—°ê²°)
            const interpolatePolygon = (points, segments = Math.max(6, Math.floor(20 * scaleFactor))) => {
                const interpolated = [];
                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];

                    for (let j = 0; j < segments; j++) {
                        const t = j / segments;
                        interpolated.push({
                            x: p1.x + (p2.x - p1.x) * t,
                            y: p1.y + (p2.y - p1.y) * t
                        });
                    }
                }
                return interpolated;
            };

            // í´ë¦¬ê³¤ ë³´ê°„ ì ìš© (ë” ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
            const smoothPolygon = interpolatePolygon(polygon);

            // í´ë¦¬ê³¤ ì±„ìš°ê¸° (ë°˜íˆ¬ëª…) - ë³´ê°„ëœ í´ë¦¬ê³¤ ì‚¬ìš©
            videoContext.fillStyle = colors.fill;
            videoContext.beginPath();
            videoContext.moveTo(smoothPolygon[0].x, smoothPolygon[0].y);
            for (let i = 1; i < smoothPolygon.length; i++) {
                videoContext.lineTo(smoothPolygon[i].x, smoothPolygon[i].y);
            }
            videoContext.closePath();
            videoContext.fill();

            // í´ë¦¬ê³¤ ì™¸ê³½ì„  - ë³´ê°„ëœ í´ë¦¬ê³¤ ì‚¬ìš©
            videoContext.strokeStyle = colors.stroke;
            videoContext.lineWidth = lineWidth;
            videoContext.beginPath();
            videoContext.moveTo(smoothPolygon[0].x, smoothPolygon[0].y);
            for (let i = 1; i < smoothPolygon.length; i++) {
                videoContext.lineTo(smoothPolygon[i].x, smoothPolygon[i].y);
            }
            videoContext.closePath();
            videoContext.stroke();

            // ì„ íƒëœ ê²½ìš° ê° ì  í‘œì‹œ (ì›ë³¸ polygon í¬ì¸íŠ¸ë§Œ)
            if (isSelected) {
                polygon.forEach((point, idx) => {
                    // ë“œë˜ê·¸ ì¤‘ì¸ í¬ì¸íŠ¸ëŠ” ë” í¬ê²Œ í‘œì‹œ (í•´ìƒë„ì— ë§ì¶° ì¡°ì ˆ)
                    const baseRadius = 6 * scaleFactor;
                    const radius = (isDraggingPoint && draggingPointIndex === idx) ? baseRadius * 1.3 : baseRadius;
                    const pointLineWidth = (isDraggingPoint && draggingPointIndex === idx) ? 3 : 2;

                    videoContext.fillStyle = '#ffffff';
                    videoContext.strokeStyle = colors.stroke;
                    videoContext.lineWidth = pointLineWidth;
                    videoContext.beginPath();
                    videoContext.arc(point.x, point.y, radius, 0, Math.PI * 2);
                    videoContext.fill();
                    videoContext.stroke();

                    // í¬ì¸íŠ¸ ì¸ë±ìŠ¤ í‘œì‹œ (ë””ë²„ê¹…ìš©) - í•´ìƒë„ì— ë§ì¶° í°íŠ¸ í¬ê¸° ì¡°ì ˆ
                    if (polygon.length > 8) {  // í¬ì¸íŠ¸ê°€ ë§ìœ¼ë©´ ë²ˆí˜¸ í‘œì‹œ
                        videoContext.fillStyle = colors.stroke;
                        videoContext.font = `${Math.floor(20 * scaleFactor)}px Arial`;
                        videoContext.fillText(idx, point.x + 8 * scaleFactor, point.y - 8 * scaleFactor);
                    }
                });
            }

            // ë ˆì´ë¸” í‘œì‹œ (ì²« ë²ˆì§¸ ì  ìœ„ì—) - í•´ìƒë„ì— ë§ì¶° í¬ê¸° ì¡°ì ˆ
            const firstPoint = polygon[0];
            const labelHeight = Math.floor(40 * scaleFactor);
            const labelWidth = Math.floor(200 * scaleFactor);
            const fontSize = Math.floor(28 * scaleFactor);
            const padding = Math.floor(5 * scaleFactor);

            videoContext.fillStyle = colors.stroke;
            videoContext.fillRect(firstPoint.x, firstPoint.y - labelHeight, labelWidth, labelHeight);
            videoContext.fillStyle = '#000';
            videoContext.font = `${fontSize}px Arial`;
            videoContext.fillText(label, firstPoint.x + padding, firstPoint.y - padding * 2);
        }

        // ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
        function drawBox(box, label, isSelected = false, className = null) {
            // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
            let color;
            if (isSelected) {
                color = '#ffff00';  // ì„ íƒëœ ê²½ìš° ë…¸ë€ìƒ‰
            } else if (className) {
                color = getColorForClass(className);
            } else {
                color = '#00ff00';  // ê¸°ë³¸ ë…¹ìƒ‰
            }

            const lineWidth = isSelected ? 3 : 2;

            videoContext.strokeStyle = color;
            videoContext.lineWidth = lineWidth;
            videoContext.strokeRect(box.x, box.y, box.width, box.height);

            // ë ˆì´ë¸” í‘œì‹œ
            videoContext.fillStyle = color;
            videoContext.fillRect(box.x, box.y - 40, 200, 40);
            videoContext.fillStyle = '#000';
            videoContext.font = '28px Arial';
            videoContext.fillText(label, box.x + 5, box.y - 10);
        }

        // í”„ë ˆì„ ë¼ë²¨ ì—…ë°ì´íŠ¸
        function updateFrameLabel() {
            document.getElementById('frameLabel').textContent = `Frame: ${currentFrame} / ${totalFrames}`;
            document.getElementById('frameSlider').value = currentFrame;

            // ì¢Œì¸¡ íŒ¨ë„ì˜ í˜„ì¬ í”„ë ˆì„ ì •ë³´ë„ ì—…ë°ì´íŠ¸
            const currentFrameInfo = document.getElementById('currentFrameInfo');
            if (currentFrameInfo) {
                currentFrameInfo.textContent = currentFrame;
            }

            // ì–´ë…¸í…Œì´ì…˜ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (í˜„ì¬ í”„ë ˆì„ì˜ ì–´ë…¸í…Œì´ì…˜ í‘œì‹œ)
            updateAnnotationList();
        }

        // Play/Pause í† ê¸€
        function togglePlay() {
            if (isPlaying) {
                // Pause playback
                videoElement.pause();
                renderLoopActive = false;
                isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ Play';

                // Sync currentFrame from video time
                currentFrame = Math.floor(videoElement.currentTime * videoFPS);
                currentFrame = Math.min(currentFrame, totalFrames - 1);
                currentFrame = Math.max(currentFrame, 0);

                // Load precise frame image for annotation
                loadFrame(currentFrame);
            } else {
                // Start playback
                isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ Pause';

                // Sync video time to current frame before playing
                videoElement.currentTime = currentFrame / videoFPS;

                // Start normal playback
                videoElement.play();
                renderLoopActive = true;
                requestAnimationFrame(renderVideoToCanvas);
            }
        }


        // ì–´ë…¸í…Œì´ì…˜ íƒ­ ì¬ìƒ ì†ë„ ë³€ê²½
        function changeAnnotationPlaybackSpeed() {
            const speed = parseFloat(document.getElementById('annotationPlaybackSpeed').value);

            if (!videoElement) {
                return;
            }

            // Set video playback speed
            videoElement.playbackRate = speed;
            console.log('[VIDEO] Playback speed changed to: ' + speed + 'x');

            // If currently playing, ensure video playback is active
            if (isPlaying) {
                renderLoopActive = true;
                videoElement.play();
                requestAnimationFrame(renderVideoToCanvas);
            }
        }

        // ì´ì „ í”„ë ˆì„
        function prevFrame() {
            if (currentFrame > 0) {
                currentFrame--;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // ë‹¤ìŒ í”„ë ˆì„
        function nextFrame() {
            if (currentFrame < totalFrames - 1) {
                currentFrame++;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // 15 í”„ë ˆì„ ë’¤ë¡œ
        function skip15SecondsBackward() {
            const framesToSkip = 15;  // 15 í”„ë ˆì„
            const newFrame = Math.max(0, currentFrame - framesToSkip);

            if (newFrame !== currentFrame) {
                currentFrame = newFrame;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // 15 í”„ë ˆì„ ì•ìœ¼ë¡œ
        function skip15SecondsForward() {
            const framesToSkip = 15;  // 15 í”„ë ˆì„
            const newFrame = Math.min(totalFrames - 1, currentFrame + framesToSkip);

            if (newFrame !== currentFrame) {
                currentFrame = newFrame;
                // Sync video time
                videoElement.currentTime = currentFrame / videoFPS;
                // Update UI immediately for instant feedback
                updateFrameLabel();
                document.getElementById('frameSlider').value = currentFrame;
                // Load precise frame for annotation in background
                loadFrame(currentFrame);
            }
        }

        // ìŠ¬ë¼ì´ë” ë³€ê²½ (throttle + ë””ë°”ìš´ì‹±)
        async function onSliderChange() {
            // ìƒˆë¡œìš´ í”„ë ˆì„ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
            const targetFrame = parseInt(document.getElementById('frameSlider').value);
            currentFrame = targetFrame;

            // ë¹„ë””ì˜¤ ì‹œê°„ ì¦‰ì‹œ ë™ê¸°í™”
            const targetTime = currentFrame / videoFPS;
            videoElement.currentTime = targetTime;
            updateFrameLabel();

            // í˜„ì¬ ì‹œê°„
            const now = Date.now();

            // Throttle: 50msë§ˆë‹¤ í•œ ë²ˆì”©ë§Œ ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
            if (now - lastSliderUpdate > 50) {
                lastSliderUpdate = now;

                // requestAnimationFrameì„ ì‚¬ìš©í•˜ì—¬ ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ì¦‰ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {  // ë‘ ë²ˆ í˜¸ì¶œí•˜ì—¬ ë¹„ë””ì˜¤ê°€ í”„ë ˆì„ì„ ì—…ë°ì´íŠ¸í•  ì‹œê°„ í™•ë³´
                        const canvas = document.getElementById('videoCanvas');
                        const ctx = canvas.getContext('2d');
                        if (videoElement.readyState >= 2) {  // HAVE_CURRENT_DATA ì´ìƒ
                            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        }
                    });
                });
            }

            // ì´ì „ ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸ ì·¨ì†Œ
            if (sliderDebounceTimer) {
                clearTimeout(sliderDebounceTimer);
            }

            // ì´ì „ í”„ë ˆì„ ë¡œë“œ ìš”ì²­ ì·¨ì†Œ
            if (frameLoadAbortController) {
                frameLoadAbortController.abort();
            }

            // 200ms ë””ë°”ìš´ìŠ¤ í›„ ê³ í’ˆì§ˆ í”„ë ˆì„ ë¡œë“œ (ë“œë˜ê·¸ê°€ ë©ˆì¶˜ í›„)
            sliderDebounceTimer = setTimeout(async () => {
                // ìƒˆ AbortController ìƒì„±
                frameLoadAbortController = new AbortController();

                try {
                    // Load precise frame for annotation
                    await loadFrame(currentFrame, frameLoadAbortController.signal);
                } catch (error) {
                    // AbortErrorëŠ” loadFrameì—ì„œ ì²˜ë¦¬ë¨
                    if (error.name !== 'AbortError') {
                        console.error('[SLIDER] Error loading frame:', error);
                    }
                }
            }, 200);  // 200ms ë””ë°”ìš´ìŠ¤
        }

        // AI ìƒíƒœ í™•ì¸ (UI ì œê±°ë¨ - ë¹„í™œì„±í™”)
        async function checkAIStatus() {
            const statusDiv = document.getElementById('aiStatusText');

            // UI ìš”ì†Œê°€ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ í•¨ìˆ˜ ë¹„í™œì„±í™”
            if (!statusDiv) {
                return;
            }

            statusDiv.textContent = 'ğŸ” Checking AI status...';
            statusDiv.style.color = '#ffa500';

            try {
                // Health checkë¡œ AI ìƒíƒœ í™•ì¸
                const response = await authFetch('/api/health');
                const data = await response.json();

                if (data.status === 'ok') {
                    // GPU ì„œë²„ ì—°ê²° í™•ì¸
                    const gpuStatus = data.gpu_status;
                    if (gpuStatus && gpuStatus.status === 'ok') {
                        // AI ì´ˆê¸°í™” ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ (ì´ë¯¸ ì´ˆê¸°í™”ë˜ì–´ ìˆìœ¼ë©´ ë°”ë¡œ ë°˜í™˜)
                        const initResponse = await authFetch('/api/ai/initialize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });

                        const initData = await initResponse.json();

                        if (initData.success) {
                            aiInitialized = true;
                            statusDiv.innerHTML = 'âœ… Ready <span style="color: #666;">(' + (initData.device || 'GPU') + ')</span>';
                            statusDiv.style.color = '#00ff00';
                            console.log('[AI] Model ready:', initData.message);
                        } else {
                            statusDiv.innerHTML = 'âŒ Failed to load';
                            statusDiv.style.color = '#ff0000';
                            console.error('[AI] Initialization failed:', initData.error);
                        }
                    } else {
                        statusDiv.innerHTML = 'âš ï¸ GPU server not available';
                        statusDiv.style.color = '#ffa500';
                    }
                } else {
                    statusDiv.innerHTML = 'âŒ Backend not available';
                    statusDiv.style.color = '#ff0000';
                }
            } catch (error) {
                statusDiv.innerHTML = 'âŒ Connection error';
                statusDiv.style.color = '#ff0000';
                console.error('[AI] Status check failed:', error);
            }
        }

        async function autoRunInference() {
            // AIê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì¶”ë¡ í•˜ì§€ ì•ŠìŒ
            if (!aiInitialized) {
                return;
            }

            if (!currentProjectId || !currentVideoId || currentFrame === null) {
                return;
            }

            console.log('[AI] Auto-running inference on frame', currentFrame);

            try {
                const response = await authFetch('/api/ai/inference', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_dir: currentProject.project_dir,
                        video_id: currentVideoId,
                        frame_number: currentFrame
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[AI] Inference completed:', data.num_classes, 'classes found,', data.bounding_boxes.length, 'objects detected');

                    // Display inference result as overlay
                    const img = new Image();
                    img.onload = function() {
                        // Replace current frame with inference result (shows segmentation overlay)
                        currentFrameImage = img;
                        drawFrame();
                    };
                    img.src = 'data:image/jpeg;base64,' + data.image;

                    // Convert bounding boxes to annotations
                    if (data.bounding_boxes && data.bounding_boxes.length > 0) {
                        convertInferenceToAnnotations(data.bounding_boxes);
                    }
                } else {
                    console.error('[AI] Inference error:', data.error);
                }
            } catch (error) {
                console.error('[AI] Inference failed:', error);
            }
        }

        // AI ì¶”ë¡  ê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë³€í™˜
        // AI ì¶”ë¡  ê²°ê³¼ ë³€í™˜ í•¨ìˆ˜ (ë¹„í™œì„±í™”ë¨)
        function convertInferenceToAnnotations(boundingBoxes) {
            // ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ë¡  ê¸°ëŠ¥ ì œê±°ë¨
            console.log('[AI] convertInferenceToAnnotations is disabled');
            return;

            if (!frameAnnotations[currentFrame]) {
                frameAnnotations[currentFrame] = [];
            }

            // ê¸°ì¡´ AI ì–´ë…¸í…Œì´ì…˜ ì œê±° (ì¤‘ë³µ ë°©ì§€)
            frameAnnotations[currentFrame] = frameAnnotations[currentFrame].filter(anno =>
                !anno.label.startsWith('class_')
            );

            // ìƒˆ ì–´ë…¸í…Œì´ì…˜ ì¶”ê°€
            for (const bbox of boundingBoxes) {
                frameAnnotations[currentFrame].push({
                    box: {
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height
                    },
                    label: bbox.label,
                    class_id: bbox.class_id,
                    area: bbox.area,
                    source: 'ai'  // AIê°€ ìƒì„±í•œ ì–´ë…¸í…Œì´ì…˜ì„ì„ í‘œì‹œ
                });
            }

            updateAnnotationList();
            updateStatistics();
            console.log('[AI] Converted', boundingBoxes.length, 'bounding boxes to annotations');
        }

        // ë¹„ë””ì˜¤ ìƒíƒœì— ë”°ë¥¸ ì–´ë…¸í…Œì´ì…˜ UI ì—…ë°ì´íŠ¸
        function updateAnnotationUIForStatus() {
            const isCompleted = currentVideoStatus === 'completed';

            console.log('[VIDEO STATUS] Updating UI for status:', currentVideoStatus, 'isCompleted:', isCompleted);

            // ì™„ë£Œëœ ë¹„ë””ì˜¤ì¸ ê²½ìš° ê²½ê³  ë©”ì‹œì§€ í‘œì‹œ
            const videoDisplay = document.getElementById('currentVideoDisplay');
            if (videoDisplay) {
                const currentHTML = videoDisplay.innerHTML;
                if (isCompleted) {
                    if (!currentHTML.includes('ì™„ë£Œ')) {
                        videoDisplay.innerHTML = currentHTML + '<br><span style="background: #28a745; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; margin-top: 5px; display: inline-block;">âœ“ ì™„ë£Œ (ì½ê¸°ì „ìš©)</span>';
                    }
                } else {
                    // ì™„ë£Œ í‘œì‹œ ì œê±°
                    videoDisplay.innerHTML = currentHTML.replace(/<br><span style="background: #28a745.*?ì™„ë£Œ.*?<\/span>/g, '');
                }
            }

            // ë²„íŠ¼ ë¹„í™œì„±í™”/í™œì„±í™”
            const saveFrameBtn = document.querySelector('button[onclick="saveCurrentFrame()"]');
            const clearFrameBtn = document.querySelector('button[onclick="clearFrame()"]');
            const editBtn = document.querySelector('button[onclick="editAnnotation()"]');
            const deleteBtn = document.querySelector('button[onclick="deleteAnnotation()"]');
            const autoInferenceToggle = document.getElementById('autoInferenceToggle');
            const crosshairToggle = document.getElementById('crosshairToggle');

            if (saveFrameBtn) saveFrameBtn.disabled = isCompleted;
            if (clearFrameBtn) clearFrameBtn.disabled = isCompleted;
            if (editBtn) editBtn.disabled = isCompleted;
            if (deleteBtn) deleteBtn.disabled = isCompleted;
            if (autoInferenceToggle) {
                autoInferenceToggle.disabled = isCompleted;
                if (isCompleted) autoInferenceToggle.checked = false;
            }
            if (crosshairToggle) crosshairToggle.disabled = isCompleted;

            // ìº”ë²„ìŠ¤ ë¹„í™œì„±í™” ìŠ¤íƒ€ì¼
            const videoCanvas = document.getElementById('videoCanvas');
            if (videoCanvas) {
                if (isCompleted) {
                    videoCanvas.style.cursor = 'not-allowed';
                    videoCanvas.style.opacity = '0.8';
                } else {
                    videoCanvas.style.cursor = '';
                    videoCanvas.style.opacity = '1';
                }
            }

            console.log('[VIDEO STATUS] UI updated - buttons disabled:', isCompleted);
        }

        // ì£¼ì„ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateAnnotationList() {
            const annotationList = document.getElementById('annotationList');
            const allAnnotations = frameAnnotations[currentFrame] || [];

            // ì „ì²´ í”„ë ˆì„ ë§ˆìŠ¤í¬ëŠ” ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œì™¸
            const annotations = allAnnotations.filter(anno => !anno.is_full_frame);

            if (annotations.length === 0) {
                annotationList.innerHTML = '<div style="color: #999;">No annotations</div>';
                selectedAnnotationIndex = -1;
                return;
            }

            annotationList.innerHTML = annotations.map((anno, idx) => {
                const isSelected = idx === selectedAnnotationIndex;
                const borderColor = isSelected ? '#ffff00' : '#00ff00';
                const bgColor = isSelected ? '#3d3d00' : '#2d2d2d';

                // ì‹ ë¢°ë„ í‘œì‹œ
                let confidenceText = '';
                if (anno.confidence !== undefined) {
                    const confidencePercent = (anno.confidence * 100).toFixed(1);
                    confidenceText = '<br><small style="color: #888;">Confidence: ' + confidencePercent + '%</small>';
                }

                // ì‘ì„±ì ì •ë³´ í‘œì‹œ (ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ì— í‘œì‹œ, ìì‹ ì˜ ì–´ë…¸í…Œì´ì…˜ì€ íšŒìƒ‰ìœ¼ë¡œ)
                let authorText = '';
                const currentUser = getCurrentUser();
                if (anno.created_by_name && currentUser) {
                    const isOwnAnnotation = anno.created_by === currentUser.user_id;
                    const authorColor = isOwnAnnotation ? '#888' : '#4a9eff';
                    authorText = '<br><small style="color: ' + authorColor + ';">ğŸ‘¤ ' + anno.created_by_name + '</small>';
                }

                return '<div onclick="selectAnnotation(' + idx + ')" style="padding: 5px; margin: 3px 0; background: ' + bgColor + '; border-radius: 3px; border-left: 3px solid ' + borderColor + '; cursor: pointer;">' +
                    '<strong>' + (idx + 1) + '. ' + getDisplayLabel(anno.label) + '</strong>' + confidenceText + authorText + '<br>' +
                    '<small>Box: (' + Math.round(anno.box.x) + ', ' + Math.round(anno.box.y) + ') ' +
                    Math.round(anno.box.width) + 'x' + Math.round(anno.box.height) + '</small>' +
                '</div>';
            }).join('');
        }

        // ì–´ë…¸í…Œì´ì…˜ ì„ íƒ
        function selectAnnotation(idx) {
            selectedAnnotationIndex = idx;
            drawFrameWithMasks();
            updateAnnotationList();
            updateCommentSection();
            console.log('[ANNOTATION] Selected annotation from list:', idx);
        }

        // ì½”ë©˜íŠ¸ ì„¹ì…˜ ì—…ë°ì´íŠ¸
        function updateCommentSection() {
            const noAnnotationDiv = document.getElementById('noAnnotationSelected');
            const commentEditor = document.getElementById('commentEditor');
            const selectedAnnotationInfo = document.getElementById('selectedAnnotationInfo');
            const commentTextArea = document.getElementById('annotationCommentText');

            if (selectedAnnotationIndex === -1) {
                // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŒ
                noAnnotationDiv.style.display = 'block';
                commentEditor.style.display = 'none';
            } else {
                // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì´ ìˆìŒ
                noAnnotationDiv.style.display = 'none';
                commentEditor.style.display = 'block';

                const annotations = frameAnnotations[currentFrame] || [];
                const anno = annotations[selectedAnnotationIndex];

                if (anno) {
                    // ì–´ë…¸í…Œì´ì…˜ ì •ë³´ í‘œì‹œ
                    selectedAnnotationInfo.innerHTML = 'ğŸ“ ' + getDisplayLabel(anno.label) + ' (Annotation #' + (selectedAnnotationIndex + 1) + ')';

                    // ê¸°ì¡´ ì½”ë©˜íŠ¸ ë¡œë“œ
                    commentTextArea.value = anno.comment || '';
                }
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ ì½”ë©˜íŠ¸ ì €ì¥
        async function saveAnnotationComment() {
            if (selectedAnnotationIndex === -1) {
                alert('Please select an annotation first');
                return;
            }

            const commentTextArea = document.getElementById('annotationCommentText');
            const comment = commentTextArea.value.trim();

            const annotations = frameAnnotations[currentFrame];
            if (annotations && annotations[selectedAnnotationIndex]) {
                annotations[selectedAnnotationIndex].comment = comment;
                console.log('[COMMENT] Saved comment for annotation', selectedAnnotationIndex, ':', comment);

                // ì„±ê³µ í”¼ë“œë°±
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'ğŸ’¾ Saving...';
                btn.disabled = true;

                try {
                    // í”„ë ˆì„ì„ ì„œë²„ì— ì €ì¥ (ì½”ë©˜íŠ¸ í¬í•¨)
                    await saveCurrentFrame();

                    // ì €ì¥ ì™„ë£Œ í”¼ë“œë°±
                    btn.textContent = 'âœ“ Saved!';
                    btn.style.background = '#28a745';
                    console.log('[COMMENT] Comment saved to server successfully');
                } catch (error) {
                    // ì €ì¥ ì‹¤íŒ¨ í”¼ë“œë°±
                    btn.textContent = 'âœ— Failed';
                    btn.style.background = '#dc3545';
                    console.error('[COMMENT] Failed to save comment to server:', error);
                }

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.disabled = false;
                }, 1500);
            }
        }

        // í”„ë ˆì„-í´ë˜ìŠ¤ë³„ ì½”ë©˜íŠ¸ ì €ì¥ì†Œ
        let frameClassComments = {};

        // í˜‘ì—…ì ëª©ë¡ ì—…ë°ì´íŠ¸
        // í†µê³„ ì¹´ë“œ ìµœì†Œí™”/ìµœëŒ€í™” í† ê¸€
        function toggleStatistics() {
            const statsContent = document.getElementById('statsContent');
            const toggleBtn = document.getElementById('toggleStatsBtn');
            const statsCard = document.getElementById('statisticsCard');

            if (statsContent.style.display === 'none') {
                // ìµœëŒ€í™”
                statsContent.style.display = 'flex';
                toggleBtn.textContent = 'â–¼';
                statsCard.style.flexGrow = '1';
            } else {
                // ìµœì†Œí™”
                statsContent.style.display = 'none';
                toggleBtn.textContent = 'â–¶';
                statsCard.style.flexGrow = '0';
            }
        }

        function updateContributorsList() {
            const contributorsList = document.getElementById('contributorsList');

            if (!annotationContributors || annotationContributors.length === 0) {
                contributorsList.innerHTML = '<span style="color: #888;">ì•„ì§ í˜‘ì—…ìê°€ ì—†ìŠµë‹ˆë‹¤</span>';
                return;
            }

            contributorsList.innerHTML = annotationContributors.map(contributor => {
                const updateDate = new Date(contributor.updated_at).toLocaleDateString('ko-KR', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                return '<div style="padding: 3px 0;">' +
                    '<strong style="color: #4a9eff;">' + contributor.user_name + '</strong>' +
                    ' <span style="color: #888; font-size: 11px;">(' + updateDate + ')</span>' +
                    '</div>';
            }).join('');
        }

        // í†µê³„ ì—…ë°ì´íŠ¸ (Saveëœ ì–´ë…¸í…Œì´ì…˜ë§Œ í‘œì‹œ + í´ë˜ìŠ¤ë³„ í†µê³„)
        function updateStatistics() {
            console.log('[STATISTICS] updateStatistics() called');
            console.log('[STATISTICS] savedFrameAnnotations keys:', Object.keys(savedFrameAnnotations));

            let totalAnnotations = 0;
            let annotatedFrames = 0;

            // í´ë˜ìŠ¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const classes = currentProject?.classes || [];
            const classNames = classes.map(c => (typeof c === 'string') ? c : c.name);

            // í”„ë ˆì„ë³„ í´ë˜ìŠ¤ë³„ ì¹´ìš´íŠ¸ ì§‘ê³„
            const frameStats = {};
            for (const frame in savedFrameAnnotations) {
                const validAnnotations = savedFrameAnnotations[frame].filter(anno => !anno.is_full_frame);
                if (validAnnotations.length > 0) {
                    annotatedFrames++;
                    totalAnnotations += validAnnotations.length;

                    // í´ë˜ìŠ¤ë³„ ì¹´ìš´íŠ¸
                    const classCounts = {};
                    classNames.forEach(className => {
                        classCounts[className] = 0;
                    });

                    // ì½”ë©˜íŠ¸ê°€ ìˆëŠ” ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ”ì§€ ì²´í¬
                    const hasComment = validAnnotations.some(anno => anno.comment && anno.comment.trim().length > 0);

                    validAnnotations.forEach(anno => {
                        const label = anno.label || 'unknown';
                        if (classCounts[label] !== undefined) {
                            classCounts[label]++;
                        } else {
                            classCounts[label] = 1;
                        }
                    });

                    frameStats[frame] = {
                        total: validAnnotations.length,
                        byClass: classCounts,
                        hasComment: hasComment
                    };
                }
            }

            console.log('[STATISTICS] Total annotations:', totalAnnotations, 'Frames:', annotatedFrames);
            document.getElementById('statsInfo').textContent = 'Saved: ' + totalAnnotations + ' | Frames: ' + annotatedFrames;

            // í”„ë ˆì„ë³„ í†µê³„ í‘œì‹œ (í´ë˜ìŠ¤ë³„)
            const statsTable = document.getElementById('statsTable');
            if (annotatedFrames === 0) {
                statsTable.innerHTML = '<div style="color: #999;">No saved annotations</div>';
                return;
            }

            // í…Œì´ë¸” í—¤ë”
            let statsHTML = '<table style="width: 100%; font-size: 10px; border-collapse: collapse;">';
            statsHTML += '<tr style="background: #2d2d2d; position: sticky; top: 0; z-index: 1;">';
            statsHTML += '<th style="padding: 6px 4px; border: 1px solid #404040; min-width: 50px;">Frame</th>';

            classes.forEach((classObj, index) => {
                const className = classNames[index];  // ì‹¤ì œ ì €ì¥ëœ name (ì˜ë¬¸)
                const displayName = getClassDisplayName(classObj);  // í™”ë©´ í‘œì‹œìš©
                const shortName = displayName.length > 6 ? displayName.substring(0, 6) + '.' : displayName;
                const tooltip = currentLanguage === 'ko' ? className : (classObj.description || className);
                const classColor = getColorForClass(className);
                statsHTML += '<th style="padding: 6px 4px; border: 1px solid #404040; font-size: 9px; background: ' + classColor + '; color: #000; font-weight: bold;" title="' + tooltip + '">' + shortName + '</th>';
            });

            statsHTML += '<th style="padding: 6px 4px; border: 1px solid #404040;">Total</th>';
            statsHTML += '</tr>';

            // í…Œì´ë¸” ë°ì´í„°
            const sortedFrames = Object.keys(frameStats).sort((a, b) => parseInt(a) - parseInt(b));
            sortedFrames.forEach(frame => {
                const stats = frameStats[frame];
                const isSelected = (selectedStatsFrame !== null && parseInt(frame) === parseInt(selectedStatsFrame));
                const rowStyle = isSelected ? 'background: #4a9eff; color: #fff;' : '';

                statsHTML += '<tr style="' + rowStyle + '">';
                // Frame ë²ˆí˜¸ì— ì½”ë©˜íŠ¸ ì•„ì´ì½˜ ì¶”ê°€ (ì–´ë…¸í…Œì´ì…˜ì— ì½”ë©˜íŠ¸ê°€ ìˆëŠ” ê²½ìš°)
                const frameLabel = stats.hasComment ? frame + ' ğŸ’¬' : frame;
                const frameTitle = stats.hasComment ? 'This frame has annotation comments' : 'Click to jump to this frame';
                statsHTML += '<td style="padding: 4px; border: 1px solid #404040; cursor: pointer; font-weight: 600;" onclick="jumpToFrame(' + frame + ')" title="' + frameTitle + '">' + frameLabel + '</td>';

                classNames.forEach(className => {
                    const count = stats.byClass[className] || 0;
                    const comment = frameClassComments[frame]?.[className] || '';
                    const hasComment = comment.length > 0;
                    const classColor = getColorForClass(className);

                    // hexë¥¼ rgbaë¡œ ë³€í™˜ (ë°˜íˆ¬ëª… ë°°ê²½ìš©)
                    const hexToRgba = (hex, alpha) => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
                    };

                    const cellStyle = 'padding: 4px; border: 1px solid #404040; text-align: center; cursor: pointer;' +
                                     (count > 0 ? 'background: ' + hexToRgba(classColor, 0.3) + ';' : '') +
                                     (hasComment ? 'position: relative;' : '');
                    const cellTitle = hasComment ? 'Click to edit comment: ' + comment : 'Click to add comment';

                    statsHTML += '<td style="' + cellStyle + '" onclick="editFrameClassComment(' + frame + ', \'' + className + '\')" title="' + cellTitle + '">';
                    if (count > 0) {
                        statsHTML += '<span style="color: ' + classColor + '; font-weight: bold;">' + count + '</span>';
                    } else {
                        statsHTML += '<span style="color: #666;">-</span>';
                    }
                    if (hasComment) {
                        statsHTML += '<span style="position: absolute; top: 2px; right: 2px; font-size: 8px;">ğŸ’¬</span>';
                    }
                    statsHTML += '</td>';
                });

                statsHTML += '<td style="padding: 4px; border: 1px solid #404040; text-align: center; font-weight: 600; background: #3d3d3d;">' + stats.total + '</td>';
                statsHTML += '</tr>';
            });

            statsHTML += '</table>';
            statsTable.innerHTML = statsHTML;

            // Export ê¸°ëŠ¥ì€ Dataset íƒ­ìœ¼ë¡œ ì´ë™ë¨
        }

        // í”„ë ˆì„-í´ë˜ìŠ¤ ì½”ë©˜íŠ¸ í¸ì§‘
        function editFrameClassComment(frameNum, className) {
            const frame = frameNum.toString();
            const currentComment = frameClassComments[frame]?.[className] || '';

            const newComment = prompt(
                `Frame ${frame} - ${className}\n\nì½”ë©˜íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì·¨ì†Œí•˜ë ¤ë©´ ë¹ˆ ì¹¸):`,
                currentComment
            );

            if (newComment !== null) {
                if (!frameClassComments[frame]) {
                    frameClassComments[frame] = {};
                }

                if (newComment.trim() === '') {
                    // ë¹ˆ ë¬¸ìì—´ì´ë©´ ì½”ë©˜íŠ¸ ì‚­ì œ
                    delete frameClassComments[frame][className];
                    if (Object.keys(frameClassComments[frame]).length === 0) {
                        delete frameClassComments[frame];
                    }
                    console.log('[COMMENT] Deleted comment for frame', frame, 'class', className);
                } else {
                    frameClassComments[frame][className] = newComment.trim();
                    console.log('[COMMENT] Saved comment for frame', frame, 'class', className, ':', newComment.trim());
                }

                // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                saveFrameClassComments();

                // í†µê³„ í…Œì´ë¸” ì—…ë°ì´íŠ¸
                updateStatistics();
            }
        }

        // ì½”ë©˜íŠ¸ë¥¼ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        function saveFrameClassComments() {
            if (currentProject) {
                const key = `frameClassComments_${currentProject.id}`;
                localStorage.setItem(key, JSON.stringify(frameClassComments));
                console.log('[COMMENT] Saved to localStorage:', key);
            }
        }

        // ì½”ë©˜íŠ¸ë¥¼ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œ
        function loadFrameClassComments() {
            if (currentProject) {
                const key = `frameClassComments_${currentProject.id}`;
                const saved = localStorage.getItem(key);
                if (saved) {
                    frameClassComments = JSON.parse(saved);
                    console.log('[COMMENT] Loaded from localStorage:', key, frameClassComments);
                } else {
                    frameClassComments = {};
                }
            }
        }

        // í”„ë ˆì„ìœ¼ë¡œ ì´ë™
        async function jumpToFrame(frameNum) {
            currentFrame = parseInt(frameNum);
            selectedStatsFrame = currentFrame;  // ì„ íƒëœ í”„ë ˆì„ ê¸°ë¡
            await loadFrame(currentFrame);
            updateFrameLabel();
            updateAnnotationList();
            updateStatistics();  // í†µê³„ í…Œì´ë¸” ì—…ë°ì´íŠ¸í•˜ì—¬ í•˜ì´ë¼ì´íŠ¸ ì ìš©
        }

        // ì£¼ì„ í¸ì§‘
        function editAnnotation() {
            if (selectedAnnotationIndex === -1) {
                alert('Please select an annotation to edit');
                return;
            }

            const allAnnotations = frameAnnotations[currentFrame];
            if (!allAnnotations) {
                alert('No annotations found');
                return;
            }

            // ì „ì²´ í”„ë ˆì„ ë§ˆìŠ¤í¬ë¥¼ ì œì™¸í•œ ì–´ë…¸í…Œì´ì…˜ë“¤ (updateAnnotationListì™€ ë™ì¼í•œ í•„í„°)
            const visibleAnnotations = allAnnotations.filter(anno => !anno.is_full_frame);

            if (selectedAnnotationIndex >= visibleAnnotations.length) {
                alert('Selected annotation not found');
                selectedAnnotationIndex = -1;
                return;
            }

            const anno = visibleAnnotations[selectedAnnotationIndex];
            const newLabel = prompt('Edit label:', anno.label);

            if (newLabel && newLabel.trim() !== '') {
                anno.label = newLabel.trim();
                drawFrameWithMasks();
                updateAnnotationList();
                console.log('[ANNOTATION] Edited annotation', selectedAnnotationIndex, 'to label:', newLabel);
            }
        }

        // ì£¼ì„ ì‚­ì œ (í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ)
        async function deleteAnnotation() {
            if (selectedAnnotationIndex === -1) {
                alert('Please select an annotation to delete');
                return;
            }

            const allAnnotations = frameAnnotations[currentFrame];
            if (!allAnnotations) {
                alert('No annotations found');
                return;
            }

            // ì „ì²´ í”„ë ˆì„ ë§ˆìŠ¤í¬ë¥¼ ì œì™¸í•œ ì–´ë…¸í…Œì´ì…˜ë“¤ (updateAnnotationListì™€ ë™ì¼í•œ í•„í„°)
            const visibleAnnotations = allAnnotations.filter(anno => !anno.is_full_frame);

            if (selectedAnnotationIndex >= visibleAnnotations.length) {
                alert('Selected annotation not found');
                selectedAnnotationIndex = -1;
                return;
            }

            // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const currentUser = getCurrentUser();
            if (!currentUser) {
                alert('ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ í™•ì¸
            const selectedAnnotation = visibleAnnotations[selectedAnnotationIndex];

            // í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ì¸ì§€ í™•ì¸
            if (selectedAnnotation.created_by && selectedAnnotation.created_by !== currentUser.user_id) {
                alert('ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì‘ì„±ì: ' + (selectedAnnotation.created_by_name || selectedAnnotation.created_by));
                selectedAnnotationIndex = -1;
                return;
            }

            // ì „ì²´ ë°°ì—´ì—ì„œ í•´ë‹¹ ì–´ë…¸í…Œì´ì…˜ì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ì°¾ê¸°
            const actualIndex = allAnnotations.indexOf(selectedAnnotation);
            if (actualIndex === -1) {
                alert('ì–´ë…¸í…Œì´ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                selectedAnnotationIndex = -1;
                return;
            }

            // ì‚­ì œ ìˆ˜í–‰ (ì „ì²´ ë°°ì—´ì—ì„œ ì‚­ì œ)
            allAnnotations.splice(actualIndex, 1);

            // ë¹ˆ ë°°ì—´ì´ë©´ í”„ë ˆì„ í‚¤ ìœ ì§€ (ë¹ˆ ë°°ì—´ë¡œ ì €ì¥í•˜ì—¬ ëª…ì‹œì  ì‚­ì œ ê¸°ë¡)
            if (allAnnotations.length === 0) {
                frameAnnotations[currentFrame] = [];
            }

            selectedAnnotationIndex = -1;
            drawFrameWithMasks();
            updateAnnotationList();
            updateStatistics();
            console.log('[ANNOTATION] Deleted annotation');

            // ì„œë²„ì— ìë™ ì €ì¥
            await saveCurrentFrame();
        }

        // í”„ë ˆì„ ì´ˆê¸°í™” (í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ)
        async function clearFrame() {
            // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const currentUser = getCurrentUser();
            if (!currentUser) {
                alert('ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            const annotations = frameAnnotations[currentFrame];
            if (!annotations || annotations.length === 0) {
                console.log('[ANNOTATION] Frame already empty');
                return;
            }

            // í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ ê°œìˆ˜ í™•ì¸
            const myAnnotations = annotations.filter(ann =>
                !ann.created_by || ann.created_by === currentUser.user_id
            );
            const othersAnnotations = annotations.filter(ann =>
                ann.created_by && ann.created_by !== currentUser.user_id
            );

            if (myAnnotations.length === 0) {
                alert('í˜„ì¬ í”„ë ˆì„ì— ì‚­ì œí•  ìˆ˜ ìˆëŠ” ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.\n(ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ ìˆìŒ)');
                return;
            }

            // ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ë§Œ ë‚¨ê¸°ê¸°
            if (othersAnnotations.length > 0) {
                const confirmMsg = `í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ ${myAnnotations.length}ê°œë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.\në‹¤ë¥¸ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ ${othersAnnotations.length}ê°œëŠ” ìœ ì§€ë©ë‹ˆë‹¤.\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                if (!confirm(confirmMsg)) {
                    return;
                }
                frameAnnotations[currentFrame] = othersAnnotations;
            } else {
                // ëª¨ë‘ í˜„ì¬ ì‚¬ìš©ìì˜ ì–´ë…¸í…Œì´ì…˜ì¸ ê²½ìš°
                const confirmMsg = `í”„ë ˆì„ì˜ ëª¨ë“  ì–´ë…¸í…Œì´ì…˜(${myAnnotations.length}ê°œ)ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                if (!confirm(confirmMsg)) {
                    return;
                }
                frameAnnotations[currentFrame] = [];
            }

            drawFrameWithMasks();
            updateAnnotationList();
            updateStatistics();
            console.log(`[ANNOTATION] Cleared ${myAnnotations.length} annotation(s), kept ${othersAnnotations.length} from other users`);

            // ì„œë²„ì— ìë™ ì €ì¥
            await saveCurrentFrame();
        }

        // Annotation íƒ­ì˜ ë‚´ë³´ë‚´ê¸° í•¨ìˆ˜ë“¤ì€ Dataset íƒ­ìœ¼ë¡œ ì´ë™ë¨
        // exportVideo, exportJSON, exportFinal ê¸°ëŠ¥ì€ Dataset íƒ­ì˜ Export ë²„íŠ¼ ì‚¬ìš©

        // í˜„ì¬ í”„ë ˆì„ ì €ì¥ (Statisticsì— ë°˜ì˜ ë° ì„œë²„ì— ì¦‰ì‹œ ì €ì¥)
        async function saveCurrentFrame() {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            // ë¹ˆ í”„ë ˆì„ë„ ì €ì¥ ê°€ëŠ¥í•˜ë„ë¡ ìˆ˜ì • (ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œí•œ ê²½ìš°ë¥¼ ê¸°ë¡)
            // Deep copy current frame annotations to savedFrameAnnotations
            if (!frameAnnotations[currentFrame]) {
                frameAnnotations[currentFrame] = [];
            }
            savedFrameAnnotations[currentFrame] = JSON.parse(JSON.stringify(frameAnnotations[currentFrame]));
            console.log('[ANNOTATION] Frame', currentFrame, 'saved to Statistics');

            // Update Statistics immediately
            updateStatistics();

            // Save to server immediately
            // IMPORTANT: Only send current user's annotations to prevent overwriting other users' data
            try {
                const currentUser = getCurrentUser();
                if (!currentUser) {
                    console.error('[ANNOTATION] Cannot save: no user info');
                    return;
                }

                // Filter to only include current user's annotations
                // BUT: If an annotation has a comment added by current user, include it
                const myAnnotations = {};
                for (const [frameKey, annotations] of Object.entries(savedFrameAnnotations)) {
                    if (Array.isArray(annotations)) {
                        const myFrameAnnotations = annotations.filter(ann => {
                            // Include if created_by is not set (new annotation) or matches current user
                            const isMyAnnotation = !ann.created_by || ann.created_by === currentUser.user_id;
                            // Also include if this annotation has a comment field (even if empty - for deletion)
                            // This ensures comment deletion is also sent to server
                            const hasCommentField = 'comment' in ann;
                            return isMyAnnotation || hasCommentField;
                        });
                        myAnnotations[frameKey] = myFrameAnnotations;
                    }
                }

                console.log('[ANNOTATION] Saving only current user annotations:', Object.keys(myAnnotations).length, 'frames');

                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        annotations: myAnnotations
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[ANNOTATION] Frame', currentFrame, 'saved to server');
                    // ì €ì¥ ì„±ê³µ - alert ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬
                } else {
                    console.error('[ANNOTATION] Save failed:', data.error);
                    alert('Failed to save frame: ' + data.error);
                }
            } catch (error) {
                console.error('[ANNOTATION] Save error:', error);
                alert('Failed to save frame: ' + error.message);
            }
        }

        // ì„¸ì…˜ ì €ì¥ (savedFrameAnnotationsë¥¼ ì„œë²„ì— ì €ì¥)
        async function saveSession() {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            // Check if there are saved frames to persist
            const savedFrameCount = Object.keys(savedFrameAnnotations).length;
            if (savedFrameCount === 0) {
                alert('No saved frames to persist. Use "Save Frame" first.');
                return;
            }

            try {
                const currentUser = getCurrentUser();
                if (!currentUser) {
                    alert('ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                // Filter to only include current user's annotations
                // BUT: If an annotation has a comment added by current user, include it
                const myAnnotations = {};
                for (const [frameKey, annotations] of Object.entries(savedFrameAnnotations)) {
                    if (Array.isArray(annotations)) {
                        const myFrameAnnotations = annotations.filter(ann => {
                            // Include if created_by is not set (new annotation) or matches current user
                            const isMyAnnotation = !ann.created_by || ann.created_by === currentUser.user_id;
                            // Also include if this annotation has a comment field (even if empty - for deletion)
                            // This ensures comment deletion is also sent to server
                            const hasCommentField = 'comment' in ann;
                            return isMyAnnotation || hasCommentField;
                        });
                        myAnnotations[frameKey] = myFrameAnnotations;
                    }
                }

                const myFrameCount = Object.keys(myAnnotations).length;
                console.log('[ANNOTATION] Saving only current user annotations:', myFrameCount, 'frames');

                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        annotations: myAnnotations
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[ANNOTATION] Session saved:', data.file);
                    console.log('[ANNOTATION] Saved', myFrameCount, 'frames to server');
                    alert('Session saved! (' + myFrameCount + ' frames persisted)');
                } else {
                    console.error('[ANNOTATION] Save failed:', data.error);
                    alert('Failed to save session: ' + data.error);
                }
            } catch (error) {
                console.error('[ANNOTATION] Save error:', error);
                alert('Failed to save session: ' + error.message);
            }
        }

        // ì„¸ì…˜ ë¡œë“œ (ìˆ˜ë™)
        async function loadSession() {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations');
                const data = await response.json();

                if (data.success) {
                    // Load into savedFrameAnnotations (persisted state)
                    savedFrameAnnotations = data.annotations || {};

                    // Also copy to frameAnnotations so saved annotations are visible
                    frameAnnotations = JSON.parse(JSON.stringify(savedFrameAnnotations));

                    // ê¸°ì—¬ì ì •ë³´ ì €ì¥
                    annotationContributors = data.contributors || [];

                    selectedAnnotationIndex = -1;
                    drawFrameWithMasks();
                    updateAnnotationList();
                    updateStatistics();
                    updateContributorsList();  // ê¸°ì—¬ì ëª©ë¡ ì—…ë°ì´íŠ¸

                    console.log('[ANNOTATION] Session loaded:', Object.keys(savedFrameAnnotations).length, 'frames');
                    console.log('[ANNOTATION] Contributors:', annotationContributors.length, 'users');
                    alert('Annotations loaded successfully!');
                } else {
                    console.error('[ANNOTATION] Load failed:', data.error);
                    alert('Failed to load annotations: ' + data.error);
                }
            } catch (error) {
                console.error('[ANNOTATION] Load error:', error);
                alert('Failed to load annotations: ' + error.message);
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ ìë™ ë¡œë“œ (ë¹„ë””ì˜¤ ë¡œë“œ ì‹œ)
        async function autoLoadAnnotations() {
            if (!currentProjectId || !currentVideoId) {
                return;
            }

            try {
                const response = await authFetch('/api/projects/' + currentProjectId + '/videos/' + currentVideoId + '/annotations');
                const data = await response.json();

                if (data.success && data.annotations) {
                    // Load into savedFrameAnnotations (persisted state for Statistics)
                    savedFrameAnnotations = data.annotations;

                    // Also copy to frameAnnotations so saved annotations are visible
                    frameAnnotations = JSON.parse(JSON.stringify(data.annotations));

                    // ê¸°ì—¬ì ì •ë³´ ì €ì¥
                    annotationContributors = data.contributors || [];

                    updateAnnotationList();
                    updateStatistics();
                    updateContributorsList();  // ê¸°ì—¬ì ëª©ë¡ ì—…ë°ì´íŠ¸
                    console.log('[ANNOTATION] Auto-loaded', Object.keys(savedFrameAnnotations).length, 'saved frames from server');
                    console.log('[ANNOTATION] Contributors:', annotationContributors.length, 'users');
                }
            } catch (error) {
                console.log('[ANNOTATION] No previous annotations found (this is normal for new videos)');
            }
        }

        // ===== Dataset Tab Functions =====
        let selectedVideosForDataset = new Set();
        let datasetProjectVideos = []; // ì„ íƒ ê°€ëŠ¥í•œ ë¹„ë””ì˜¤ ëª©ë¡

        // New workflow variables - ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›
        let datasetSelectedProjects = new Set();  // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì„ íƒ
        let datasetSelectedProject = null;  // í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ (ì²« ë²ˆì§¸ í”„ë¡œì íŠ¸)
        let datasetSelectedClasses = new Set();
        let datasetSelectedVideos = new Set();
        let datasetAnnotationSummary = null;
        let datasetAllProjects = [];  // ì „ì²´ í”„ë¡œì íŠ¸ ëª©ë¡ ìºì‹œ
        let datasetProjectSummaries = {};  // í”„ë¡œì íŠ¸ë³„ ì–´ë…¸í…Œì´ì…˜ ìš”ì•½

        // Initialize dataset tab (load available projects)
        async function initializeDatasetTab() {
            await loadDatasetProjects();
        }

        // Load available projects into checkbox list
        async function loadDatasetProjects() {
            try {
                const response = await authFetch('/api/projects');
                const data = await response.json();

                const container = document.getElementById('datasetProjectList');

                if (data.success && data.projects && data.projects.length > 0) {
                    datasetAllProjects = data.projects;

                    let html = '';
                    data.projects.forEach(project => {
                        const ownerInfo = project.owner ? ` [${project.owner}]` : '';
                        const annotationCount = project.annotation_count || 0;
                        const videoCount = project.video_count || 0;

                        html += `
                            <label style="display: flex; align-items: center; gap: 8px; padding: 6px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; background: #2a2a2a;"
                                   onmouseover="this.style.background='#3a3a3a'"
                                   onmouseout="this.style.background='#2a2a2a'">
                                <input type="checkbox" value="${project.id}" onchange="onDatasetProjectToggle(this)"
                                       style="width: 16px; height: 16px; cursor: pointer;">
                                <div style="flex: 1; overflow: hidden;">
                                    <div style="font-size: 13px; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                        ${project.name}${ownerInfo}
                                    </div>
                                    <div style="font-size: 11px; color: #888;">
                                        ğŸ“¹ ${videoCount}ê°œ | ğŸ·ï¸ ${annotationCount}ê°œ
                                    </div>
                                </div>
                            </label>
                        `;
                    });

                    container.innerHTML = html;
                } else {
                    container.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                }
            } catch (error) {
                console.error('[DATASET] Failed to load projects:', error);
                document.getElementById('datasetProjectList').innerHTML =
                    '<div style="color: #ff6b6b; text-align: center; padding: 20px;">í”„ë¡œì íŠ¸ ë¡œë“œ ì‹¤íŒ¨</div>';
            }
        }

        // í”„ë¡œì íŠ¸ ì²´í¬ë°•ìŠ¤ í† ê¸€
        async function onDatasetProjectToggle(checkbox) {
            const projectId = checkbox.value;

            if (checkbox.checked) {
                datasetSelectedProjects.add(projectId);
            } else {
                datasetSelectedProjects.delete(projectId);
            }

            // ì„ íƒ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
            document.getElementById('selectedProjectCount').textContent = datasetSelectedProjects.size;

            // ì²« ë²ˆì§¸ ì„ íƒëœ í”„ë¡œì íŠ¸ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì • (í˜¸í™˜ì„±)
            datasetSelectedProject = datasetSelectedProjects.size > 0 ? [...datasetSelectedProjects][0] : null;

            // ì„ íƒëœ í”„ë¡œì íŠ¸ë“¤ì˜ ì–´ë…¸í…Œì´ì…˜ ìš”ì•½ ë¡œë“œ ë° í´ë˜ìŠ¤ ì—…ë°ì´íŠ¸
            await updateMultiProjectClasses();
        }

        // í”„ë¡œì íŠ¸ ì „ì²´ ì„ íƒ
        function selectAllProjects() {
            const checkboxes = document.querySelectorAll('#datasetProjectList input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                datasetSelectedProjects.add(cb.value);
            });
            document.getElementById('selectedProjectCount').textContent = datasetSelectedProjects.size;
            datasetSelectedProject = datasetSelectedProjects.size > 0 ? [...datasetSelectedProjects][0] : null;
            updateMultiProjectClasses();
        }

        // í”„ë¡œì íŠ¸ ì „ì²´ í•´ì œ
        function deselectAllProjects() {
            const checkboxes = document.querySelectorAll('#datasetProjectList input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
            });
            datasetSelectedProjects.clear();
            datasetSelectedProject = null;
            document.getElementById('selectedProjectCount').textContent = '0';
            datasetProjectSummaries = {};
            datasetSelectedClasses.clear();
            updateDatasetClassFilter();
            updateDatasetStats();
        }

        // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ì˜ í´ë˜ìŠ¤ ì •ë³´ ì—…ë°ì´íŠ¸
        async function updateMultiProjectClasses() {
            if (datasetSelectedProjects.size === 0) {
                datasetProjectSummaries = {};
                datasetSelectedClasses.clear();
                updateDatasetClassFilter();
                updateDatasetStats();
                return;
            }

            // ì„ íƒëœ ê° í”„ë¡œì íŠ¸ì˜ ì–´ë…¸í…Œì´ì…˜ ìš”ì•½ ë¡œë“œ
            for (const projectId of datasetSelectedProjects) {
                if (!datasetProjectSummaries[projectId]) {
                    try {
                        const response = await authFetch(`/api/projects/${encodeURIComponent(projectId)}/annotations/summary`);
                        const data = await response.json();
                        if (data.success) {
                            datasetProjectSummaries[projectId] = data.summary;
                        }
                    } catch (error) {
                        console.error(`[DATASET] Failed to load summary for ${projectId}:`, error);
                    }
                }
            }

            // ì‚­ì œëœ í”„ë¡œì íŠ¸ì˜ ìš”ì•½ ì œê±°
            Object.keys(datasetProjectSummaries).forEach(pid => {
                if (!datasetSelectedProjects.has(pid)) {
                    delete datasetProjectSummaries[pid];
                }
            });

            // í´ë˜ìŠ¤ í•„í„° ì—…ë°ì´íŠ¸
            updateDatasetClassFilter();
            updateDatasetStats();
        }

        // Project selection changed
        async function onDatasetProjectChange() {
            const selector = document.getElementById('datasetProjectSelector');
            const projectId = selector.value;

            // Reset selections
            datasetSelectedClasses.clear();
            datasetSelectedVideos.clear();
            datasetSelectedProject = null;
            datasetAnnotationSummary = null;

            if (!projectId) {
                updateDatasetClassFilter();
                updateDatasetVideosList();
                updateDatasetStats();
                return;
            }

            try {
                // Load annotation summary for this project
                const response = await authFetch(`/api/projects/${encodeURIComponent(projectId)}/annotations/summary`);
                const data = await response.json();

                if (data.success) {
                    datasetSelectedProject = projectId;
                    datasetAnnotationSummary = data.summary;

                    // Update UI components
                    updateDatasetClassFilter();
                    updateDatasetStats();
                } else {
                    alert('í”„ë¡œì íŠ¸ ì–´ë…¸í…Œì´ì…˜ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('[DATASET] Failed to load project annotations:', error);
                alert('í”„ë¡œì íŠ¸ ì •ë³´ ë¡œë”© ì‹¤íŒ¨: ' + error.message);
            }
        }

        // Update class filter checkboxes
        function updateDatasetClassFilter() {
            const container = document.getElementById('datasetClassFilter');

            // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›: ëª¨ë“  í”„ë¡œì íŠ¸ì˜ í´ë˜ìŠ¤ë¥¼ í•©ì‚°
            const mergedClasses = {};

            if (datasetSelectedProjects.size > 0) {
                // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ëª¨ë“œ
                Object.values(datasetProjectSummaries).forEach(summary => {
                    if (summary && summary.by_class) {
                        Object.entries(summary.by_class).forEach(([className, count]) => {
                            mergedClasses[className] = (mergedClasses[className] || 0) + count;
                        });
                    }
                });
            } else if (datasetAnnotationSummary && datasetAnnotationSummary.by_class) {
                // ë‹¨ì¼ í”„ë¡œì íŠ¸ ëª¨ë“œ (í•˜ìœ„ í˜¸í™˜ì„±)
                Object.assign(mergedClasses, datasetAnnotationSummary.by_class);
            }

            const classes = Object.keys(mergedClasses);

            if (classes.length === 0) {
                container.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”</div>';
                return;
            }

            // ì–´ë…¸í…Œì´ì…˜ ìˆ˜ë¡œ ì •ë ¬
            classes.sort((a, b) => mergedClasses[b] - mergedClasses[a]);

            let html = '';
            classes.forEach(className => {
                const count = mergedClasses[className];
                const isChecked = datasetSelectedClasses.has(className);

                // ì–´ë–¤ í”„ë¡œì íŠ¸ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í‘œì‹œ
                const projectsWithClass = [];
                Object.entries(datasetProjectSummaries).forEach(([pid, summary]) => {
                    if (summary && summary.by_class && summary.by_class[className]) {
                        const proj = datasetAllProjects.find(p => p.id === pid);
                        if (proj) projectsWithClass.push(proj.name);
                    }
                });
                const projectInfo = projectsWithClass.length > 1 ? ` (${projectsWithClass.length}ê°œ í”„ë¡œì íŠ¸)` : '';

                html += `
                    <label style="display: flex; align-items: center; padding: 6px; cursor: pointer; border-radius: 4px; transition: background 0.2s; background: #2a2a2a; margin-bottom: 4px;"
                           onmouseover="this.style.background='#3a3a3a'"
                           onmouseout="this.style.background='#2a2a2a'">
                        <input type="checkbox"
                               ${isChecked ? 'checked' : ''}
                               onchange="toggleDatasetClass('${className}')"
                               style="margin-right: 8px; cursor: pointer; width: 16px; height: 16px;">
                        <span style="flex: 1; color: #ccc;">${className}${projectInfo}</span>
                        <span style="color: #4a9eff; font-size: 11px; font-weight: bold;">${count.toLocaleString()}ê°œ</span>
                    </label>
                `;
            });

            container.innerHTML = html;
        }

        // Toggle class selection
        function toggleDatasetClass(className) {
            if (datasetSelectedClasses.has(className)) {
                datasetSelectedClasses.delete(className);
            } else {
                datasetSelectedClasses.add(className);
            }

            // Update video list and stats
            updateDatasetVideosList();
            updateDatasetStats();
            updateBuildSummary();
        }

        // Select all classes
        function selectAllClasses() {
            if (!datasetAnnotationSummary || !datasetAnnotationSummary.by_class) return;

            datasetSelectedClasses.clear();
            Object.keys(datasetAnnotationSummary.by_class).forEach(className => {
                datasetSelectedClasses.add(className);
            });

            updateDatasetClassFilter();
            updateDatasetVideosList();
            updateDatasetStats();
            updateBuildSummary();
        }

        // Deselect all classes
        function deselectAllClasses() {
            datasetSelectedClasses.clear();
            updateDatasetClassFilter();
            updateDatasetVideosList();
            updateDatasetStats();
            updateBuildSummary();
        }

        // Update videos list based on selected classes
        function updateDatasetVideosList() {
            const container = document.getElementById('datasetVideosList');

            if (!datasetAnnotationSummary || datasetSelectedClasses.size === 0) {
                container.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">í”„ë¡œì íŠ¸ì™€ í´ë˜ìŠ¤ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”</div>';
                return;
            }

            // Get videos that have annotations for selected classes
            const videoMap = {};
            const selectedClassArray = Array.from(datasetSelectedClasses);

            if (datasetAnnotationSummary.videos) {
                Object.keys(datasetAnnotationSummary.videos).forEach(videoId => {
                    const videoInfo = datasetAnnotationSummary.videos[videoId];
                    let hasSelectedClass = false;
                    let annotationCount = 0;

                    if (videoInfo.by_class) {
                        selectedClassArray.forEach(className => {
                            if (videoInfo.by_class[className]) {
                                hasSelectedClass = true;
                                annotationCount += videoInfo.by_class[className];
                            }
                        });
                    }

                    if (hasSelectedClass) {
                        videoMap[videoId] = {
                            id: videoId,
                            name: videoInfo.name || videoId,
                            frames: videoInfo.frames || 0,
                            annotations: annotationCount
                        };
                    }
                });
            }

            const videos = Object.values(videoMap);

            if (videos.length === 0) {
                container.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">ì„ íƒí•œ í´ë˜ìŠ¤ì˜ ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }

            let html = '';
            videos.forEach(video => {
                const isSelected = datasetSelectedVideos.has(video.id);

                html += `
                    <label style="display: flex; align-items: center; padding: 6px; cursor: pointer; border-radius: 4px; transition: background 0.2s;"
                           onmouseover="this.style.background='#333'"
                           onmouseout="this.style.background='transparent'">
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleDatasetVideo('${video.id}')"
                               style="margin-right: 8px; cursor: pointer;">
                        <span style="flex: 1; color: #ccc; font-size: 12px;">${video.name}</span>
                        <span style="color: #9b59b6; font-size: 11px; margin-left: 5px;">${video.frames}í”„ë ˆì„, ${video.annotations}ê°œ</span>
                    </label>
                `;
            });

            container.innerHTML = html;
        }

        // Toggle video selection
        function toggleDatasetVideo(videoId) {
            if (datasetSelectedVideos.has(videoId)) {
                datasetSelectedVideos.delete(videoId);
            } else {
                datasetSelectedVideos.add(videoId);
            }

            updateDatasetStats();
            updateBuildSummary();
        }

        // Update real-time statistics
        function updateDatasetStats() {
            const totalFramesEl = document.getElementById('statTotalFrames');
            const totalAnnotationsEl = document.getElementById('statTotalAnnotations');
            const totalVideosEl = document.getElementById('statTotalVideos');

            // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›
            const summariesToCheck = datasetSelectedProjects.size > 0
                ? Object.values(datasetProjectSummaries)
                : (datasetAnnotationSummary ? [datasetAnnotationSummary] : []);

            if (summariesToCheck.length === 0 || datasetSelectedClasses.size === 0) {
                totalFramesEl.textContent = '0';
                totalAnnotationsEl.textContent = '0';
                totalVideosEl.textContent = '0';
                return;
            }

            let totalFrames = 0;
            let totalAnnotations = 0;
            let videoCount = 0;

            // ê° í”„ë¡œì íŠ¸ì˜ ë¹„ë””ì˜¤ì—ì„œ ì„ íƒëœ í´ë˜ìŠ¤ í†µê³„ ê³„ì‚°
            summariesToCheck.forEach(summary => {
                const videos = summary.videos || {};
                Object.entries(videos).forEach(([videoId, videoInfo]) => {
                    let videoHasSelectedClass = false;

                    datasetSelectedClasses.forEach(className => {
                        const count = videoInfo.by_class?.[className] || 0;
                        if (count > 0) {
                            videoHasSelectedClass = true;
                            totalAnnotations += count;
                        }
                    });

                    if (videoHasSelectedClass) {
                        videoCount++;
                        totalFrames += videoInfo.frames || 0;
                    }
                });
            });

            totalFramesEl.textContent = totalFrames.toLocaleString();
            totalAnnotationsEl.textContent = totalAnnotations.toLocaleString();
            totalVideosEl.textContent = videoCount.toLocaleString();
        }

        // ë¼ë²¨ë§ ì ê²€ ë³€ìˆ˜
        let inspectorFrameData = [];
        let inspectorAllFrames = [];

        // ë¼ë²¨ë§ ì ê²€ íŒ¨ë„ ì—´ê¸°
        function openLabelingInspector() {
            // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›
            if (datasetSelectedProjects.size === 0 && !datasetSelectedProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const panel = document.getElementById('labelingInspectorPanel');
            panel.style.display = 'block';

            // ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë“œ (ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›)
            const selector = document.getElementById('inspectorVideoSelector');
            selector.innerHTML = '<option value="">-- ë¹„ë””ì˜¤ ì„ íƒ --</option>';

            const projectIds = datasetSelectedProjects.size > 0
                ? [...datasetSelectedProjects]
                : [datasetSelectedProject];

            // ê° í”„ë¡œì íŠ¸ì˜ ë¹„ë””ì˜¤ë¥¼ ê·¸ë£¹ìœ¼ë¡œ í‘œì‹œ
            projectIds.forEach(projectId => {
                const summary = datasetProjectSummaries[projectId] || datasetAnnotationSummary;
                if (!summary || !summary.videos) return;

                // í”„ë¡œì íŠ¸ ì´ë¦„ ì°¾ê¸°
                const project = datasetAllProjects.find(p => p.id === projectId);
                const projectName = project ? project.name : projectId;

                // í”„ë¡œì íŠ¸ê°€ ì—¬ëŸ¬ ê°œì¼ ê²½ìš° optgroup ì‚¬ìš©
                const isMultiProject = projectIds.length > 1;

                if (isMultiProject) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = projectName;

                    Object.entries(summary.videos).forEach(([videoId, info]) => {
                        const option = document.createElement('option');
                        option.value = `${projectId}::${videoId}`;  // projectId::videoId í˜•ì‹
                        const annotationCount = info.total_annotations || 0;
                        option.textContent = `${info.name || videoId} (${annotationCount}ê°œ)`;
                        optgroup.appendChild(option);
                    });

                    selector.appendChild(optgroup);
                } else {
                    Object.entries(summary.videos).forEach(([videoId, info]) => {
                        const option = document.createElement('option');
                        option.value = `${projectId}::${videoId}`;
                        const annotationCount = info.total_annotations || 0;
                        option.textContent = `${info.name || videoId} (${annotationCount}ê°œ ì–´ë…¸í…Œì´ì…˜)`;
                        selector.appendChild(option);
                    });
                }
            });

            // ì²« ë²ˆì§¸ ë¹„ë””ì˜¤ ìë™ ì„ íƒ
            if (selector.options.length > 1) {
                selector.selectedIndex = 1;
                loadInspectorFrames();
            }
        }

        // ë¼ë²¨ë§ ì ê²€ íŒ¨ë„ ë‹«ê¸°
        function closeLabelingInspector() {
            document.getElementById('labelingInspectorPanel').style.display = 'none';
            inspectorFrameData = [];
            inspectorAllFrames = [];
        }

        // í˜„ì¬ ë¼ë²¨ë§ ì ê²€ì—ì„œ ì„ íƒëœ í”„ë¡œì íŠ¸ (ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›)
        let currentInspectorProjectId = null;

        // í”„ë ˆì„ ë¡œë“œ (ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” í”„ë ˆì„ë§Œ)
        async function loadInspectorFrames() {
            const selectorValue = document.getElementById('inspectorVideoSelector').value;
            const grid = document.getElementById('inspectorFrameGrid');

            if (!selectorValue) {
                grid.innerHTML = '<div style="color: #999; text-align: center; padding: 40px; grid-column: 1/-1;">ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ë©´ í”„ë ˆì„ì´ í‘œì‹œë©ë‹ˆë‹¤</div>';
                return;
            }

            // projectId::videoId í˜•ì‹ íŒŒì‹±
            let projectId, videoId;
            if (selectorValue.includes('::')) {
                [projectId, videoId] = selectorValue.split('::');
            } else {
                projectId = datasetSelectedProject;
                videoId = selectorValue;
            }

            currentInspectorProjectId = projectId;

            grid.innerHTML = '<div style="color: #999; text-align: center; padding: 40px; grid-column: 1/-1;">í”„ë ˆì„ ì •ë³´ ë¡œë”© ì¤‘...</div>';

            try {
                // ì–´ë…¸í…Œì´ì…˜ ì •ë³´ ë¡œë“œ
                const response = await authFetch(`/api/projects/${encodeURIComponent(projectId)}/videos/${encodeURIComponent(videoId)}/annotations`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'ì–´ë…¸í…Œì´ì…˜ ë¡œë“œ ì‹¤íŒ¨');
                }

                // ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” í”„ë ˆì„ë§Œ ìˆ˜ì§‘
                inspectorAllFrames = [];
                const annotations = data.annotations || {};

                // í”„ë ˆì„ ë²ˆí˜¸ ê¸°ì¤€ ì •ë ¬
                const frameNumbers = Object.keys(annotations)
                    .map(k => parseInt(k))
                    .filter(k => !isNaN(k))
                    .sort((a, b) => a - b);

                // ì„ íƒëœ í´ë˜ìŠ¤ ëª©ë¡
                const selectedClassArray = Array.from(datasetSelectedClasses);

                frameNumbers.forEach(frameNumber => {
                    const frameKey = frameNumber.toString();
                    const frameAnnotations = annotations[frameKey] || [];

                    // ì„ íƒëœ í´ë˜ìŠ¤ë¡œ í•„í„°ë§ (í´ë˜ìŠ¤ê°€ ì„ íƒëœ ê²½ìš°ì—ë§Œ)
                    const filteredAnnotations = selectedClassArray.length > 0
                        ? frameAnnotations.filter(a => selectedClassArray.includes(a.label))
                        : frameAnnotations;

                    inspectorAllFrames.push({
                        frameNumber: frameNumber,
                        hasAnnotation: filteredAnnotations.length > 0,
                        annotationCount: filteredAnnotations.length,
                        totalAnnotationCount: frameAnnotations.length,
                        annotations: frameAnnotations,  // ì „ì²´ ì–´ë…¸í…Œì´ì…˜ ì €ì¥ (ëª¨ë‹¬ìš©)
                        filteredAnnotations: filteredAnnotations  // í•„í„°ë§ëœ ì–´ë…¸í…Œì´ì…˜
                    });
                });

                if (inspectorAllFrames.length === 0) {
                    grid.innerHTML = '<div style="color: #999; text-align: center; padding: 40px; grid-column: 1/-1;">ì–´ë…¸í…Œì´ì…˜ëœ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                    document.getElementById('inspectorFrameCount').textContent = '0';
                    return;
                }

                filterInspectorFrames();

            } catch (error) {
                console.error('[Inspector] Error loading frames:', error);
                grid.innerHTML = `<div style="color: #ff6b6b; text-align: center; padding: 40px; grid-column: 1/-1;">ì˜¤ë¥˜: ${error.message}</div>`;
            }
        }

        // í”„ë ˆì„ í•„í„°ë§
        function filterInspectorFrames() {
            const filter = document.querySelector('input[name="inspectorFilter"]:checked')?.value || 'all';
            const grid = document.getElementById('inspectorFrameGrid');
            const countEl = document.getElementById('inspectorFrameCount');

            let filteredFrames = inspectorAllFrames;

            if (filter === 'annotated') {
                filteredFrames = inspectorAllFrames.filter(f => f.hasAnnotation);
            } else if (filter === 'empty') {
                filteredFrames = inspectorAllFrames.filter(f => !f.hasAnnotation);
            }

            countEl.textContent = filteredFrames.length.toLocaleString();

            if (filteredFrames.length === 0) {
                grid.innerHTML = '<div style="color: #999; text-align: center; padding: 40px; grid-column: 1/-1;">í‘œì‹œí•  í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }

            // í”„ë ˆì„ ì¹´ë“œ ìƒì„± (ìµœëŒ€ 200ê°œë§Œ í‘œì‹œ)
            const displayFrames = filteredFrames.slice(0, 200);
            const selectorValue = document.getElementById('inspectorVideoSelector').value;
            // projectId::videoId í˜•ì‹ íŒŒì‹±
            const videoId = selectorValue.includes('::') ? selectorValue.split('::')[1] : selectorValue;

            grid.innerHTML = displayFrames.map(frame => {
                const borderColor = frame.hasAnnotation ? '#28a745' : '#555';
                const badge = frame.hasAnnotation
                    ? `<span style="position: absolute; top: 5px; right: 5px; background: #28a745; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">${frame.annotationCount}</span>`
                    : `<span style="position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">ì—†ìŒ</span>`;

                return `
                    <div onclick="openFrameInAnnotator(${frame.frameNumber})"
                         style="position: relative; cursor: pointer; border: 2px solid ${borderColor}; border-radius: 6px; overflow: hidden; background: #252525; transition: transform 0.2s;"
                         onmouseover="this.style.transform='scale(1.05)'"
                         onmouseout="this.style.transform='scale(1)'">
                        <img src="${API_BASE_URL}/api/projects/${encodeURIComponent(currentInspectorProjectId || datasetSelectedProject)}/videos/${encodeURIComponent(videoId)}/frame/${frame.frameNumber}?token=${encodeURIComponent(localStorage.getItem('session_id'))}"
                             style="width: 100%; height: 100px; object-fit: cover;"
                             loading="lazy"
                             onerror="this.style.display='none'">
                        ${badge}
                        <div style="padding: 5px; text-align: center; font-size: 11px; color: #aaa; background: #1e1e1e;">
                            í”„ë ˆì„ ${frame.frameNumber}
                        </div>
                    </div>
                `;
            }).join('');

            if (filteredFrames.length > 200) {
                grid.innerHTML += `<div style="color: #aaa; text-align: center; padding: 20px; grid-column: 1/-1; font-size: 12px;">+ ${filteredFrames.length - 200}ê°œ ë” ìˆìŒ (ì²˜ìŒ 200ê°œë§Œ í‘œì‹œ)</div>`;
            }
        }

        // ì–´ë…¸í…Œì´ì…˜ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ ë³€ìˆ˜
        let currentPreviewIndex = 0;
        let previewFilteredFrames = [];

        // í´ë˜ìŠ¤ë³„ ìƒ‰ìƒ
        const labelColors = {
            'crack': '#ff6b6b',
            'joint': '#4ecdc4',
            'root': '#45b7d1',
            'deposit': '#96ceb4',
            'obstacle': '#ffeaa7',
            'damage': '#dfe6e9',
            'corrosion': '#fd79a8',
            'deformation': '#a29bfe'
        };

        function getLabelColor(label) {
            if (labelColors[label]) return labelColors[label];
            // í•´ì‹œ ê¸°ë°˜ ìƒ‰ìƒ ìƒì„±
            let hash = 0;
            for (let i = 0; i < label.length; i++) {
                hash = label.charCodeAt(i) + ((hash << 5) - hash);
            }
            const hue = hash % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }

        // ì–´ë…¸í…Œì´ì…˜ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ ì—´ê¸°
        function openFrameInAnnotator(frameNumber) {
            const selectorValue = document.getElementById('inspectorVideoSelector').value;
            if (!selectorValue) return;

            // í˜„ì¬ í•„í„°ë§ëœ í”„ë ˆì„ ëª©ë¡ì—ì„œ ì¸ë±ìŠ¤ ì°¾ê¸°
            const filter = document.querySelector('input[name="inspectorFilter"]:checked')?.value || 'all';
            previewFilteredFrames = inspectorAllFrames;
            if (filter === 'annotated') {
                previewFilteredFrames = inspectorAllFrames.filter(f => f.hasAnnotation);
            } else if (filter === 'empty') {
                previewFilteredFrames = inspectorAllFrames.filter(f => !f.hasAnnotation);
            }

            currentPreviewIndex = previewFilteredFrames.findIndex(f => f.frameNumber === frameNumber);
            if (currentPreviewIndex === -1) currentPreviewIndex = 0;

            showAnnotationPreview(frameNumber);
        }

        // ì–´ë…¸í…Œì´ì…˜ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
        function showAnnotationPreview(frameNumber) {
            const selectorValue = document.getElementById('inspectorVideoSelector').value;
            // projectId::videoId í˜•ì‹ íŒŒì‹±
            const videoId = selectorValue.includes('::') ? selectorValue.split('::')[1] : selectorValue;
            const modal = document.getElementById('annotationPreviewModal');
            const baseImage = document.getElementById('previewBaseImage');
            const container = document.getElementById('previewImageContainer');
            const frameInfo = document.getElementById('previewFrameInfo');
            const annotationCountEl = document.getElementById('previewAnnotationCount');
            const legend = document.getElementById('previewLegend');

            // ê¸°ì¡´ ìº”ë²„ìŠ¤ ì œê±°
            const oldCanvas = container.querySelector('canvas');
            if (oldCanvas) oldCanvas.remove();

            // í”„ë ˆì„ ë°ì´í„° ì°¾ê¸°
            const frameData = inspectorAllFrames.find(f => f.frameNumber === frameNumber);
            if (!frameData) return;

            modal.style.display = 'flex';

            // í”„ë ˆì„ ì •ë³´ ì—…ë°ì´íŠ¸
            frameInfo.textContent = `í”„ë ˆì„ ${frameNumber}`;
            annotationCountEl.textContent = `${frameData.totalAnnotationCount || frameData.annotationCount}ê°œ ì–´ë…¸í…Œì´ì…˜`;

            // ì´ë¯¸ì§€ URL ì„¤ì • (ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›)
            const projectId = currentInspectorProjectId || datasetSelectedProject;
            const imageUrl = `${API_BASE_URL}/api/projects/${encodeURIComponent(projectId)}/videos/${encodeURIComponent(videoId)}/frame/${frameNumber}?token=${encodeURIComponent(localStorage.getItem('session_id'))}`;

            baseImage.onload = function() {
                // ì´ë¯¸ì§€ê°€ ì™„ì „íˆ ë Œë”ë§ëœ í›„ ìº”ë²„ìŠ¤ ì„¤ì •
                requestAnimationFrame(() => {
                    const displayWidth = baseImage.clientWidth;
                    const displayHeight = baseImage.clientHeight;

                    // ìƒˆ ìº”ë²„ìŠ¤ ìƒì„±
                    const canvas = document.createElement('canvas');
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    canvas.style.cssText = `position: absolute; top: 0; left: 0; width: ${displayWidth}px; height: ${displayHeight}px; pointer-events: none; z-index: 10;`;
                    container.appendChild(canvas);

                    const ctx = canvas.getContext('2d');

                    // ìŠ¤ì¼€ì¼ ê³„ì‚° (ì›ë³¸ ì´ë¯¸ì§€ ëŒ€ë¹„ í‘œì‹œ í¬ê¸°)
                    const scaleX = displayWidth / baseImage.naturalWidth;
                    const scaleY = displayHeight / baseImage.naturalHeight;

                // ì–´ë…¸í…Œì´ì…˜ ê·¸ë¦¬ê¸°
                const labelCounts = {};

                // ì  ì¢Œí‘œ ì¶”ì¶œ í•¨ìˆ˜
                const getPoint = (pt) => {
                    if (pt && typeof pt.x === 'number' && typeof pt.y === 'number') {
                        return { x: pt.x, y: pt.y };
                    } else if (Array.isArray(pt) && pt.length >= 2) {
                        return { x: pt[0], y: pt[1] };
                    }
                    return null;
                };

                // HSL ìƒ‰ìƒì„ HSLAë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
                const toTransparent = (color, alpha) => {
                    if (color.startsWith('hsl(')) {
                        return color.replace('hsl(', 'hsla(').replace(')', `, ${alpha})`);
                    }
                    // 16ì§„ìˆ˜ ìƒ‰ìƒì¸ ê²½ìš°
                    return color + Math.round(alpha * 255).toString(16).padStart(2, '0');
                };

                console.log('[Preview] Drawing annotations:', frameData.annotations.length);

                frameData.annotations.forEach((anno, idx) => {
                    const color = getLabelColor(anno.label);
                    labelCounts[anno.label] = (labelCounts[anno.label] || 0) + 1;

                    const polyPoints = anno.polygon || anno.points;
                    console.log('[Preview] Annotation', idx, ':', anno.label, 'polyPoints:', polyPoints?.length || 0);

                    if (polyPoints && polyPoints.length > 0) {
                        const firstPt = getPoint(polyPoints[0]);

                        if (firstPt) {
                            ctx.beginPath();
                            ctx.moveTo(firstPt.x * scaleX, firstPt.y * scaleY);

                            for (let i = 1; i < polyPoints.length; i++) {
                                const pt = getPoint(polyPoints[i]);
                                if (pt) {
                                    ctx.lineTo(pt.x * scaleX, pt.y * scaleY);
                                }
                            }

                            ctx.closePath();
                            ctx.fillStyle = toTransparent(color, 0.1);
                            ctx.fill();
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 3;
                            ctx.stroke();

                            // ë¼ë²¨ í…ìŠ¤íŠ¸
                            const textX = firstPt.x * scaleX;
                            const textY = firstPt.y * scaleY - 8;
                            ctx.font = 'bold 14px Arial';
                            const textWidth = ctx.measureText(anno.label).width;
                            ctx.fillStyle = color;
                            ctx.fillRect(textX - 2, textY - 16, textWidth + 4, 20);
                            ctx.fillStyle = '#fff';
                            ctx.fillText(anno.label, textX, textY);
                        }
                    } else if (anno.bbox) {
                        const [x, y, w, h] = anno.bbox;
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x * scaleX, y * scaleY, w * scaleX, h * scaleY);
                        ctx.fillStyle = toTransparent(color, 0.25);
                        ctx.fillRect(x * scaleX, y * scaleY, w * scaleX, h * scaleY);

                        ctx.fillStyle = color;
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(anno.label, x * scaleX, y * scaleY - 5);
                    }
                });

                // ë²”ë¡€ ìƒì„±
                legend.innerHTML = Object.entries(labelCounts).map(([label, count]) => {
                    const color = getLabelColor(label);
                    return `<div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 16px; height: 16px; background: ${color}; border-radius: 2px;"></div>
                        <span style="color: #ccc; font-size: 13px;">${label}: ${count}ê°œ</span>
                    </div>`;
                }).join('');

                if (Object.keys(labelCounts).length === 0) {
                    legend.innerHTML = '<span style="color: #888;">ì–´ë…¸í…Œì´ì…˜ ì—†ìŒ</span>';
                }
                }); // requestAnimationFrame ë‹«ê¸°
            };

            baseImage.onerror = function() {
                console.error('[Preview] Failed to load image');
                legend.innerHTML = '<span style="color: #ff6b6b;">ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨</span>';
            };

            baseImage.src = imageUrl;

            // ESC í‚¤ë¡œ ë‹«ê¸°
            document.addEventListener('keydown', handlePreviewKeydown);
        }

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        function handlePreviewKeydown(e) {
            if (e.key === 'Escape') {
                closeAnnotationPreview();
            } else if (e.key === 'ArrowLeft') {
                navigatePreview(-1);
            } else if (e.key === 'ArrowRight') {
                navigatePreview(1);
            }
        }

        // ë¯¸ë¦¬ë³´ê¸° ë‹«ê¸°
        function closeAnnotationPreview() {
            document.getElementById('annotationPreviewModal').style.display = 'none';
            document.removeEventListener('keydown', handlePreviewKeydown);
        }

        // ì´ì „/ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ ì´ë™
        function navigatePreview(direction) {
            if (previewFilteredFrames.length === 0) return;

            currentPreviewIndex += direction;
            if (currentPreviewIndex < 0) currentPreviewIndex = previewFilteredFrames.length - 1;
            if (currentPreviewIndex >= previewFilteredFrames.length) currentPreviewIndex = 0;

            const frame = previewFilteredFrames[currentPreviewIndex];
            showAnnotationPreview(frame.frameNumber);
        }

        async function loadVideosForDataset() {
            // Admin ëŒ€ì‹œë³´ë“œì—ì„œ ì„ íƒí•œ í”„ë¡œì íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸
            if (!window.adminSelectedProjects || window.adminSelectedProjects.length === 0) {
                document.getElementById('datasetVideosList').innerHTML =
                    '<span style="color: #999;">ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.</span>';
                return;
            }

            const videosList = document.getElementById('datasetVideosList');
            videosList.innerHTML = '<div style="text-align: center; padding: 20px;">ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë”© ì¤‘...</div>';

            try {
                datasetProjectVideos = [];

                // ê° í”„ë¡œì íŠ¸ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì™€ì„œ ë¹„ë””ì˜¤ ëª©ë¡ ìˆ˜ì§‘
                for (const project of window.adminSelectedProjects) {
                    const response = await authFetch(`/api/projects/${project.project_id}`);
                    const data = await response.json();

                    if (data.success && data.project.videos) {
                        data.project.videos.forEach(video => {
                            datasetProjectVideos.push({
                                project_id: project.project_id,
                                project_name: project.project_name,
                                user_id: project.user_id,
                                user_name: project.user_name,
                                video_id: video.video_id,
                                video_name: video.video_name || video.video_id,
                                annotations: video.annotations || 0,
                                annotated_frames: video.annotated_frames || 0,
                                status: video.status
                            });
                        });
                    }
                }

                // ë¹„ë””ì˜¤ ëª©ë¡ ë Œë”ë§
                renderDatasetVideos();

            } catch (error) {
                console.error('[DATASET] Error loading videos:', error);
                videosList.innerHTML = '<span style="color: #ff6b6b;">ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</span>';
            }
        }

        function renderDatasetVideos() {
            const videosList = document.getElementById('datasetVideosList');

            if (datasetProjectVideos.length === 0) {
                videosList.innerHTML = '<span style="color: #999;">ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</span>';
                return;
            }

            // ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ë¹„ë””ì˜¤ë§Œ í•„í„°ë§
            const videosWithAnnotations = datasetProjectVideos.filter(v => v.annotations > 0);

            if (videosWithAnnotations.length === 0) {
                videosList.innerHTML = '<span style="color: #999;">ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.</span>';
                return;
            }

            let html = '<div style="max-height: 400px; overflow-y: auto;">';

            videosWithAnnotations.forEach((video, index) => {
                const videoKey = `${video.user_id}/${video.project_id}/${video.video_id}`;
                const isSelected = selectedVideosForDataset.has(videoKey);

                html += `
                    <div style="background: ${isSelected ? '#2d4a2d' : '#1e1e1e'}; padding: 10px; margin-bottom: 8px; border-radius: 4px; border: 1px solid ${isSelected ? '#4a9' : '#404040'}; cursor: pointer;" onclick="toggleVideoSelection('${videoKey}')">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <input type="checkbox" ${isSelected ? 'checked' : ''} style="margin-right: 10px;" onchange="event.stopPropagation(); toggleVideoSelection('${videoKey}')">
                                <span style="font-weight: bold; color: #4a9eff;">${video.video_name}</span>
                                <span style="font-size: 11px; color: #999; margin-left: 10px;">(${video.project_name} - ${video.user_name})</span>
                            </div>
                            <div style="display: flex; gap: 15px; font-size: 12px;">
                                <span style="color: #ffa500;">ğŸ“Š ${video.annotations}ê°œ</span>
                                <span style="color: #9b59b6;">ğŸï¸ ${video.annotated_frames}í”„ë ˆì„</span>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            html += `
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #404040; font-size: 13px; color: #ccc;">
                    <strong>ì„ íƒëœ ë¹„ë””ì˜¤: ${selectedVideosForDataset.size}ê°œ</strong> /
                    ì „ì²´ ì–´ë…¸í…Œì´ì…˜: ${videosWithAnnotations.filter(v => selectedVideosForDataset.has(`${v.user_id}/${v.project_id}/${v.video_id}`)).reduce((sum, v) => sum + v.annotations, 0)}ê°œ
                </div>
            `;

            videosList.innerHTML = html;
        }

        function toggleVideoSelection(videoKey) {
            // í˜„ì¬ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì €ì¥
            const videosList = document.getElementById('datasetVideosList');
            const scrollPosition = videosList.scrollTop;

            if (selectedVideosForDataset.has(videoKey)) {
                selectedVideosForDataset.delete(videoKey);
            } else {
                selectedVideosForDataset.add(videoKey);
            }
            renderDatasetVideos();

            // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³µì›
            requestAnimationFrame(() => {
                videosList.scrollTop = scrollPosition;
            });
        }

        function selectAllVideos() {
            // New workflow: select all videos filtered by selected classes
            if (!datasetAnnotationSummary || !datasetAnnotationSummary.videos) {
                // Fall back to old behavior for admin dashboard compatibility
                const videosWithAnnotations = datasetProjectVideos.filter(v => v.annotations > 0);
                videosWithAnnotations.forEach(video => {
                    const videoKey = `${video.user_id}/${video.project_id}/${video.video_id}`;
                    selectedVideosForDataset.add(videoKey);
                });
                renderDatasetVideos();
                return;
            }

            // Get all videos that have selected classes
            const selectedClassArray = Array.from(datasetSelectedClasses);
            Object.keys(datasetAnnotationSummary.videos).forEach(videoId => {
                const videoInfo = datasetAnnotationSummary.videos[videoId];
                let hasSelectedClass = false;

                if (videoInfo.by_class) {
                    selectedClassArray.forEach(className => {
                        if (videoInfo.by_class[className]) {
                            hasSelectedClass = true;
                        }
                    });
                }

                if (hasSelectedClass) {
                    datasetSelectedVideos.add(videoId);
                }
            });

            updateDatasetVideosList();
            updateDatasetStats();
            updateBuildSummary();
        }

        function deselectAllVideos() {
            // New workflow: clear video selection
            if (datasetSelectedVideos) {
                datasetSelectedVideos.clear();
                updateDatasetVideosList();
                updateDatasetStats();
                updateBuildSummary();
            } else {
                // Fall back to old behavior for admin dashboard compatibility
                selectedVideosForDataset.clear();
                renderDatasetVideos();
            }
        }

        async function buildDataset() {
            // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›: í”„ë¡œì íŠ¸ ì„ íƒ í™•ì¸
            if (datasetSelectedProjects.size === 0 && !datasetSelectedProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            if (datasetSelectedClasses.size === 0) {
                alert('í´ë˜ìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const selectedClassArray = Array.from(datasetSelectedClasses);

            // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ì—ì„œ ë¹„ë””ì˜¤ ìˆ˜ì§‘
            const projectVideosMap = {};  // { projectId: [videos] }
            let totalVideoCount = 0;
            let totalAnnotationCount = 0;

            // ì„ íƒëœ ê° í”„ë¡œì íŠ¸ì—ì„œ ë¹„ë””ì˜¤ ìˆ˜ì§‘
            const projectIds = datasetSelectedProjects.size > 0
                ? [...datasetSelectedProjects]
                : [datasetSelectedProject];

            projectIds.forEach(projectId => {
                const summary = datasetProjectSummaries[projectId] || datasetAnnotationSummary;
                if (!summary || !summary.videos) return;

                projectVideosMap[projectId] = [];

                Object.entries(summary.videos).forEach(([videoId, videoInfo]) => {
                    let annotationCount = 0;
                    let hasSelectedClass = false;

                    selectedClassArray.forEach(className => {
                        const count = videoInfo.by_class?.[className] || 0;
                        if (count > 0) {
                            hasSelectedClass = true;
                            annotationCount += count;
                        }
                    });

                    if (hasSelectedClass) {
                        projectVideosMap[projectId].push({
                            video_id: videoId,
                            name: videoInfo.name || videoId,
                            annotations: annotationCount,
                            frames: videoInfo.frames || 0
                        });
                        totalVideoCount++;
                        totalAnnotationCount += annotationCount;
                    }
                });
            });

            if (totalVideoCount === 0) {
                alert('ì„ íƒí•œ í´ë˜ìŠ¤ì˜ ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ë¹„ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // ì„¤ì • ê°’ ê°€ì ¸ì˜¤ê¸°
            const outputDir = document.getElementById('datasetOutputPath').value.trim();
            const splitRatio = document.getElementById('datasetSplit').value.trim();
            const format = document.getElementById('datasetFormat').value;

            // í”„ë¡œì íŠ¸ ì´ë¦„ ëª©ë¡
            const projectNames = projectIds.map(pid => {
                const proj = datasetAllProjects.find(p => p.id === pid);
                return proj ? proj.name : pid;
            });

            if (!confirm(
                `YOLO ë°ì´í„°ì…‹ì„ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n` +
                `í”„ë¡œì íŠ¸: ${projectNames.join(', ')} (${projectIds.length}ê°œ)\n` +
                `ì„ íƒëœ í´ë˜ìŠ¤: ${selectedClassArray.join(', ')}\n` +
                `ë¹„ë””ì˜¤: ${totalVideoCount}ê°œ\n` +
                `ì´ ì–´ë…¸í…Œì´ì…˜: ${totalAnnotationCount}ê°œ\n` +
                `Train/Val/Test ë¹„ìœ¨: ${splitRatio}\n` +
                `ì¶œë ¥ ë””ë ‰í† ë¦¬: ${outputDir}`
            )) {
                return;
            }

            // ì§„í–‰ ìƒí™© ì´ˆê¸°í™”
            const progressBar = document.getElementById('datasetProgressBar');
            const progressText = document.getElementById('datasetProgressText');
            const logDiv = document.getElementById('datasetLog');
            const resultPanel = document.getElementById('datasetResultPanel');

            // ì´ì „ ê²°ê³¼ íŒ¨ë„ ìˆ¨ê¸°ê¸°
            resultPanel.style.display = 'none';

            progressBar.style.width = '0%';
            progressBar.style.background = '#4a9eff';
            progressText.textContent = 'ğŸ”„ ë¹Œë“œ ì¤€ë¹„ ì¤‘...';
            logDiv.innerHTML = '';

            function addLog(message, color = '#ccc') {
                const timestamp = new Date().toLocaleTimeString();
                logDiv.innerHTML += `<div style="color: ${color};">[${timestamp}] ${message}</div>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            addLog('ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ë°ì´í„°ì…‹ ë¹Œë“œ ì‹œì‘...', '#4a9eff');
            addLog(`í”„ë¡œì íŠ¸: ${projectNames.join(', ')} (${projectIds.length}ê°œ)`, '#4a9eff');
            addLog(`ì„ íƒëœ í´ë˜ìŠ¤: ${selectedClassArray.join(', ')}`, '#4a9eff');
            addLog(`ë¹„ë””ì˜¤: ${totalVideoCount}ê°œ`, '#4a9eff');

            // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
            progressBar.style.width = '10%';
            progressText.textContent = 'ğŸ”„ ì„œë²„ì— ìš”ì²­ ì¤‘...';

            try {
                addLog('GPU ì„œë²„ì— ë¹Œë“œ ìš”ì²­ ì „ì†¡...', '#ffa500');

                // ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ë¹Œë“œ API í˜¸ì¶œ
                const response = await authFetch('/api/dataset/build-multi', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        projects: projectVideosMap,  // { projectId: [videos] }
                        classes: selectedClassArray,
                        output_dir: outputDir,
                        split_ratio: splitRatio,
                        format: format
                    })
                });

                progressBar.style.width = '50%';
                progressText.textContent = 'ğŸ”„ ì‘ë‹µ ì²˜ë¦¬ ì¤‘...';
                addLog('ì„œë²„ ì‘ë‹µ ìˆ˜ì‹ , ì²˜ë¦¬ ì¤‘...', '#ffa500');

                const data = await response.json();

                if (data.success) {
                    progressBar.style.width = '100%';
                    progressBar.style.background = '#28a745';
                    progressText.textContent = 'âœ… ì™„ë£Œ!';
                    addLog('âœ… ë°ì´í„°ì…‹ ë¹Œë“œ ì™„ë£Œ!', '#28a745');
                    addLog(`ì¶œë ¥ ë””ë ‰í† ë¦¬: ${data.output_dir}`, '#4a9eff');
                    addLog(`ì´ ì´ë¯¸ì§€: ${data.total_images || 0}ê°œ`, '#4a9eff');
                    addLog(`Train: ${data.train_count || 0}ê°œ`, '#4a9eff');
                    addLog(`Val: ${data.val_count || 0}ê°œ`, '#4a9eff');
                    addLog(`Test: ${data.test_count || 0}ê°œ`, '#4a9eff');

                    // ê²°ê³¼ íŒ¨ë„ í‘œì‹œ
                    showDatasetResult({
                        success: true,
                        outputDir: data.output_dir,
                        totalImages: data.total_images || 0,
                        trainCount: data.train_count || 0,
                        valCount: data.val_count || 0,
                        testCount: data.test_count || 0,
                        projects: projectNames,
                        classes: selectedClassArray
                    });
                } else {
                    progressBar.style.width = '100%';
                    progressBar.style.background = '#ff6b6b';
                    progressText.textContent = 'âŒ ì‹¤íŒ¨';
                    addLog('âŒ ë¹Œë“œ ì‹¤íŒ¨: ' + data.error, '#ff6b6b');

                    // ì‹¤íŒ¨ íŒ¨ë„ í‘œì‹œ
                    showDatasetResult({
                        success: false,
                        error: data.error
                    });
                }
            } catch (error) {
                progressBar.style.width = '100%';
                progressBar.style.background = '#ff6b6b';
                progressText.textContent = 'âŒ ì˜¤ë¥˜';
                addLog('âŒ ì˜¤ë¥˜ ë°œìƒ: ' + error.message, '#ff6b6b');
                console.error('[DATASET] Build error:', error);

                // ì˜¤ë¥˜ íŒ¨ë„ í‘œì‹œ
                showDatasetResult({
                    success: false,
                    error: error.message
                });
            }
        }

        // ë°ì´í„°ì…‹ ë¹Œë“œ ê²°ê³¼ í‘œì‹œ
        function showDatasetResult(result) {
            const panel = document.getElementById('datasetResultPanel');
            const content = document.getElementById('datasetResultContent');

            if (result.success) {
                panel.style.display = 'block';
                panel.style.background = '#1a3a1a';
                panel.style.borderColor = '#28a745';
                panel.querySelector('h3').textContent = 'âœ… ë°ì´í„°ì…‹ ë¹Œë“œ ì™„ë£Œ';
                panel.querySelector('h3').style.color = '#28a745';

                content.innerHTML = `
                    <div style="background: #0d1f0d; padding: 15px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745;">${result.totalImages}</div>
                        <div style="color: #888; font-size: 12px;">ì´ ì´ë¯¸ì§€</div>
                    </div>
                    <div style="background: #0d1f0d; padding: 15px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #4a9eff;">${result.trainCount}</div>
                        <div style="color: #888; font-size: 12px;">Train</div>
                    </div>
                    <div style="background: #0d1f0d; padding: 15px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #ffa500;">${result.valCount}</div>
                        <div style="color: #888; font-size: 12px;">Validation</div>
                    </div>
                    <div style="background: #0d1f0d; padding: 15px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 28px; font-weight: bold; color: #ff6b6b;">${result.testCount}</div>
                        <div style="color: #888; font-size: 12px;">Test</div>
                    </div>
                    <div style="grid-column: 1 / -1; background: #0d1f0d; padding: 15px; border-radius: 6px;">
                        <div style="color: #888; font-size: 12px; margin-bottom: 5px;">ì¶œë ¥ ë””ë ‰í† ë¦¬</div>
                        <div style="color: #4a9eff; font-family: monospace; word-break: break-all;">${result.outputDir}</div>
                    </div>
                    <div style="grid-column: 1 / -1; background: #0d1f0d; padding: 15px; border-radius: 6px;">
                        <div style="color: #888; font-size: 12px; margin-bottom: 5px;">í”„ë¡œì íŠ¸ (${result.projects.length}ê°œ)</div>
                        <div style="color: #ccc;">${result.projects.join(', ')}</div>
                    </div>
                    <div style="grid-column: 1 / -1; background: #0d1f0d; padding: 15px; border-radius: 6px;">
                        <div style="color: #888; font-size: 12px; margin-bottom: 5px;">í´ë˜ìŠ¤ (${result.classes.length}ê°œ)</div>
                        <div style="color: #ccc;">${result.classes.join(', ')}</div>
                    </div>
                `;

                // íŒ¨ë„ë¡œ ìŠ¤í¬ë¡¤
                panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                panel.style.display = 'block';
                panel.style.background = '#3a1a1a';
                panel.style.borderColor = '#ff6b6b';
                panel.querySelector('h3').textContent = 'âŒ ë°ì´í„°ì…‹ ë¹Œë“œ ì‹¤íŒ¨';
                panel.querySelector('h3').style.color = '#ff6b6b';

                content.innerHTML = `
                    <div style="grid-column: 1 / -1; background: #1f0d0d; padding: 20px; border-radius: 6px;">
                        <div style="color: #ff6b6b; font-size: 14px;">${result.error}</div>
                    </div>
                `;

                panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        // ============================================
        // í´ë˜ìŠ¤ ê´€ë¦¬ ê¸°ëŠ¥
        // ============================================

        let classManagerMode = null;  // 'rename', 'merge', 'delete', 'preview'
        let classPreviewData = [];    // ë¯¸ë¦¬ë³´ê¸°ìš© ì–´ë…¸í…Œì´ì…˜ ë°ì´í„°

        function openClassManager(mode) {
            const selectedClasses = Array.from(datasetSelectedClasses);

            if (selectedClasses.length === 0) {
                alert('í´ë˜ìŠ¤ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            if (mode === 'merge' && selectedClasses.length < 2) {
                alert('ë³‘í•©í•˜ë ¤ë©´ 2ê°œ ì´ìƒì˜ í´ë˜ìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            classManagerMode = mode;
            const modal = document.getElementById('classManagerModal');
            const title = document.getElementById('classManagerTitle');
            const content = document.getElementById('classManagerContent');

            modal.style.display = 'flex';

            switch (mode) {
                case 'rename':
                    title.innerHTML = 'âœï¸ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½';
                    title.style.color = '#e67e22';
                    renderRenameUI(content, selectedClasses);
                    break;
                case 'merge':
                    title.innerHTML = 'ğŸ”— í´ë˜ìŠ¤ ë³‘í•©';
                    title.style.color = '#9b59b6';
                    renderMergeUI(content, selectedClasses);
                    break;
                case 'delete':
                    title.innerHTML = 'ğŸ—‘ï¸ í´ë˜ìŠ¤ ì‚­ì œ';
                    title.style.color = '#e74c3c';
                    renderDeleteUI(content, selectedClasses);
                    break;
                case 'preview':
                    title.innerHTML = 'ğŸ‘ï¸ ì–´ë…¸í…Œì´ì…˜ ë¯¸ë¦¬ë³´ê¸°';
                    title.style.color = '#3498db';
                    renderPreviewUI(content, selectedClasses);
                    break;
            }
        }

        function closeClassManager() {
            document.getElementById('classManagerModal').style.display = 'none';
            classManagerMode = null;
        }

        // ì´ë¦„ ë³€ê²½ UI
        function renderRenameUI(container, classes) {
            const projectIds = datasetSelectedProjects.size > 0
                ? [...datasetSelectedProjects]
                : (datasetSelectedProject ? [datasetSelectedProject] : []);

            container.innerHTML = `
                <div style="margin-bottom: 20px; padding: 15px; background: #1e1e1e; border-radius: 6px;">
                    <p style="color: #aaa; margin: 0 0 10px 0;">ì„ íƒëœ í´ë˜ìŠ¤ì˜ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤. ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì–´ë…¸í…Œì´ì…˜ì— ì ìš©ë©ë‹ˆë‹¤.</p>
                    <p style="color: #ffa500; margin: 0; font-size: 12px;">âš ï¸ ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
                </div>
                ${classes.map(cls => `
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 12px; padding: 12px; background: #252525; border-radius: 6px;">
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 11px; color: #888; margin-bottom: 3px;">í˜„ì¬ ì´ë¦„</label>
                            <div style="color: #4a9eff; font-weight: bold;">${cls}</div>
                        </div>
                        <div style="color: #888;">â†’</div>
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 11px; color: #888; margin-bottom: 3px;">ìƒˆ ì´ë¦„</label>
                            <input type="text" id="rename-${cls}" value="${cls}" style="width: 100%; padding: 8px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
                        </div>
                    </div>
                `).join('')}
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button onclick="executeRename()" style="flex: 1; padding: 12px; background: #e67e22; border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        âœï¸ ì´ë¦„ ë³€ê²½ ì‹¤í–‰
                    </button>
                    <button onclick="closeClassManager()" style="flex: 1; padding: 12px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer;">
                        ì·¨ì†Œ
                    </button>
                </div>
            `;
        }

        // ë³‘í•© UI
        function renderMergeUI(container, classes) {
            container.innerHTML = `
                <div style="margin-bottom: 20px; padding: 15px; background: #1e1e1e; border-radius: 6px;">
                    <p style="color: #aaa; margin: 0 0 10px 0;">ì„ íƒëœ í´ë˜ìŠ¤ë“¤ì„ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë¡œ ë³‘í•©í•©ë‹ˆë‹¤.</p>
                    <p style="color: #ffa500; margin: 0; font-size: 12px;">âš ï¸ ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 5px;">ë³‘í•©ë  í´ë˜ìŠ¤ë“¤</label>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; padding: 12px; background: #252525; border-radius: 6px;">
                        ${classes.map(cls => `
                            <span style="background: #9b59b6; color: white; padding: 5px 12px; border-radius: 15px; font-size: 12px;">${cls}</span>
                        `).join('')}
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 5px;">ë³‘í•© í›„ í´ë˜ìŠ¤ ì´ë¦„</label>
                    <input type="text" id="mergeTargetName" value="${classes[0]}" style="width: 100%; padding: 10px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px; font-size: 14px;">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="executeMerge(${JSON.stringify(classes).replace(/"/g, '&quot;')})" style="flex: 1; padding: 12px; background: #9b59b6; border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        ğŸ”— ë³‘í•© ì‹¤í–‰
                    </button>
                    <button onclick="closeClassManager()" style="flex: 1; padding: 12px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer;">
                        ì·¨ì†Œ
                    </button>
                </div>
            `;
        }

        // ì‚­ì œ UI
        function renderDeleteUI(container, classes) {
            // ê° í´ë˜ìŠ¤ë³„ ì–´ë…¸í…Œì´ì…˜ ìˆ˜ ê³„ì‚°
            const classCounts = {};
            classes.forEach(cls => {
                let count = 0;
                Object.values(datasetProjectSummaries).forEach(summary => {
                    if (summary && summary.by_class && summary.by_class[cls]) {
                        count += summary.by_class[cls];
                    }
                });
                classCounts[cls] = count;
            });

            const totalCount = Object.values(classCounts).reduce((a, b) => a + b, 0);

            container.innerHTML = `
                <div style="margin-bottom: 20px; padding: 15px; background: #3a1a1a; border: 1px solid #e74c3c; border-radius: 6px;">
                    <p style="color: #ff6b6b; margin: 0 0 10px 0; font-weight: bold;">âš ï¸ ê²½ê³ : ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!</p>
                    <p style="color: #aaa; margin: 0;">ì„ íƒëœ í´ë˜ìŠ¤ì˜ ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ì´ ì˜êµ¬ì ìœ¼ë¡œ ì‚­ì œë©ë‹ˆë‹¤.</p>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 10px;">ì‚­ì œë  í´ë˜ìŠ¤ ë° ì–´ë…¸í…Œì´ì…˜ ìˆ˜</label>
                    <div style="background: #252525; border-radius: 6px; overflow: hidden;">
                        ${classes.map(cls => `
                            <div style="display: flex; justify-content: space-between; padding: 12px 15px; border-bottom: 1px solid #333;">
                                <span style="color: #e74c3c; font-weight: bold;">${cls}</span>
                                <span style="color: #aaa;">${classCounts[cls]}ê°œ ì–´ë…¸í…Œì´ì…˜</span>
                            </div>
                        `).join('')}
                        <div style="display: flex; justify-content: space-between; padding: 12px 15px; background: #1a1a1a;">
                            <span style="color: white; font-weight: bold;">í•©ê³„</span>
                            <span style="color: #e74c3c; font-weight: bold;">${totalCount}ê°œ ì–´ë…¸í…Œì´ì…˜</span>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-size: 12px; color: #ff6b6b; margin-bottom: 5px;">í™•ì¸ì„ ìœ„í•´ "ì‚­ì œ"ë¥¼ ì…ë ¥í•˜ì„¸ìš”</label>
                    <input type="text" id="deleteConfirmInput" placeholder="ì‚­ì œ" style="width: 100%; padding: 10px; background: #1e1e1e; border: 1px solid #e74c3c; color: white; border-radius: 4px;">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="executeDelete(${JSON.stringify(classes).replace(/"/g, '&quot;')})" style="flex: 1; padding: 12px; background: #e74c3c; border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        ğŸ—‘ï¸ ì‚­ì œ ì‹¤í–‰
                    </button>
                    <button onclick="closeClassManager()" style="flex: 1; padding: 12px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer;">
                        ì·¨ì†Œ
                    </button>
                </div>
            `;
        }

        // ë¯¸ë¦¬ë³´ê¸° UI
        async function renderPreviewUI(container, classes) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #888;">
                    <div>ì–´ë…¸í…Œì´ì…˜ ë¡œë”© ì¤‘...</div>
                </div>
            `;

            try {
                const projectIds = datasetSelectedProjects.size > 0
                    ? [...datasetSelectedProjects]
                    : (datasetSelectedProject ? [datasetSelectedProject] : []);

                // ì–´ë…¸í…Œì´ì…˜ ìˆ˜ì§‘
                const annotations = [];
                for (const projectId of projectIds) {
                    const response = await authFetch(`/api/projects/${encodeURIComponent(projectId)}/annotations/by-classes`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ classes: classes, limit: 50 })
                    });
                    const data = await response.json();
                    if (data.success && data.annotations) {
                        data.annotations.forEach(ann => {
                            ann.projectId = projectId;
                        });
                        annotations.push(...data.annotations);
                    }
                }

                classPreviewData = annotations;

                if (annotations.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #888;">
                            ì„ íƒëœ í´ë˜ìŠ¤ì— ëŒ€í•œ ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.
                        </div>
                    `;
                    return;
                }

                // í´ë˜ìŠ¤ë³„ í•„í„° íƒ­
                const classFilters = classes.map(cls => {
                    const count = annotations.filter(a => a.label === cls).length;
                    return `<button onclick="filterPreviewByClass('${cls}')" class="preview-filter-btn" data-class="${cls}" style="padding: 6px 12px; background: #3498db; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">${cls} (${count})</button>`;
                }).join('');

                container.innerHTML = `
                    <div style="margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 8px;">
                        <button onclick="filterPreviewByClass('all')" class="preview-filter-btn active" data-class="all" style="padding: 6px 12px; background: #28a745; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">ì „ì²´ (${annotations.length})</button>
                        ${classFilters}
                    </div>
                    <div id="previewGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; max-height: 500px; overflow-y: auto;">
                    </div>
                `;

                renderPreviewGrid(annotations);

            } catch (error) {
                console.error('[ClassManager] Preview error:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ff6b6b;">
                        ì–´ë…¸í…Œì´ì…˜ ë¡œë”© ì‹¤íŒ¨: ${error.message}
                    </div>
                `;
            }
        }

        function filterPreviewByClass(className) {
            // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.preview-filter-btn').forEach(btn => {
                if (btn.dataset.class === className) {
                    btn.style.background = btn.dataset.class === 'all' ? '#28a745' : '#3498db';
                    btn.classList.add('active');
                } else {
                    btn.style.background = '#555';
                    btn.classList.remove('active');
                }
            });

            const filtered = className === 'all'
                ? classPreviewData
                : classPreviewData.filter(a => a.label === className);

            renderPreviewGrid(filtered);
        }

        function renderPreviewGrid(annotations) {
            const grid = document.getElementById('previewGrid');
            if (!grid) return;

            grid.innerHTML = annotations.map((ann, idx) => `
                <div style="background: #252525; border-radius: 6px; overflow: hidden;">
                    <div style="position: relative; height: 120px; background: #1a1a1a; cursor: pointer;" onclick="openAnnotationDetail(${idx})">
                        <img src="${API_BASE_URL}/api/projects/${encodeURIComponent(ann.projectId)}/videos/${encodeURIComponent(ann.videoId)}/frame/${ann.frame}?token=${encodeURIComponent(localStorage.getItem('session_id'))}"
                             style="width: 100%; height: 100%; object-fit: cover;"
                             loading="lazy"
                             onerror="this.style.display='none'">
                        <div style="position: absolute; top: 5px; left: 5px; background: ${getLabelColor(ann.label)}; color: white; padding: 2px 8px; border-radius: 10px; font-size: 10px;">${ann.label}</div>
                    </div>
                    <div style="padding: 8px; font-size: 11px; color: #aaa;">
                        <div>í”„ë ˆì„: ${ann.frame}</div>
                        <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${ann.videoId}">${ann.videoId}</div>
                        <button onclick="openAnnotationEditor(${idx})" style="width: 100%; margin-top: 6px; padding: 5px; background: #e67e22; border: none; color: white; border-radius: 3px; cursor: pointer; font-size: 11px;">
                            âœï¸ í¸ì§‘
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function openAnnotationDetail(idx) {
            const ann = classPreviewData[idx];
            if (!ann) return;

            console.log('[Preview] Opening annotation detail:', ann);
            console.log('[Preview] Polygon data:', ann.polygon);

            // ê¸°ì¡´ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ í™œìš©
            const projectId = ann.projectId;
            const videoId = ann.videoId;
            const frameNumber = ann.frame;

            // ì„ì‹œë¡œ inspectorAllFrames ì„¤ì •
            const tempFrame = {
                frameNumber: frameNumber,
                annotations: [ann],
                totalAnnotationCount: 1,
                annotationCount: 1
            };

            inspectorAllFrames = [tempFrame];
            currentInspectorProjectId = projectId;

            // ë¹„ë””ì˜¤ ì„ íƒê¸° ê°’ ì„¤ì •
            const selector = document.getElementById('inspectorVideoSelector');
            if (selector) {
                selector.value = `${projectId}::${videoId}`;
            }

            showAnnotationPreview(frameNumber);
        }

        // ì´ë¦„ ë³€ê²½ ì‹¤í–‰
        async function executeRename() {
            const selectedClasses = Array.from(datasetSelectedClasses);
            const renameMap = {};

            selectedClasses.forEach(cls => {
                const newName = document.getElementById(`rename-${cls}`)?.value.trim();
                if (newName && newName !== cls) {
                    renameMap[cls] = newName;
                }
            });

            if (Object.keys(renameMap).length === 0) {
                alert('ë³€ê²½í•  í´ë˜ìŠ¤ ì´ë¦„ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (!confirm(`${Object.keys(renameMap).length}ê°œ í´ë˜ìŠ¤ì˜ ì´ë¦„ì„ ë³€ê²½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            const projectIds = datasetSelectedProjects.size > 0
                ? [...datasetSelectedProjects]
                : (datasetSelectedProject ? [datasetSelectedProject] : []);

            try {
                const response = await authFetch('/api/annotations/rename-class', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projects: projectIds,
                        renameMap: renameMap
                    })
                });

                const data = await response.json();
                if (data.success) {
                    alert(`í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½ ì™„ë£Œ!\në³€ê²½ëœ ì–´ë…¸í…Œì´ì…˜: ${data.updatedCount}ê°œ`);
                    closeClassManager();
                    // í´ë˜ìŠ¤ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    await updateMultiProjectClasses();
                } else {
                    alert('í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[ClassManager] Rename error:', error);
                alert('í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // ë³‘í•© ì‹¤í–‰
        async function executeMerge(classes) {
            const targetName = document.getElementById('mergeTargetName')?.value.trim();
            if (!targetName) {
                alert('ë³‘í•© í›„ í´ë˜ìŠ¤ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            if (!confirm(`${classes.length}ê°œ í´ë˜ìŠ¤ë¥¼ "${targetName}"ìœ¼ë¡œ ë³‘í•©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            const projectIds = datasetSelectedProjects.size > 0
                ? [...datasetSelectedProjects]
                : (datasetSelectedProject ? [datasetSelectedProject] : []);

            try {
                const response = await authFetch('/api/annotations/merge-classes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projects: projectIds,
                        sourceClasses: classes,
                        targetClass: targetName
                    })
                });

                const data = await response.json();
                if (data.success) {
                    alert(`í´ë˜ìŠ¤ ë³‘í•© ì™„ë£Œ!\në³‘í•©ëœ ì–´ë…¸í…Œì´ì…˜: ${data.updatedCount}ê°œ`);
                    closeClassManager();
                    datasetSelectedClasses.clear();
                    await updateMultiProjectClasses();
                } else {
                    alert('í´ë˜ìŠ¤ ë³‘í•© ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[ClassManager] Merge error:', error);
                alert('í´ë˜ìŠ¤ ë³‘í•© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // ì‚­ì œ ì‹¤í–‰
        async function executeDelete(classes) {
            const confirmInput = document.getElementById('deleteConfirmInput')?.value;
            if (confirmInput !== 'ì‚­ì œ') {
                alert('"ì‚­ì œ"ë¥¼ ì •í™•íˆ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!confirm(`ì •ë§ë¡œ ${classes.length}ê°œ í´ë˜ìŠ¤ì˜ ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)) {
                return;
            }

            const projectIds = datasetSelectedProjects.size > 0
                ? [...datasetSelectedProjects]
                : (datasetSelectedProject ? [datasetSelectedProject] : []);

            try {
                const response = await authFetch('/api/annotations/delete-classes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projects: projectIds,
                        classes: classes
                    })
                });

                const data = await response.json();
                if (data.success) {
                    alert(`í´ë˜ìŠ¤ ì‚­ì œ ì™„ë£Œ!\nì‚­ì œëœ ì–´ë…¸í…Œì´ì…˜: ${data.deletedCount}ê°œ`);
                    closeClassManager();
                    datasetSelectedClasses.clear();
                    await updateMultiProjectClasses();
                } else {
                    alert('í´ë˜ìŠ¤ ì‚­ì œ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[ClassManager] Delete error:', error);
                alert('í´ë˜ìŠ¤ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        // ============================================
        // ì–´ë…¸í…Œì´ì…˜ í¸ì§‘ ê¸°ëŠ¥
        // ============================================

        let editorState = {
            projectId: null,
            videoId: null,
            frameNumber: null,
            annotations: [],        // í˜„ì¬ í”„ë ˆì„ì˜ ëª¨ë“  ì–´ë…¸í…Œì´ì…˜
            selectedIndex: -1,      // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ ì¸ë±ìŠ¤
            dragPointIndex: -1,     // ë“œë˜ê·¸ ì¤‘ì¸ ì  ì¸ë±ìŠ¤
            isDragging: false,
            image: null,
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            modified: false,
            currentPreviewIndex: 0  // í˜„ì¬ ë¯¸ë¦¬ë³´ê¸° ì¸ë±ìŠ¤
        };

        const POINT_RADIUS = 8;     // ì  í´ë¦­ ë²”ìœ„

        async function openAnnotationEditor(idx) {
            const ann = classPreviewData[idx];
            if (!ann) return;

            editorState.projectId = ann.projectId;
            editorState.videoId = ann.videoId;
            editorState.frameNumber = ann.frame;
            editorState.currentPreviewIndex = idx;
            editorState.modified = false;

            // ë¨¼ì € ëª¨ë‹¬ í‘œì‹œ (ì»¨í…Œì´ë„ˆ í¬ê¸°ë¥¼ ì–»ê¸° ìœ„í•´)
            document.getElementById('annotationEditorModal').style.display = 'flex';

            // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ì„¤ì •
            const canvas = document.getElementById('editorCanvas');
            canvas.onmousedown = onEditorMouseDown;
            canvas.onmousemove = onEditorMouseMove;
            canvas.onmouseup = onEditorMouseUp;
            canvas.onmouseleave = onEditorMouseUp;

            // ESC í‚¤ë¡œ ë‹«ê¸°
            document.addEventListener('keydown', handleEditorKeydown);

            // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ì–´ë…¸í…Œì´ì…˜ ë¡œë“œ (DOMì´ ë Œë”ë§ëœ í›„)
            await new Promise(resolve => setTimeout(resolve, 100));

            // í•´ë‹¹ í”„ë ˆì„ì˜ ëª¨ë“  ì–´ë…¸í…Œì´ì…˜ ë¡œë“œ
            await loadFrameAnnotationsForEditor();
        }

        function handleEditorKeydown(e) {
            if (e.key === 'Escape') {
                closeAnnotationEditor();
            } else if (e.key === 'Delete' && editorState.selectedIndex >= 0) {
                deleteSelectedAnnotation();
            }
        }

        async function loadFrameAnnotationsForEditor() {
            try {
                const response = await authFetch(
                    `/api/projects/${encodeURIComponent(editorState.projectId)}/videos/${encodeURIComponent(editorState.videoId)}/annotations`
                );
                const data = await response.json();

                console.log('[Editor] Annotations response:', data);

                if (data.success) {
                    const frameKey = editorState.frameNumber.toString();
                    editorState.annotations = data.annotations[frameKey] || [];
                    editorState.selectedIndex = -1;

                    console.log('[Editor] Frame', frameKey, 'annotations:', editorState.annotations);
                    console.log('[Editor] Total annotations in frame:', editorState.annotations.length);

                    // ì´ë¯¸ì§€ ë¡œë“œ ë° ìº”ë²„ìŠ¤ ë Œë”ë§
                    await loadEditorImage();
                    updateEditorAnnotationList();
                }
            } catch (error) {
                console.error('[Editor] Error loading annotations:', error);
                alert('ì–´ë…¸í…Œì´ì…˜ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
            }
        }

        async function loadEditorImage() {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    editorState.image = img;
                    resizeEditorCanvas();
                    renderEditorCanvas();
                    resolve();
                };
                img.onerror = reject;
                img.src = `${API_BASE_URL}/api/projects/${encodeURIComponent(editorState.projectId)}/videos/${encodeURIComponent(editorState.videoId)}/frame/${editorState.frameNumber}?token=${encodeURIComponent(localStorage.getItem('session_id'))}`;
            });
        }

        function resizeEditorCanvas() {
            const canvas = document.getElementById('editorCanvas');
            const container = canvas.parentElement;
            const img = editorState.image;

            if (!img) return;

            // ì»¨í…Œì´ë„ˆ í¬ê¸°ì— ë§ê²Œ ìŠ¤ì¼€ì¼ ê³„ì‚°
            const maxWidth = container.clientWidth - 40;
            const maxHeight = container.clientHeight - 40;

            console.log('[Editor] Container size:', maxWidth, 'x', maxHeight);
            console.log('[Editor] Image size:', img.naturalWidth, 'x', img.naturalHeight);

            if (maxWidth <= 0 || maxHeight <= 0) {
                console.warn('[Editor] Container has no size, using default');
                editorState.scale = 0.5;
                canvas.width = img.naturalWidth * editorState.scale;
                canvas.height = img.naturalHeight * editorState.scale;
                return;
            }

            const scaleX = maxWidth / img.naturalWidth;
            const scaleY = maxHeight / img.naturalHeight;
            editorState.scale = Math.min(scaleX, scaleY);  // ì»¨í…Œì´ë„ˆì— ë§ê²Œ ìŠ¤ì¼€ì¼

            canvas.width = img.naturalWidth * editorState.scale;
            canvas.height = img.naturalHeight * editorState.scale;

            console.log('[Editor] Scale:', editorState.scale, 'Canvas:', canvas.width, 'x', canvas.height);
        }

        function renderEditorCanvas() {
            const canvas = document.getElementById('editorCanvas');
            const ctx = canvas.getContext('2d');
            const img = editorState.image;
            const scale = editorState.scale;

            if (!img) return;

            console.log('[Editor] Rendering canvas, annotations:', editorState.annotations.length);

            // ë°°ê²½ ì´ë¯¸ì§€
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // ì–´ë…¸í…Œì´ì…˜ ê·¸ë¦¬ê¸°
            editorState.annotations.forEach((anno, idx) => {
                const isSelected = idx === editorState.selectedIndex;
                const color = getLabelColor(anno.label);
                const points = anno.polygon || [];

                console.log('[Editor] Drawing annotation', idx, ':', anno.label, 'points:', points.length);

                if (points.length < 3) {
                    console.warn('[Editor] Annotation has less than 3 points:', points);
                    return;
                }

                // í´ë¦¬ê³¤ ì±„ìš°ê¸°
                ctx.beginPath();
                const firstPt = getEditorPoint(points[0]);
                ctx.moveTo(firstPt.x * scale, firstPt.y * scale);

                for (let i = 1; i < points.length; i++) {
                    const pt = getEditorPoint(points[i]);
                    ctx.lineTo(pt.x * scale, pt.y * scale);
                }
                ctx.closePath();

                // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì€ ë” ì§„í•˜ê²Œ
                ctx.fillStyle = isSelected ? color.replace(')', ', 0.4)').replace('hsl', 'hsla') : color.replace(')', ', 0.2)').replace('hsl', 'hsla');
                ctx.fill();

                // ì™¸ê³½ì„ 
                ctx.strokeStyle = isSelected ? '#fff' : color;
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.stroke();

                // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì˜ ì  ê·¸ë¦¬ê¸°
                if (isSelected) {
                    points.forEach((point, ptIdx) => {
                        const pt = getEditorPoint(point);
                        const x = pt.x * scale;
                        const y = pt.y * scale;

                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                        ctx.fillStyle = ptIdx === editorState.dragPointIndex ? '#ff0' : '#fff';
                        ctx.fill();
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                }

                // ë¼ë²¨ í‘œì‹œ
                const labelPt = getEditorPoint(points[0]);
                ctx.font = 'bold 12px Arial';
                const textWidth = ctx.measureText(anno.label).width;
                ctx.fillStyle = color;
                ctx.fillRect(labelPt.x * scale - 2, labelPt.y * scale - 18, textWidth + 8, 18);
                ctx.fillStyle = '#fff';
                ctx.fillText(anno.label, labelPt.x * scale + 2, labelPt.y * scale - 5);
            });

            // í”„ë ˆì„ ì •ë³´ ì—…ë°ì´íŠ¸
            document.getElementById('editorFrameInfo').textContent =
                `í”„ë ˆì„ ${editorState.frameNumber} | ${editorState.annotations.length}ê°œ ì–´ë…¸í…Œì´ì…˜${editorState.modified ? ' (ìˆ˜ì •ë¨)' : ''}`;
        }

        function getEditorPoint(pt) {
            if (pt && typeof pt.x === 'number' && typeof pt.y === 'number') {
                return { x: pt.x, y: pt.y };
            } else if (Array.isArray(pt) && pt.length >= 2) {
                return { x: pt[0], y: pt[1] };
            }
            return { x: 0, y: 0 };
        }

        function setEditorPoint(anno, ptIdx, x, y) {
            const points = anno.polygon;
            if (!points || ptIdx >= points.length) return;

            if (typeof points[ptIdx].x === 'number') {
                points[ptIdx].x = x;
                points[ptIdx].y = y;
            } else if (Array.isArray(points[ptIdx])) {
                points[ptIdx][0] = x;
                points[ptIdx][1] = y;
            }
        }

        function updateEditorAnnotationList() {
            const listDiv = document.getElementById('editorAnnotationList');
            const deleteBtn = document.getElementById('deleteAnnotationBtn');

            listDiv.innerHTML = editorState.annotations.map((anno, idx) => {
                const isSelected = idx === editorState.selectedIndex;
                const color = getLabelColor(anno.label);
                const pointCount = (anno.polygon || []).length;

                return `
                    <div onclick="selectEditorAnnotation(${idx})"
                         style="padding: 10px; background: ${isSelected ? '#3a3a3a' : '#252525'}; border: 2px solid ${isSelected ? color : 'transparent'};
                                border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 12px; height: 12px; background: ${color}; border-radius: 2px;"></div>
                            <span style="color: #fff; font-weight: ${isSelected ? 'bold' : 'normal'};">${anno.label}</span>
                        </div>
                        <div style="font-size: 10px; color: #888; margin-top: 4px;">${pointCount}ê°œ ì </div>
                    </div>
                `;
            }).join('');

            // ì‚­ì œ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
            deleteBtn.style.display = editorState.selectedIndex >= 0 ? 'block' : 'none';
        }

        function selectEditorAnnotation(idx) {
            editorState.selectedIndex = idx;
            updateEditorAnnotationList();
            renderEditorCanvas();
        }

        function onEditorMouseDown(e) {
            const canvas = document.getElementById('editorCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / editorState.scale;
            const y = (e.clientY - rect.top) / editorState.scale;

            // ì„ íƒëœ ì–´ë…¸í…Œì´ì…˜ì˜ ì  í´ë¦­ í™•ì¸
            if (editorState.selectedIndex >= 0) {
                const anno = editorState.annotations[editorState.selectedIndex];
                const points = anno.polygon || [];

                for (let i = 0; i < points.length; i++) {
                    const pt = getEditorPoint(points[i]);
                    const dist = Math.sqrt((pt.x - x) ** 2 + (pt.y - y) ** 2);

                    if (dist < POINT_RADIUS / editorState.scale) {
                        editorState.dragPointIndex = i;
                        editorState.isDragging = true;
                        canvas.style.cursor = 'grabbing';
                        return;
                    }
                }
            }

            // ì–´ë…¸í…Œì´ì…˜ í´ë¦­ í™•ì¸
            for (let i = editorState.annotations.length - 1; i >= 0; i--) {
                if (isPointInPolygon(x, y, editorState.annotations[i].polygon || [])) {
                    selectEditorAnnotation(i);
                    return;
                }
            }

            // ë¹ˆ ê³µê°„ í´ë¦­ - ì„ íƒ í•´ì œ
            editorState.selectedIndex = -1;
            updateEditorAnnotationList();
            renderEditorCanvas();
        }

        function onEditorMouseMove(e) {
            if (!editorState.isDragging || editorState.dragPointIndex < 0) return;

            const canvas = document.getElementById('editorCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / editorState.scale;
            const y = (e.clientY - rect.top) / editorState.scale;

            // ì´ë¯¸ì§€ ë²”ìœ„ ë‚´ë¡œ ì œí•œ
            const clampedX = Math.max(0, Math.min(editorState.image.naturalWidth, x));
            const clampedY = Math.max(0, Math.min(editorState.image.naturalHeight, y));

            const anno = editorState.annotations[editorState.selectedIndex];
            setEditorPoint(anno, editorState.dragPointIndex, clampedX, clampedY);

            editorState.modified = true;
            renderEditorCanvas();
        }

        function onEditorMouseUp(e) {
            if (editorState.isDragging) {
                editorState.isDragging = false;
                editorState.dragPointIndex = -1;
                document.getElementById('editorCanvas').style.cursor = 'crosshair';
            }
        }

        function isPointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;

            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const pi = getEditorPoint(polygon[i]);
                const pj = getEditorPoint(polygon[j]);

                if (((pi.y > y) !== (pj.y > y)) &&
                    (x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function deleteSelectedAnnotation() {
            if (editorState.selectedIndex < 0) return;

            const anno = editorState.annotations[editorState.selectedIndex];
            if (!confirm(`"${anno.label}" ì–´ë…¸í…Œì´ì…˜ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;

            editorState.annotations.splice(editorState.selectedIndex, 1);
            editorState.selectedIndex = -1;
            editorState.modified = true;

            updateEditorAnnotationList();
            renderEditorCanvas();
        }

        async function saveAnnotationEdit() {
            if (!editorState.modified) {
                alert('ë³€ê²½ëœ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                const response = await authFetch(
                    `/api/projects/${encodeURIComponent(editorState.projectId)}/videos/${encodeURIComponent(editorState.videoId)}/annotations/${editorState.frameNumber}`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            annotations: editorState.annotations
                        })
                    }
                );

                const data = await response.json();
                if (data.success) {
                    alert('ì–´ë…¸í…Œì´ì…˜ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    editorState.modified = false;
                    renderEditorCanvas();

                    // í´ë˜ìŠ¤ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì–´ë…¸í…Œì´ì…˜ ìˆ˜ê°€ ë°”ë€” ìˆ˜ ìˆìŒ)
                    await updateMultiProjectClasses();
                } else {
                    alert('ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[Editor] Save error:', error);
                alert('ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        function editorPrevFrame() {
            if (editorState.modified) {
                if (!confirm('ì €ì¥í•˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
            }

            // ê°™ì€ ë¹„ë””ì˜¤ì˜ ì´ì „ í”„ë ˆì„ ì°¾ê¸°
            const currentIdx = editorState.currentPreviewIndex;
            for (let i = currentIdx - 1; i >= 0; i--) {
                const ann = classPreviewData[i];
                if (ann && ann.projectId === editorState.projectId && ann.videoId === editorState.videoId) {
                    openAnnotationEditor(i);
                    return;
                }
            }
            alert('ì´ì „ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤.');
        }

        function editorNextFrame() {
            if (editorState.modified) {
                if (!confirm('ì €ì¥í•˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
            }

            // ê°™ì€ ë¹„ë””ì˜¤ì˜ ë‹¤ìŒ í”„ë ˆì„ ì°¾ê¸°
            const currentIdx = editorState.currentPreviewIndex;
            for (let i = currentIdx + 1; i < classPreviewData.length; i++) {
                const ann = classPreviewData[i];
                if (ann && ann.projectId === editorState.projectId && ann.videoId === editorState.videoId) {
                    openAnnotationEditor(i);
                    return;
                }
            }
            alert('ë‹¤ìŒ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤.');
        }

        function closeAnnotationEditor() {
            if (editorState.modified) {
                if (!confirm('ì €ì¥í•˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ë‹«ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
            }

            document.getElementById('annotationEditorModal').style.display = 'none';
            document.removeEventListener('keydown', handleEditorKeydown);

            // ìƒíƒœ ì´ˆê¸°í™”
            editorState.projectId = null;
            editorState.videoId = null;
            editorState.frameNumber = null;
            editorState.annotations = [];
            editorState.selectedIndex = -1;
            editorState.modified = false;
        }

        async function exportYOLO() {
            await exportDataset('yolo');
        }

        async function exportSegFormer() {
            await exportDataset('segformer');
        }

        async function exportDataset(format) {
            if (!currentProjectId || !currentVideoId) {
                alert('No project or video selected');
                return;
            }

            if (Object.keys(frameAnnotations).length === 0) {
                alert('No annotations to export');
                return;
            }

            // ì‚¬ìš©ì ì¶”ê°€ ì–´ë…¸í…Œì´ì…˜ ê°œìˆ˜ í™•ì¸
            let userAnnotationCount = 0;
            for (const frame in frameAnnotations) {
                const userAnnotations = frameAnnotations[frame].filter(anno => !anno.auto_detected);
                userAnnotationCount += userAnnotations.length;
            }

            if (userAnnotationCount === 0) {
                alert('No user annotations to export. Please add manual annotations before exporting.');
                return;
            }

            const formatName = format === 'yolo' ? 'YOLO Segmentation' : 'SegFormer';
            if (!confirm(`Export dataset in ${formatName} format?\n\nFrames with annotations: ${Object.keys(frameAnnotations).length}\nUser annotations: ${userAnnotationCount}`)) {
                return;
            }

            try {
                console.log(`[EXPORT] Exporting ${formatName} dataset...`);

                const response = await fetch(API_BASE_URL + '/api/export/dataset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project_id: currentProjectId,
                        video_id: currentVideoId,
                        annotations: frameAnnotations,
                        format: format,
                        output_dir: 'datasets'
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[EXPORT] Dataset exported successfully:', data);
                    alert(`${formatName} dataset exported successfully!\n\nFrames: ${data.frames_exported}\nLocation: ${data.output_dir}\n\nFormat:\n` +
                        (format === 'segformer' ? '- images/ (frames)\n- masks/ (segmentation masks)\n- dataset_info.json' :
                                                  '- images/ (frames)\n- labels/ (polygon annotations)\n- dataset_info.json'));
                } else {
                    console.error('[EXPORT] Export failed:', data.error);
                    alert('Failed to export dataset: ' + data.error);
                }
            } catch (error) {
                console.error('[EXPORT] Export error:', error);
                alert('Failed to export dataset: ' + error.message);
            }
        }

        // ===== Training Tab Functions =====
        function browseDataset() {
            alert('ë°ì´í„°ì…‹ ì„ íƒ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function startTraining() {
            alert('í•™ìŠµ ì‹œì‘ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        function stopTraining() {
            alert('í•™ìŠµ ì¤‘ì§€ ê¸°ëŠ¥ì€ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        // ===== Inference Tab Functions =====
        let inferenceProjectList = [];
        let inferenceVideoList = [];
        let lastInferenceJobId = null;
        let lastInferenceResults = null;

        // ì¶”ë¡  íƒ­ ì´ˆê¸°í™”
        async function initInferenceTab() {
            try {
                // í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
                const response = await authFetch('/api/projects');
                const data = await response.json();

                if (data.success !== false) {
                    inferenceProjectList = Array.isArray(data) ? data : (data.projects || []);
                    const select = document.getElementById('inferenceProjectSelect');
                    select.innerHTML = '<option value="">-- í”„ë¡œì íŠ¸ ì„ íƒ --</option>';

                    inferenceProjectList.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.id;
                        option.textContent = project.name || project.id;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('[INFERENCE] Failed to load projects:', error);
            }
        }

        // í”„ë¡œì íŠ¸ ì„ íƒ ì‹œ ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë“œ
        async function loadInferenceVideos() {
            const projectId = document.getElementById('inferenceProjectSelect').value;
            const videoSelect = document.getElementById('inferenceVideoSelect');
            videoSelect.innerHTML = '<option value="">-- ë¹„ë””ì˜¤ ì„ íƒ --</option>';

            if (!projectId) return;

            try {
                // í”„ë¡œì íŠ¸ ìƒì„¸ ì •ë³´ì—ì„œ ë¹„ë””ì˜¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const response = await authFetch(`/api/projects/${encodeURIComponent(projectId)}`);
                const data = await response.json();

                if (data.success !== false) {
                    // API ì‘ë‹µ êµ¬ì¡°: { success, project: { videos: [...] } }
                    const projectData = data.project || data;
                    inferenceVideoList = projectData.videos || [];
                    console.log('[INFERENCE] Loaded videos:', inferenceVideoList.length, 'videos');

                    inferenceVideoList.forEach(video => {
                        const option = document.createElement('option');
                        const videoId = video.video_id || video.id;
                        const videoPath = video.video_path || video.path || '';

                        // ì˜ë¯¸ ìˆëŠ” ë¹„ë””ì˜¤ ì´ë¦„ ìƒì„±
                        let videoName = '';
                        const meta = video.nas_metadata;
                        if (meta && meta.dir_metadata) {
                            // ì˜ˆ: [373-ì§€ë°©-100MM-PE] 20240402_1ì§€ì  ìˆœë°©í–¥ ì „ì§„.avi
                            const dirInfo = meta.parent_dir || '';
                            const filename = video.filename || '';
                            videoName = dirInfo ? `[${dirInfo}] ${filename}` : filename;
                        } else if (video.filename) {
                            videoName = video.filename;
                        } else {
                            videoName = video.name || videoId;
                        }

                        option.value = videoPath;
                        option.textContent = videoName;
                        option.dataset.videoId = videoId;
                        videoSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('[INFERENCE] Failed to load videos:', error);
            }
        }

        // ë¹„ë””ì˜¤ ì„ íƒ ì‹œ ê²½ë¡œ ì„¤ì •
        function onInferenceVideoSelected() {
            const videoSelect = document.getElementById('inferenceVideoSelect');
            const selectedOption = videoSelect.options[videoSelect.selectedIndex];
            const videoPath = videoSelect.value;

            document.getElementById('inferenceVideoPath').value = videoPath;

            // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìë™ ì„¤ì •
            if (videoPath) {
                const projectId = document.getElementById('inferenceProjectSelect').value;
                const videoId = selectedOption.dataset.videoId || 'inference';
                document.getElementById('inferenceOutputPath').value = `inference_results/${projectId}/${videoId}`;
            }
        }

        // ëª¨ë¸ íƒ€ì… ë³€ê²½ ì‹œ
        function onModelTypeChanged() {
            const modelType = document.getElementById('inferenceModelType').value;
            const modelPathInput = document.getElementById('inferenceModelPath');

            // ê¸°ë³¸ ëª¨ë¸ ê²½ë¡œ ì œì•ˆ
            if (modelType === 'yolo') {
                modelPathInput.placeholder = 'YOLO ëª¨ë¸ ê²½ë¡œ (ì˜ˆ: best.pt, yolov8n.pt)';
            } else if (modelType === 'segformer') {
                modelPathInput.placeholder = 'SegFormer ëª¨ë¸ ê²½ë¡œ (ì˜ˆ: segformer_best.pth)';
            } else {
                modelPathInput.placeholder = 'ëª¨ë¸ ê²½ë¡œ';
            }
        }

        // íŒŒì¼ ë¸Œë¼ìš°ì € ìƒíƒœ
        let fileBrowserCallback = null;
        let fileBrowserFilter = '';

        function browseInferenceModel() {
            const modelType = document.getElementById('inferenceModelType').value;
            let filter = '.pt,.pth';
            if (modelType === 'yolo') {
                filter = '.pt';
            } else if (modelType === 'segformer') {
                filter = '.pth';
            }
            openFileBrowser('.models', filter, (selectedPath) => {
                document.getElementById('inferenceModelPath').value = selectedPath;
            });
        }

        function browseInferenceVideo() {
            alert('ìœ„ì˜ í”„ë¡œì íŠ¸/ë¹„ë””ì˜¤ ì„ íƒì„ ì‚¬ìš©í•˜ê±°ë‚˜ ì§ì ‘ ê²½ë¡œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
        }

        // íŒŒì¼ ë¸Œë¼ìš°ì € ì—´ê¸°
        function openFileBrowser(initialPath, filter, callback) {
            fileBrowserCallback = callback;
            fileBrowserFilter = filter;
            document.getElementById('fileBrowserSelected').value = '';
            document.getElementById('fileBrowserModal').style.display = 'flex';
            loadFileBrowserDirectory(initialPath);
        }

        // íŒŒì¼ ë¸Œë¼ìš°ì € ë‹«ê¸°
        function closeFileBrowser() {
            document.getElementById('fileBrowserModal').style.display = 'none';
            fileBrowserCallback = null;
        }

        // ë””ë ‰í† ë¦¬ ë‚´ìš© ë¡œë“œ
        async function loadFileBrowserDirectory(path) {
            const listDiv = document.getElementById('fileBrowserList');
            listDiv.innerHTML = '<div style="padding: 20px; color: #666; text-align: center;">ë¡œë”© ì¤‘...</div>';

            try {
                const params = new URLSearchParams();
                if (path) params.append('path', path);
                if (fileBrowserFilter) params.append('filter', fileBrowserFilter);

                const response = await authFetch(`/api/files/browse?${params.toString()}`);
                const data = await response.json();

                if (!data.success) {
                    listDiv.innerHTML = `<div style="padding: 20px; color: #ff6b6b; text-align: center;">ì˜¤ë¥˜: ${data.error}</div>`;
                    return;
                }

                document.getElementById('fileBrowserCurrentPath').textContent = data.current_path;

                if (data.items.length === 0) {
                    listDiv.innerHTML = '<div style="padding: 20px; color: #666; text-align: center;">íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    return;
                }

                listDiv.innerHTML = data.items.map(item => {
                    const icon = item.type === 'directory' ? 'ğŸ“' : 'ğŸ“„';
                    const sizeInfo = item.size ? `<span style="color: #666; font-size: 11px; margin-left: 10px;">${item.size}</span>` : '';
                    const bgColor = item.type === 'directory' ? '#2a2a2a' : '#252525';

                    return `
                        <div onclick="onFileBrowserItemClick('${item.path.replace(/'/g, "\\'")}', '${item.type}')"
                             style="padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #333; display: flex; align-items: center; background: ${bgColor};"
                             onmouseover="this.style.background='#3a3a3a'"
                             onmouseout="this.style.background='${bgColor}'">
                            <span style="margin-right: 10px;">${icon}</span>
                            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.name}</span>
                            ${sizeInfo}
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('[FILE BROWSER] Error:', error);
                listDiv.innerHTML = `<div style="padding: 20px; color: #ff6b6b; text-align: center;">ì˜¤ë¥˜: ${error.message}</div>`;
            }
        }

        // íŒŒì¼/í´ë” í´ë¦­ ì²˜ë¦¬
        function onFileBrowserItemClick(path, type) {
            if (type === 'directory') {
                loadFileBrowserDirectory(path);
            } else {
                document.getElementById('fileBrowserSelected').value = path;
            }
        }

        // íŒŒì¼ ì„ íƒ í™•ì¸
        function confirmFileSelection() {
            const selectedPath = document.getElementById('fileBrowserSelected').value;
            if (!selectedPath) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            if (fileBrowserCallback) {
                fileBrowserCallback(selectedPath);
            }
            closeFileBrowser();
        }

        async function startInference() {
            const modelType = document.getElementById('inferenceModelType').value;
            let modelPath = document.getElementById('inferenceModelPath').value.trim();
            const videoPath = document.getElementById('inferenceVideoPath').value.trim();
            const outputPath = document.getElementById('inferenceOutputPath').value.trim();
            const confidence = parseFloat(document.getElementById('inferenceConfidence').value) || 0.5;

            // ë¹„ë””ì˜¤ ê²½ë¡œ í™•ì¸
            if (!videoPath) {
                alert('ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            // ëª¨ë¸ ê²½ë¡œê°€ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš°
            if (!modelPath) {
                if (modelType === 'yolo') {
                    // ê¸°ë³¸ YOLO ëª¨ë¸ ì‚¬ìš©
                    modelPath = 'yolov8n.pt';
                } else if (modelType === 'segformer') {
                    const projectId = document.getElementById('inferenceProjectSelect').value;
                    if (projectId) {
                        modelPath = `projects/${projectId}/segformer_best.pth`;
                    } else {
                        alert('SegFormer ëª¨ë¸ ê²½ë¡œë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”.');
                        return;
                    }
                } else {
                    alert('ëª¨ë¸ íŒŒì¼ì„ ì§€ì •í•´ì£¼ì„¸ìš”.');
                    return;
                }
            }

            // ê¸°ì¡´ ì¶”ë¡  ê²°ê³¼ í™•ì¸
            try {
                const checkResponse = await authFetch('/api/inference/check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        video_path: videoPath,
                        output_path: outputPath
                    })
                });

                const checkData = await checkResponse.json();

                if (checkData.success && checkData.exists) {
                    // ì´ë¯¸ ì¶”ë¡  ê²°ê³¼ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°
                    const frameInfo = `\n\ní”„ë ˆì„ ìˆ˜: ${checkData.frame_count}\nFPS: ${checkData.fps}`;
                    const choice = confirm(
                        'ì´ë¯¸ ì¶”ë¡  ê²°ê³¼ê°€ ì¡´ì¬í•©ë‹ˆë‹¤!' + frameInfo +
                        '\n\n[í™•ì¸] - ê¸°ì¡´ ê²°ê³¼ ë³´ê¸°\n[ì·¨ì†Œ] - ì¬ì‹¤í–‰'
                    );

                    if (choice) {
                        // ê¸°ì¡´ ê²°ê³¼ ë³´ê¸°
                        viewInferenceResults(checkData);
                        return;
                    }
                    // ì·¨ì†Œë¥¼ ì„ íƒí•˜ë©´ ê³„ì† ì§„í–‰í•˜ì—¬ ì¬ì‹¤í–‰
                }
            } catch (error) {
                console.error('[INFERENCE] Check error:', error);
                // í™•ì¸ ì‹¤íŒ¨ ì‹œ ê·¸ëƒ¥ ê³„ì† ì§„í–‰
            }

            try {
                document.getElementById('startInferenceBtn').disabled = true;
                document.getElementById('inferenceProgressText').textContent = 'ì¶”ë¡  ì‹œì‘ ì¤‘...';
                // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ íŒ¨ë„ ìˆ¨ê¸°ê¸° (ìƒˆ ì¶”ë¡  ì‹œì‘ ì‹œ)
                document.getElementById('representativeFramePanel').style.display = 'none';

                const response = await authFetch('/api/inference', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_type: modelType,
                        model_path: modelPath,
                        video_path: videoPath,
                        output_path: outputPath
                    })
                });

                const data = await response.json();

                if (data.success && data.job_id) {
                    // ì‘ì—… ID ì €ì¥
                    currentJobId = data.job_id;

                    // ì·¨ì†Œ ë²„íŠ¼ í‘œì‹œ
                    const cancelBtn = document.getElementById('cancelInferenceBtn');
                    if (cancelBtn) {
                        cancelBtn.style.display = 'inline-block';
                        cancelBtn.disabled = false;
                    }

                    // ì§„í–‰ ìƒí™© ì²´í¬ ì‹œì‘
                    document.getElementById('inferenceProgressText').textContent = 'ì¶”ë¡  ì§„í–‰ ì¤‘... 0%';
                    startProgressPolling();

                    // ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ì‹œì‘
                    startPreviewPlayer();
                } else {
                    alert('ì¶”ë¡  ì‹œì‘ ì‹¤íŒ¨: ' + data.error);
                    document.getElementById('inferenceProgressText').textContent = 'ì¶”ë¡  ì‹¤íŒ¨';
                    document.getElementById('startInferenceBtn').disabled = false;
                }
            } catch (error) {
                console.error('[INFERENCE] Error:', error);
                alert('ì¶”ë¡  ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                document.getElementById('inferenceProgressText').textContent = 'ì˜¤ë¥˜ ë°œìƒ';
                document.getElementById('startInferenceBtn').disabled = false;
            }
        }

        // ì§„í–‰ ìƒí™© í´ë§ ì‹œì‘
        function startProgressPolling() {
            if (progressInterval) {
                clearInterval(progressInterval);
            }

            progressInterval = setInterval(async () => {
                if (!currentJobId) {
                    clearInterval(progressInterval);
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/api/inference/status/${currentJobId}`);
                    const data = await response.json();

                    if (data.success) {
                        const progress = data.progress || 0;
                        const currentFrame = data.current_frame || 0;
                        const totalFrames = data.total_frames || 0;
                        const status = data.status;

                        // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                        document.getElementById('inferenceProgressText').textContent =
                            `ì¶”ë¡  ì§„í–‰ ì¤‘... ${progress.toFixed(1)}% (${currentFrame}/${totalFrames} í”„ë ˆì„)`;
                        document.getElementById('inferenceProgressBar').style.width = `${progress}%`;

                        // ë¯¸ë¦¬ë³´ê¸° ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
                        const previewStatus = document.getElementById('inferencePreviewStatus');
                        if (previewStatus) {
                            previewStatus.textContent = `í”„ë ˆì„: ${currentFrame} / ${totalFrames}`;
                        }

                        // ì™„ë£Œ ë˜ëŠ” ì·¨ì†Œë¨
                        if (status === 'completed') {
                            clearInterval(progressInterval);
                            stopPreviewPlayer();
                            document.getElementById('inferenceProgressText').textContent = `ì¶”ë¡  ì™„ë£Œ! (${totalFrames} í”„ë ˆì„)`;
                            document.getElementById('inferenceProgressBar').style.width = '100%';
                            document.getElementById('startInferenceBtn').disabled = false;
                            document.getElementById('cancelInferenceBtn').style.display = 'none';
                            document.getElementById('saveInferenceBtn').style.display = 'block';

                            // ê²°ê³¼ ì •ë³´ ì €ì¥
                            lastInferenceJobId = currentJobId;
                            lastInferenceResults = {
                                job_id: currentJobId,
                                output_path: data.output_path,
                                total_frames: totalFrames,
                                project_id: document.getElementById('inferenceProjectSelect').value,
                                video_id: document.getElementById('inferenceVideoSelect').options[document.getElementById('inferenceVideoSelect').selectedIndex]?.dataset?.videoId,
                                video_path: document.getElementById('inferenceVideoPath').value
                            };

                            // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ íŒ¨ë„ í‘œì‹œ
                            console.log('[INFERENCE] Showing representative frame panel');
                            const repPanel = document.getElementById('representativeFramePanel');
                            if (repPanel) {
                                repPanel.style.display = 'block';
                                console.log('[INFERENCE] Panel displayed');
                            } else {
                                console.error('[INFERENCE] representativeFramePanel not found!');
                            }
                            if (typeof resetRepresentativeFramePanel === 'function') {
                                resetRepresentativeFramePanel();
                            }

                            alert(`ì¶”ë¡ ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\nì²˜ë¦¬ëœ í”„ë ˆì„: ${totalFrames}\nì¶œë ¥ ë””ë ‰í† ë¦¬: ${data.output_path}\n\nê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥í•˜ê±°ë‚˜ ëŒ€í‘œ í”„ë ˆì„ì„ ì¶”ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
                            currentJobId = null;
                        } else if (status === 'cancelled') {
                            clearInterval(progressInterval);
                            stopPreviewPlayer();
                            document.getElementById('inferenceProgressText').textContent = 'ì¶”ë¡ ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                            document.getElementById('startInferenceBtn').disabled = false;
                            document.getElementById('cancelInferenceBtn').style.display = 'none';
                            document.getElementById('saveInferenceBtn').style.display = 'none';
                            currentJobId = null;
                        } else if (status === 'failed') {
                            clearInterval(progressInterval);
                            stopPreviewPlayer();
                            console.error('[INFERENCE] Job failed:', data.error);
                            document.getElementById('inferenceProgressText').textContent = 'ì¶”ë¡  ì‹¤íŒ¨';
                            document.getElementById('startInferenceBtn').disabled = false;
                            document.getElementById('cancelInferenceBtn').style.display = 'none';
                            document.getElementById('saveInferenceBtn').style.display = 'none';
                            alert('ì¶”ë¡  ì‹¤íŒ¨: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
                            currentJobId = null;
                        }
                    } else {
                        console.error('[INFERENCE] Status check failed:', data);
                    }
                } catch (error) {
                    console.error('[INFERENCE] Progress check error:', error);
                    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† í´ë§ (ì„œë²„ ì¬ì‹œì‘ ë“±ì˜ ê²½ìš°)
                }
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì²´í¬
        }

        // ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ ì‹œì‘
        function startPreviewPlayer() {
            // Placeholder ìˆ¨ê¸°ê³  í”Œë ˆì´ì–´ í‘œì‹œ
            document.getElementById('inferencePreviewPlaceholder').style.display = 'none';
            document.getElementById('inferencePreviewPlayer').style.display = 'flex';

            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            inferencePreviewCanvas = document.getElementById('inferencePreviewCanvas');
            inferencePreviewCtx = inferencePreviewCanvas.getContext('2d');

            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™”
            playerState.isPlaying = false;
            playerState.currentFrameIndex = 0;
            playerState.frameCache.clear();

            // ê¸°ì¡´ ì¸í„°ë²Œì´ ìˆìœ¼ë©´ ì¤‘ì§€
            if (previewInterval) {
                clearInterval(previewInterval);
            }

            // í”„ë ˆì„ ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œì‘ (1ì´ˆë§ˆë‹¤)
            previewInterval = setInterval(updatePlayerInfo, 1000);

            // ìµœì‹  í”„ë ˆì„ ìë™ í‘œì‹œ ì‹œì‘
            updateLatestFrame();
        }

        // í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸ (ì²˜ë¦¬ëœ í”„ë ˆì„ ìˆ˜, FPS ë“±)
        async function updatePlayerInfo() {
            if (!currentJobId) return;

            try {
                const response = await fetch(`${API_BASE_URL}/api/inference/frames/${currentJobId}`);
                const data = await response.json();

                if (data.success) {
                    playerState.totalFrames = data.total_frames;
                    playerState.processedFrames = data.processed_frames;
                    playerState.fps = data.fps || 30;

                    // íƒ€ì„ë¼ì¸ ì—…ë°ì´íŠ¸
                    const timeline = document.getElementById('videoTimeline');
                    timeline.max = Math.max(1, playerState.processedFrames - 1);

                    // ë²„í¼ ìƒíƒœ í‘œì‹œ
                    const bufferPercent = playerState.totalFrames > 0
                        ? (playerState.processedFrames / playerState.totalFrames * 100).toFixed(1)
                        : 0;
                    document.getElementById('inferenceBufferStatus').textContent = `ë²„í¼: ${bufferPercent}%`;

                    // ì¬ìƒ ì¤‘ì´ ì•„ë‹ˆë©´ ìµœì‹  í”„ë ˆì„ í‘œì‹œ
                    if (!playerState.isPlaying && playerState.processedFrames > 0) {
                        playerState.currentFrameIndex = playerState.processedFrames - 1;
                        await displayLatestPreview();
                    }
                }
            } catch (error) {
            }
        }

        // ìµœì‹  í”„ë ˆì„ ìë™ í‘œì‹œ
        async function updateLatestFrame() {
            if (!currentJobId || playerState.isPlaying) return;

            try {
                // ìµœì‹  í”„ë ˆì„ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
                await displayLatestPreview();
            } catch (error) {
            }
        }

        // ìµœì‹  ë¯¸ë¦¬ë³´ê¸° í”„ë ˆì„ í‘œì‹œ (ë©”ëª¨ë¦¬ì—ì„œ)
        async function displayLatestPreview() {
            if (!currentJobId) return;

            try {
                // ì„œë²„ì—ì„œ ìµœì‹  í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°
                const img = new Image();

                img.onload = function() {
                    drawInferenceFrame(img);
                    updateTimeDisplay();
                };

                img.onerror = function() {
                    // ë¯¸ë¦¬ë³´ê¸° ì‹¤íŒ¨ - ì•„ì§ í”„ë ˆì„ì´ ì—†ì„ ìˆ˜ ìˆìŒ
                };

                // ìºì‹œ ë°©ì§€ë¥¼ ìœ„í•´ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
                img.src = `${API_BASE_URL}/api/inference/preview/${currentJobId}?t=${Date.now()}`;

            } catch (error) {
            }
        }

        // íŠ¹ì • í”„ë ˆì„ í‘œì‹œ (ë” ì´ìƒ ê°œë³„ í”„ë ˆì„ ì €ì¥ ì•ˆí•¨ - ìµœì‹  ë¯¸ë¦¬ë³´ê¸°ë§Œ í‘œì‹œ)
        async function displayFrame(frameIndex) {
            // í”„ë ˆì„ ì´ë¯¸ì§€ëŠ” ë” ì´ìƒ ì €ì¥í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ìµœì‹  ë¯¸ë¦¬ë³´ê¸°ë§Œ í‘œì‹œ
            await displayLatestPreview();
        }

        // Inference í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
        function drawInferenceFrame(img) {
            if (!inferencePreviewCanvas || !inferencePreviewCtx) return;

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
            if (inferencePreviewCanvas.width !== img.width || inferencePreviewCanvas.height !== img.height) {
                inferencePreviewCanvas.width = img.width;
                inferencePreviewCanvas.height = img.height;
            }

            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            inferencePreviewCtx.clearRect(0, 0, inferencePreviewCanvas.width, inferencePreviewCanvas.height);
            inferencePreviewCtx.drawImage(img, 0, 0);
        }

        // ì‹œê°„ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateTimeDisplay() {
            const currentTime = playerState.currentFrameIndex / playerState.fps;
            const totalTime = playerState.processedFrames / playerState.fps;

            document.getElementById('videoCurrentTime').textContent = formatTime(currentTime);
            document.getElementById('videoDuration').textContent = formatTime(totalTime);

            // íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸
            const timeline = document.getElementById('videoTimeline');
            timeline.value = playerState.currentFrameIndex;

            // í”„ë ˆì„ ìƒíƒœ ì—…ë°ì´íŠ¸
            document.getElementById('inferencePreviewStatus').textContent =
                `í”„ë ˆì„: ${playerState.currentFrameIndex + 1} / ${playerState.processedFrames}`;
        }

        // ì‹œê°„ í¬ë§·íŒ… (ì´ˆ -> MM:SS)
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // í”Œë ˆì´ì–´ ì¤‘ì§€
        function stopPreviewPlayer() {
            // ì¬ìƒ ì¤‘ì§€
            if (playerState.isPlaying) {
                togglePlayPause();
            }

            // ì¸í„°ë²Œ ì¤‘ì§€
            if (previewInterval) {
                clearInterval(previewInterval);
                previewInterval = null;
            }

            // í”Œë ˆì´ì–´ ìˆ¨ê¸°ê³  Placeholder í‘œì‹œ
            document.getElementById('inferencePreviewPlayer').style.display = 'none';
            document.getElementById('inferencePreviewPlaceholder').style.display = 'block';

            // ìƒíƒœ ì´ˆê¸°í™”
            playerState.frameCache.clear();
        }

        // ì¬ìƒ/ì¼ì‹œì •ì§€ í† ê¸€
        function togglePlayPause() {
            if (playerState.isPlaying) {
                pausePlayback();
            } else {
                startPlayback();
            }
        }

        // ì¬ìƒ ì‹œì‘
        async function startPlayback() {
            if (playerState.processedFrames === 0) {
                alert('ì•„ì§ ì²˜ë¦¬ëœ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            playerState.isPlaying = true;
            document.getElementById('playPauseBtn').innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';

            // ë¹„ë™ê¸° ì¬ìƒ ë£¨í”„ ì‹œì‘
            playbackLoop();
        }

        // ë¹„ë™ê¸° ì¬ìƒ ë£¨í”„ (displayFrameì´ ì™„ë£Œëœ í›„ ë‹¤ìŒ í”„ë ˆì„ í˜¸ì¶œ)
        async function playbackLoop() {
            while (playerState.isPlaying) {
                const startTime = performance.now();

                // ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ ì´ë™
                playerState.currentFrameIndex++;

                // ëì— ë„ë‹¬í•˜ë©´ ì²˜ìŒìœ¼ë¡œ
                if (playerState.currentFrameIndex >= playerState.processedFrames) {
                    playerState.currentFrameIndex = 0;
                }

                // í”„ë ˆì„ í‘œì‹œ (ë¹„ë™ê¸° - ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°)
                await window.displayFrame(playerState.currentFrameIndex);

                // ì¬ìƒ ì†ë„ì— ë”°ë¥¸ í”„ë ˆì„ ê°„ê²© ê³„ì‚°
                const targetInterval = (1000 / playerState.fps) / playerState.playbackSpeed;
                const elapsed = performance.now() - startTime;
                const delay = Math.max(0, targetInterval - elapsed);

                // ë‹¤ìŒ í”„ë ˆì„ê¹Œì§€ ëŒ€ê¸°
                if (delay > 0 && playerState.isPlaying) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // ì¬ìƒ ì¼ì‹œì •ì§€
        function pausePlayback() {
            playerState.isPlaying = false;
            document.getElementById('playPauseBtn').innerHTML = 'â–¶ï¸ ì¬ìƒ';
        }

        // ì¬ìƒ ì •ì§€ (ì²˜ìŒìœ¼ë¡œ)
        function stopPlayback() {
            pausePlayback();
            playerState.currentFrameIndex = 0;
            displayFrame(0);
        }

        // í”„ë ˆì„ ê±´ë„ˆë›°ê¸°
        function skipFrames(count) {
            if (playerState.processedFrames === 0) return;

            playerState.currentFrameIndex += count;

            // ë²”ìœ„ ì²´í¬
            if (playerState.currentFrameIndex < 0) {
                playerState.currentFrameIndex = 0;
            } else if (playerState.currentFrameIndex >= playerState.processedFrames) {
                playerState.currentFrameIndex = playerState.processedFrames - 1;
            }

            displayFrame(playerState.currentFrameIndex);
        }

        // íŠ¹ì • í”„ë ˆì„ìœ¼ë¡œ ì´ë™ (íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë”)
        function seekToFrame(frameIndex) {
            frameIndex = parseInt(frameIndex);

            if (frameIndex < 0 || frameIndex >= playerState.processedFrames) return;

            playerState.currentFrameIndex = frameIndex;
            displayFrame(frameIndex);
        }

        // ì¬ìƒ ì†ë„ ë³€ê²½
        function changePlaybackSpeed() {
            const speed = parseFloat(document.getElementById('playbackSpeed').value);
            playerState.playbackSpeed = speed;

            // ë¹„ë””ì˜¤ ìš”ì†Œê°€ ìˆìœ¼ë©´ ì§ì ‘ ì¬ìƒ ì†ë„ ë³€ê²½
            if (inferenceVideoElement) {
                inferenceVideoElement.playbackRate = speed;
            }
        }

        // ì™„ë£Œëœ ì¶”ë¡  ê²°ê³¼ ë³´ê¸°
        // ì¶”ë¡  ê²°ê³¼ ë·°ì–´ìš© ìƒíƒœ
        let inferenceResultsData = null;  // JSON ê²°ê³¼ ë°ì´í„°
        let inferenceVideoElement = null;  // ë¹„ë””ì˜¤ ì—˜ë¦¬ë¨¼íŠ¸

        async function viewInferenceResults(resultData) {
            console.log('[INFERENCE VIEWER] Loading results:', resultData);

            // ìƒíƒœ ì´ˆê¸°í™”
            const viewerJobId = 'viewer_' + Date.now();
            currentJobId = viewerJobId;

            playerState.totalFrames = resultData.total_frames;
            playerState.processedFrames = resultData.frame_count;
            playerState.fps = resultData.fps || 30;
            playerState.currentFrameIndex = 0;
            playerState.isPlaying = false;

            // ë¡œë”© í‘œì‹œ
            document.getElementById('inferencePreviewPlaceholder').innerHTML =
                '<p style="color: #4a9eff;">ì¶”ë¡  ê²°ê³¼ ë¡œë”© ì¤‘...</p>';

            try {
                // 1. JSON ê²°ê³¼ ë¡œë“œ
                console.log('[INFERENCE VIEWER] Fetching JSON results...');
                const jsonResponse = await fetch(API_BASE_URL + '/api/inference/results', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({result_path: resultData.result_path})
                });

                if (!jsonResponse.ok) {
                    throw new Error('Failed to load inference results');
                }

                const jsonData = await jsonResponse.json();
                if (!jsonData.success) {
                    throw new Error(jsonData.error || 'Failed to load results');
                }

                inferenceResultsData = jsonData.data;

                // resultsê°€ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° í”„ë ˆì„ ë²ˆí˜¸ë¡œ ì¸ë±ì‹±ëœ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
                if (Array.isArray(inferenceResultsData.results)) {
                    const resultsMap = {};
                    inferenceResultsData.results.forEach(item => {
                        if (item.frame_number !== undefined) {
                            resultsMap[item.frame_number] = item.detections || [];
                        }
                    });
                    inferenceResultsData.resultsMap = resultsMap;
                    console.log('[INFERENCE VIEWER] JSON loaded, frames:', Object.keys(resultsMap).length);
                } else {
                    // ì´ë¯¸ ë”•ì…”ë„ˆë¦¬ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    inferenceResultsData.resultsMap = inferenceResultsData.results || {};
                    console.log('[INFERENCE VIEWER] JSON loaded, frames:', Object.keys(inferenceResultsData.resultsMap).length);
                }

                // 2. ë¹„ë””ì˜¤ URL êµ¬ì„± (ì›ë³¸ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¬ë°)
                const videoPath = inferenceResultsData.video_path || resultData.video_path;
                const sessionId = getSessionId();

                // í˜„ì¬ ì„ íƒëœ í”„ë¡œì íŠ¸ì™€ ë¹„ë””ì˜¤ ID ê°€ì ¸ì˜¤ê¸°
                const projectSelect = document.getElementById('inferenceProjectSelect');
                const videoSelect = document.getElementById('inferenceVideoSelect');
                const projectId = projectSelect ? projectSelect.value : '';
                const selectedOption = videoSelect ? videoSelect.options[videoSelect.selectedIndex] : null;
                const videoId = selectedOption ? selectedOption.dataset.videoId : '';

                if (!projectId || !videoId) {
                    throw new Error('í”„ë¡œì íŠ¸ ë˜ëŠ” ë¹„ë””ì˜¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                }

                console.log('[INFERENCE VIEWER] Project:', projectId, 'Video ID:', videoId);
                const videoStreamUrl = `${API_BASE_URL}/api/projects/${encodeURIComponent(projectId)}/videos/${encodeURIComponent(videoId)}/stream?session_id=${sessionId}`;

                // 3. Placeholder ìˆ¨ê¸°ê³  í”Œë ˆì´ì–´ í‘œì‹œ
                document.getElementById('inferencePreviewPlaceholder').style.display = 'none';
                document.getElementById('inferencePreviewPlayer').style.display = 'flex';

                // 4. ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                inferencePreviewCanvas = document.getElementById('inferencePreviewCanvas');
                inferencePreviewCtx = inferencePreviewCanvas.getContext('2d');

                // 5. ìˆ¨ê²¨ì§„ ë¹„ë””ì˜¤ ì—˜ë¦¬ë¨¼íŠ¸ ìƒì„± (í”„ë ˆì„ ì¶”ì¶œìš©)
                if (!inferenceVideoElement) {
                    inferenceVideoElement = document.createElement('video');
                    inferenceVideoElement.style.display = 'none';
                    inferenceVideoElement.crossOrigin = 'anonymous';
                    inferenceVideoElement.preload = 'auto';
                    document.body.appendChild(inferenceVideoElement);
                }

                // ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì„¤ì •
                inferenceVideoElement.src = videoStreamUrl;

                // ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œ ëŒ€ê¸°
                await new Promise((resolve, reject) => {
                    inferenceVideoElement.onloadedmetadata = resolve;
                    inferenceVideoElement.onerror = () => reject(new Error('ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨'));
                    setTimeout(() => reject(new Error('ë¹„ë””ì˜¤ ë¡œë“œ íƒ€ì„ì•„ì›ƒ')), 30000);
                });

                console.log('[INFERENCE VIEWER] Video loaded, duration:', inferenceVideoElement.duration);

                // íƒ€ì„ë¼ì¸ ì„¤ì •
                const timeline = document.getElementById('videoTimeline');
                timeline.max = Math.max(1, playerState.processedFrames - 1);

                // ë²„í¼ ìƒíƒœ í‘œì‹œ
                document.getElementById('inferenceBufferStatus').textContent = 'ë²„í¼: 100%';

                // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                inferencePreviewCanvas.width = inferenceVideoElement.videoWidth;
                inferencePreviewCanvas.height = inferenceVideoElement.videoHeight;

                // ë Œë” ë£¨í”„ (requestAnimationFrame ê¸°ë°˜)
                let inferenceRenderLoopActive = false;

                function renderInferenceFrame() {
                    if (!inferenceRenderLoopActive) return;

                    // í˜„ì¬ í”„ë ˆì„ ê³„ì‚°
                    const currentFrame = Math.floor(inferenceVideoElement.currentTime * playerState.fps);
                    playerState.currentFrameIndex = currentFrame;

                    // ìº”ë²„ìŠ¤ì— ë¹„ë””ì˜¤ í”„ë ˆì„ ê·¸ë¦¬ê¸°
                    inferencePreviewCtx.drawImage(inferenceVideoElement, 0, 0);

                    // ì¶”ë¡  ê²°ê³¼ ì˜¤ë²„ë ˆì´
                    const frameResults = inferenceResultsData.resultsMap[currentFrame];
                    if (frameResults && frameResults.length > 0) {
                        drawInferenceOverlay(frameResults);
                    }

                    updateTimeDisplay();

                    // ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
                    requestAnimationFrame(renderInferenceFrame);
                }

                // displayFrame í•¨ìˆ˜ (ì‹œí¬ìš© - ì¼ì‹œì •ì§€ ìƒíƒœì—ì„œ ì‚¬ìš©)
                window.displayFrame = async function(frameIndex) {
                    if (frameIndex < 0 || frameIndex >= playerState.totalFrames) return;

                    playerState.currentFrameIndex = frameIndex;

                    // ë¹„ë””ì˜¤ì—ì„œ í•´ë‹¹ í”„ë ˆì„ìœ¼ë¡œ ì‹œí¬
                    const targetTime = frameIndex / playerState.fps;
                    inferenceVideoElement.currentTime = targetTime;

                    // ì‹œí¬ ì™„ë£Œ ëŒ€ê¸°
                    await new Promise(resolve => {
                        inferenceVideoElement.onseeked = resolve;
                    });

                    // ìº”ë²„ìŠ¤ì— ë¹„ë””ì˜¤ í”„ë ˆì„ ê·¸ë¦¬ê¸°
                    inferencePreviewCtx.drawImage(inferenceVideoElement, 0, 0);

                    // ì¶”ë¡  ê²°ê³¼ ì˜¤ë²„ë ˆì´
                    const frameResults = inferenceResultsData.resultsMap[frameIndex];
                    if (frameResults && frameResults.length > 0) {
                        drawInferenceOverlay(frameResults);
                    }

                    updateTimeDisplay();
                };

                // startPlayback/pausePlayback ì¬ì •ì˜ (ë¹„ë””ì˜¤ ìì—° ì¬ìƒ ì‚¬ìš©)
                window.startPlayback = function() {
                    if (playerState.processedFrames === 0) {
                        alert('ì•„ì§ ì²˜ë¦¬ëœ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }

                    playerState.isPlaying = true;
                    document.getElementById('playPauseBtn').innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';

                    // ì¬ìƒ ì†ë„ ì„¤ì •
                    inferenceVideoElement.playbackRate = playerState.playbackSpeed;

                    // ë¹„ë””ì˜¤ ì¬ìƒ ì‹œì‘
                    inferenceVideoElement.play();

                    // ë Œë” ë£¨í”„ ì‹œì‘
                    inferenceRenderLoopActive = true;
                    requestAnimationFrame(renderInferenceFrame);
                };

                window.pausePlayback = function() {
                    playerState.isPlaying = false;
                    document.getElementById('playPauseBtn').innerHTML = 'â–¶ï¸ ì¬ìƒ';

                    // ë¹„ë””ì˜¤ ì¼ì‹œì •ì§€
                    inferenceVideoElement.pause();

                    // ë Œë” ë£¨í”„ ì¤‘ì§€
                    inferenceRenderLoopActive = false;
                };

                // ë¹„ë””ì˜¤ ì¢…ë£Œ ì‹œ ì²˜ë¦¬
                inferenceVideoElement.onended = function() {
                    playerState.isPlaying = false;
                    inferenceRenderLoopActive = false;
                    document.getElementById('playPauseBtn').innerHTML = 'â–¶ï¸ ì¬ìƒ';
                    playerState.currentFrameIndex = 0;
                    inferenceVideoElement.currentTime = 0;
                    window.displayFrame(0);
                };

                // ì²« í”„ë ˆì„ í‘œì‹œ
                await window.displayFrame(0);

                // ì¬ìƒ ë²„íŠ¼ í™œì„±í™”
                document.getElementById('playPauseBtn').disabled = false;

                // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œì„ ìœ„í•´ lastInferenceResults ì„¤ì •
                const outputPath = resultData.result_path || resultData.output_path || '';
                lastInferenceResults = {
                    job_id: viewerJobId,
                    output_path: outputPath.replace('/inference_results.json', ''),
                    total_frames: playerState.totalFrames,
                    project_id: projectId,
                    video_id: videoId,
                    video_path: videoPath
                };
                console.log('[INFERENCE VIEWER] lastInferenceResults:', lastInferenceResults);

                // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ íŒ¨ë„ í‘œì‹œ
                console.log('[INFERENCE VIEWER] Showing representative frame panel');
                const repPanel = document.getElementById('representativeFramePanel');
                if (repPanel) {
                    repPanel.style.display = 'block';
                    console.log('[INFERENCE VIEWER] Panel displayed');
                } else {
                    console.error('[INFERENCE VIEWER] representativeFramePanel not found!');
                }
                if (typeof resetRepresentativeFramePanel === 'function') {
                    resetRepresentativeFramePanel();
                }

                console.log('[INFERENCE VIEWER] Ready to play (native video playback)');

            } catch (error) {
                console.error('[INFERENCE VIEWER] Error:', error);
                document.getElementById('inferencePreviewPlaceholder').innerHTML =
                    `<p style="color: #f44;">ì˜¤ë¥˜: ${error.message}</p>`;
                document.getElementById('inferencePreviewPlaceholder').style.display = 'block';
                document.getElementById('inferencePreviewPlayer').style.display = 'none';
            }
        }

        // ì¶”ë¡  ê²°ê³¼ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        function drawInferenceOverlay(detections) {
            if (!inferencePreviewCtx || !detections) return;

            // í´ë˜ìŠ¤ë³„ ìƒ‰ìƒ
            const classColors = {
                'crack': '#FF0000',      // ê· ì—´ - ë¹¨ê°•
                'joint': '#00FF00',      // ì´ìŒë¶€ - ë…¹ìƒ‰
                'root': '#0000FF',       // ë¿Œë¦¬ì¹¨ì… - íŒŒë‘
                'deposit': '#FFFF00',    // í‡´ì ë¬¼ - ë…¸ë‘
                'damage': '#FF00FF',     // íŒŒì† - ë§ˆì  íƒ€
                'scale': '#FFA500',      // ìŠ¤ì¼€ì¼ - ì£¼í™©
                'default': '#00FFFF'     // ê¸°ë³¸ - ì‹œì•ˆ
            };

            detections.forEach(det => {
                const color = classColors[det.label] || classColors['default'];

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
                if (det.polygon && det.polygon.length > 0) {
                    inferencePreviewCtx.beginPath();
                    inferencePreviewCtx.moveTo(det.polygon[0][0], det.polygon[0][1]);
                    for (let i = 1; i < det.polygon.length; i++) {
                        inferencePreviewCtx.lineTo(det.polygon[i][0], det.polygon[i][1]);
                    }
                    inferencePreviewCtx.closePath();

                    // ë°˜íˆ¬ëª… ì±„ìš°ê¸°
                    inferencePreviewCtx.fillStyle = color + '40';  // 25% íˆ¬ëª…ë„
                    inferencePreviewCtx.fill();

                    // í…Œë‘ë¦¬
                    inferencePreviewCtx.strokeStyle = color;
                    inferencePreviewCtx.lineWidth = 2;
                    inferencePreviewCtx.stroke();
                }

                // í´ë¦¬ê³¤ì´ ìˆìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ëŠ” ìƒëµí•˜ê³ , ë¼ë²¨ë§Œ í´ë¦¬ê³¤ ìœ„ì— í‘œì‹œ
                if (det.polygon && det.polygon.length > 0) {
                    const labelText = `${det.label} ${(det.confidence * 100).toFixed(0)}%`;
                    const minX = Math.min(...det.polygon.map(p => p[0]));
                    const minY = Math.min(...det.polygon.map(p => p[1]));
                    inferencePreviewCtx.font = '14px Arial';
                    inferencePreviewCtx.fillStyle = color;
                    inferencePreviewCtx.fillRect(minX, Math.max(0, minY - 20), inferencePreviewCtx.measureText(labelText).width + 8, 20);
                    inferencePreviewCtx.fillStyle = '#000';
                    inferencePreviewCtx.fillText(labelText, minX + 4, Math.max(15, minY - 5));
                } else {
                    // í´ë¦¬ê³¤ì´ ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸° (box í˜•ì‹: [x, y, width, height])
                    const bbox = det.bbox || det.box;
                    if (bbox) {
                        const [x, y, w, h] = bbox;
                        inferencePreviewCtx.strokeStyle = color;
                        inferencePreviewCtx.lineWidth = 2;
                        inferencePreviewCtx.strokeRect(x, y, w, h);

                        // ë¼ë²¨ í‘œì‹œ
                        const labelText = `${det.label} ${(det.confidence * 100).toFixed(0)}%`;
                        inferencePreviewCtx.font = '14px Arial';
                        inferencePreviewCtx.fillStyle = color;
                        inferencePreviewCtx.fillRect(x, Math.max(0, y - 20), inferencePreviewCtx.measureText(labelText).width + 8, 20);
                        inferencePreviewCtx.fillStyle = '#000';
                        inferencePreviewCtx.fillText(labelText, x + 4, Math.max(15, y - 5));
                    }
                }
            });
        }

        // ì¶”ë¡  ì·¨ì†Œ
        async function cancelInference() {
            if (!currentJobId) {
                alert('ì§„í–‰ ì¤‘ì¸ ì¶”ë¡ ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (!confirm('ì •ë§ë¡œ ì¶”ë¡ ì„ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                document.getElementById('cancelInferenceBtn').disabled = true;
                const response = await fetch(`${API_BASE_URL}/api/inference/cancel/${currentJobId}`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    console.log('[INFERENCE] Cancel requested');
                    document.getElementById('inferenceProgressText').textContent = 'ì·¨ì†Œ ì¤‘...';
                } else {
                    alert('ì·¨ì†Œ ì‹¤íŒ¨: ' + data.error);
                    document.getElementById('cancelInferenceBtn').disabled = false;
                }
            } catch (error) {
                console.error('Cancel error:', error);
                alert('ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                document.getElementById('cancelInferenceBtn').disabled = false;
            }
        }

        // ì¶”ë¡  ê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥
        async function saveInferenceResults() {
            if (!lastInferenceResults) {
                alert('ì €ì¥í•  ì¶”ë¡  ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const { job_id, project_id, video_id, output_path, total_frames } = lastInferenceResults;

            if (!job_id) {
                alert('ì¶”ë¡  ì‘ì—… IDê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (!project_id || !video_id) {
                alert('í”„ë¡œì íŠ¸ ë˜ëŠ” ë¹„ë””ì˜¤ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (!confirm(`ì¶”ë¡  ê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\ní”„ë¡œì íŠ¸: ${project_id}\në¹„ë””ì˜¤: ${video_id}\ní”„ë ˆì„ ìˆ˜: ${total_frames}`)) {
                return;
            }

            const saveBtn = document.getElementById('saveInferenceBtn');
            saveBtn.disabled = true;
            saveBtn.textContent = 'ì €ì¥ ì¤‘...';

            try {
                const response = await authFetch('/api/inference/save-annotations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        job_id: job_id,
                        project_id: project_id,
                        video_id: video_id,
                        output_path: output_path
                    })
                });

                const data = await response.json();

                if (data.success) {
                    alert(`ì¶”ë¡  ê²°ê³¼ê°€ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nì €ì¥ëœ í”„ë ˆì„: ${data.total_frames}\nì €ì¥ëœ ì–´ë…¸í…Œì´ì…˜: ${data.total_annotations}`);
                    saveBtn.style.display = 'none';
                    lastInferenceResults = null;
                    // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                    document.getElementById('representativeFramePanel').style.display = 'none';
                } else {
                    alert('ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[INFERENCE] Save error:', error);
                alert('ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'ê²°ê³¼ë¥¼ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥';
            }
        }

        // ============================================
        // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ ê¸°ëŠ¥
        // ============================================

        // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ ìƒíƒœ ë³€ìˆ˜
        let motionSegments = null;  // ì›€ì§ì„ ë¶„ì„ ê²°ê³¼
        let representativeFrames = null;  // ëŒ€í‘œ í”„ë ˆì„ ëª©ë¡
        let currentInferenceResultPath = null;  // í˜„ì¬ ì¶”ë¡  ê²°ê³¼ ê²½ë¡œ
        let currentVideoPathForExtraction = null;  // í˜„ì¬ ë¹„ë””ì˜¤ ê²½ë¡œ

        // ì›€ì§ì„ ë¶„ì„
        async function analyzeMotion() {
            if (!lastInferenceResults || !lastInferenceResults.output_path) {
                alert('ì¶”ë¡  ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì¶”ë¡ ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.');
                return;
            }

            const btn = document.getElementById('analyzeMotionBtn');
            const resultDiv = document.getElementById('motionAnalysisResult');
            const threshold = parseFloat(document.getElementById('motionThreshold').value);
            const minDuration = parseFloat(document.getElementById('minSegmentDuration').value);

            btn.disabled = true;
            btn.innerHTML = 'â³ ë¶„ì„ ì¤‘...';

            // ì§„í–‰ ë°” í‘œì‹œ
            const progressContainer = document.getElementById('extractionProgressContainer');
            const progressBar = document.getElementById('extractionProgressBar');
            const progressText = document.getElementById('extractionProgressText');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressText.textContent = 'ì›€ì§ì„ ë¶„ì„ ì¤€ë¹„ ì¤‘...';

            // ê²°ê³¼ ê²½ë¡œì™€ ë¹„ë””ì˜¤ ê²½ë¡œ ì„¤ì •
            const resultPath = lastInferenceResults.output_path;
            currentInferenceResultPath = resultPath + '/inference_results.json';
            currentVideoPathForExtraction = lastInferenceResults.video_path ||
                currentProject?.videos?.find(v => v.id === lastInferenceResults.video_id)?.path;

            // ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ì§„í–‰ ìƒí™© ìˆ˜ì‹ 
            try {
                const response = await fetch(`${API_BASE_URL}/api/inference/analyze-motion`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        result_path: resultPath,
                        motion_threshold: threshold,
                        min_segment_duration: minDuration,
                        stream_progress: true
                    })
                });

                // ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì²˜ë¦¬
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let data = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const json = JSON.parse(line.slice(6));
                                if (json.progress !== undefined) {
                                    // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                                    const pct = Math.round(json.progress);
                                    progressBar.style.width = `${Math.min(pct, 30)}%`;
                                    progressText.textContent = `ì›€ì§ì„ ë¶„ì„ ì¤‘... ${pct}% (${json.current_frame || 0}/${json.total_frames || 0} í”„ë ˆì„)`;
                                } else if (json.segments !== undefined) {
                                    // ìµœì¢… ê²°ê³¼
                                    data = json;
                                }
                            } catch (e) {
                                // JSON íŒŒì‹± ì‹¤íŒ¨ ë¬´ì‹œ
                            }
                        }
                    }
                }

                // ë²„í¼ì— ë‚¨ì€ ë°ì´í„° ì²˜ë¦¬
                if (buffer.startsWith('data: ')) {
                    try {
                        data = JSON.parse(buffer.slice(6));
                    } catch (e) {}
                }

                if (data.success !== false && data.segments) {
                    motionSegments = data.segments;
                    const segmentCount = data.segment_count || data.total_segments || motionSegments.length;

                    // ê²°ê³¼ í‘œì‹œ
                    resultDiv.style.display = 'block';
                    document.getElementById('segmentCount').textContent = segmentCount;
                    const stats = data.motion_stats || {};
                    document.getElementById('motionRange').textContent =
                        `${(stats.avg || 0).toFixed(2)} (min: ${(stats.min || 0).toFixed(2)}, max: ${(stats.max || 0).toFixed(2)})`;

                    // 2ë‹¨ê³„ ë²„íŠ¼ í™œì„±í™”
                    const extractBtn = document.getElementById('extractRepresentativesBtn');
                    extractBtn.disabled = false;
                    extractBtn.style.opacity = '1';

                    progressBar.style.width = '33%';
                    progressText.textContent = `âœ“ ì›€ì§ì„ ë¶„ì„ ì™„ë£Œ - ${segmentCount}ê°œ ì •ì§€ êµ¬ê°„ ë°œê²¬`;

                    console.log('[EXTRACT] Motion analysis complete:', data);
                } else {
                    throw new Error(data.error || 'ì›€ì§ì„ ë¶„ì„ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('[EXTRACT] Motion analysis error:', error);
                alert('ì›€ì§ì„ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                progressContainer.style.display = 'none';
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'ğŸ” êµ¬ê°„ ë¶„ì„';
            }
        }

        // ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ
        async function extractRepresentatives() {
            if (!motionSegments || motionSegments.length === 0) {
                alert('ë¨¼ì € ì›€ì§ì„ ë¶„ì„ì„ ìˆ˜í–‰í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!currentInferenceResultPath) {
                alert('ì¶”ë¡  ê²°ê³¼ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const btn = document.getElementById('extractRepresentativesBtn');
            const resultDiv = document.getElementById('extractionResult');
            const framesPerSegment = parseInt(document.getElementById('framesPerSegment').value);
            const minConfidence = parseFloat(document.getElementById('minConfidenceFilter').value);

            btn.disabled = true;
            btn.innerHTML = 'â³ ì„ íƒ ì¤‘...';

            const progressBar = document.getElementById('extractionProgressBar');
            const progressText = document.getElementById('extractionProgressText');
            progressText.textContent = 'ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ ì¤‘...';

            try {
                // result_pathëŠ” ë””ë ‰í† ë¦¬ ê²½ë¡œ (íŒŒì¼ëª… ì œì™¸)
                const resultPath = currentInferenceResultPath.replace('/inference_results.json', '');

                const response = await fetch(`${API_BASE_URL}/api/inference/extract-representatives`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        result_path: resultPath,
                        segments: motionSegments,
                        frames_per_segment: framesPerSegment,
                        min_confidence: minConfidence
                    })
                });

                const data = await response.json();

                if (data.success) {
                    representativeFrames = data.representative_frames;

                    // ê²°ê³¼ í‘œì‹œ
                    resultDiv.style.display = 'block';
                    document.getElementById('selectedFrameCount').textContent = data.total_frames;
                    document.getElementById('selectedDetectionCount').textContent = data.total_detections;

                    // 3ë‹¨ê³„ ë²„íŠ¼ í™œì„±í™”
                    const exportBtn = document.getElementById('exportDatasetBtn');
                    exportBtn.disabled = false;
                    exportBtn.style.opacity = '1';

                    progressBar.style.width = '66%';
                    progressText.textContent = `âœ“ ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ ì™„ë£Œ - ${data.total_frames}ê°œ í”„ë ˆì„, ${data.total_detections}ê°œ ê²€ì¶œ`;

                    console.log('[EXTRACT] Representative extraction complete:', data);
                } else {
                    throw new Error(data.error || 'ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('[EXTRACT] Representative extraction error:', error);
                alert('ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'âœ… ëŒ€í‘œ í”„ë ˆì„ ì„ íƒ';
            }
        }

        // ë°ì´í„°ì…‹ ë‚´ë³´ë‚´ê¸°
        async function exportExtractedDataset() {
            if (!representativeFrames || representativeFrames.length === 0) {
                alert('ë¨¼ì € ëŒ€í‘œ í”„ë ˆì„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!currentVideoPathForExtraction) {
                alert('ë¹„ë””ì˜¤ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const btn = document.getElementById('exportDatasetBtn');
            const resultDiv = document.getElementById('exportResult');
            const outputPath = document.getElementById('extractedDatasetPath').value.trim();
            const format = document.getElementById('extractedDatasetFormat').value;
            const splitRatio = document.getElementById('extractedSplitRatio').value.trim();

            if (!outputPath) {
                alert('ì¶œë ¥ ë””ë ‰í† ë¦¬ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ë¹„ìœ¨ íŒŒì‹±
            const ratios = splitRatio.split(',').map(r => parseFloat(r.trim()));
            if (ratios.length !== 3 || ratios.some(isNaN) || Math.abs(ratios.reduce((a,b) => a+b, 0) - 1.0) > 0.01) {
                alert('Train/Val/Test ë¹„ìœ¨ì€ í•©ì´ 1.0ì´ì–´ì•¼ í•©ë‹ˆë‹¤. (ì˜ˆ: 0.8,0.1,0.1)');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = 'â³ ìƒì„± ì¤‘...';

            const progressBar = document.getElementById('extractionProgressBar');
            const progressText = document.getElementById('extractionProgressText');
            progressText.textContent = 'ë°ì´í„°ì…‹ ìƒì„± ì¤‘...';

            try {
                // result_pathëŠ” ë””ë ‰í† ë¦¬ ê²½ë¡œ (íŒŒì¼ëª… ì œì™¸)
                const resultPath = currentInferenceResultPath.replace('/inference_results.json', '');

                const response = await fetch(`${API_BASE_URL}/api/inference/export-dataset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        result_path: resultPath,
                        representative_frames: representativeFrames,
                        output_dir: outputPath,
                        format: format,
                        split_ratio: ratios
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // ê²°ê³¼ í‘œì‹œ
                    resultDiv.style.display = 'block';
                    document.getElementById('exportResultContent').innerHTML = `
                        <div style="color: #28a745; margin-bottom: 8px;">âœ“ ë°ì´í„°ì…‹ ìƒì„± ì™„ë£Œ!</div>
                        <div>ì €ì¥ ê²½ë¡œ: <span style="color: #4a9eff;">${data.output_path}</span></div>
                        <div>ì´ ì´ë¯¸ì§€: <span style="color: #fff;">${data.total_images}ê°œ</span></div>
                        <div style="margin-top: 5px; color: #888;">
                            Train: ${data.train_count || '-'} / Val: ${data.val_count || '-'} / Test: ${data.test_count || '-'}
                        </div>
                    `;

                    progressBar.style.width = '100%';
                    progressText.textContent = `âœ“ ë°ì´í„°ì…‹ ìƒì„± ì™„ë£Œ - ${data.total_images}ê°œ ì´ë¯¸ì§€`;

                    console.log('[EXTRACT] Dataset export complete:', data);

                    // ì„±ê³µ ì•Œë¦¼
                    alert(`ë°ì´í„°ì…‹ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nê²½ë¡œ: ${data.output_path}\nì´ ì´ë¯¸ì§€: ${data.total_images}ê°œ`);
                } else {
                    throw new Error(data.error || 'ë°ì´í„°ì…‹ ìƒì„± ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('[EXTRACT] Dataset export error:', error);
                alert('ë°ì´í„°ì…‹ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'ğŸš€ ë°ì´í„°ì…‹ ìƒì„±';
            }
        }

        // ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ íŒ¨ë„ ìƒíƒœ ë¦¬ì…‹
        function resetRepresentativeFramePanel() {
            motionSegments = null;
            representativeFrames = null;
            currentInferenceResultPath = null;
            currentVideoPathForExtraction = null;

            // UI ë¦¬ì…‹
            document.getElementById('motionAnalysisResult').style.display = 'none';
            document.getElementById('extractionResult').style.display = 'none';
            document.getElementById('exportResult').style.display = 'none';
            document.getElementById('extractionProgressContainer').style.display = 'none';

            const extractBtn = document.getElementById('extractRepresentativesBtn');
            extractBtn.disabled = true;
            extractBtn.style.opacity = '0.5';

            const exportBtn = document.getElementById('exportDatasetBtn');
            exportBtn.disabled = true;
            exportBtn.style.opacity = '0.5';
        }

        // ============================================
        // ê´€ë¦¬ì ê¸°ëŠ¥
        // ============================================

        // ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ
        async function loadUsers() {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '<p style="color: #999;">ë¡œë”© ì¤‘...</p>';

            try {
                const response = await authFetch('/api/auth/users');
                const data = await response.json();

                if (data.success && data.users) {
                    usersList.innerHTML = data.users.map(u => `
                        <div style="padding: 15px; margin-bottom: 10px; background: #2d2d2d; border-radius: 4px; border-left: 4px solid ${u.role === 'admin' ? '#ff6b6b' : '#4a9eff'};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="font-size: 16px; color: #4a9eff;">${u.user_id}</strong>
                                    <span style="margin-left: 10px; padding: 2px 8px; background: ${u.role === 'admin' ? '#ff6b6b' : '#4a9eff'}; color: white; border-radius: 3px; font-size: 11px;">${u.role}</span>
                                    <br>
                                    <small style="color: #999;">${u.full_name || 'No name'}</small>
                                    <br>
                                    <small style="color: #666;">ìƒì„±ì¼: ${new Date(u.created_at).toLocaleString('ko-KR')}</small>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button onclick="editUser('${u.user_id}', '${u.full_name || ''}', '${u.role}')" style="padding: 8px 15px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;" onmouseover="this.style.background='#3a8eef'" onmouseout="this.style.background='#4a9eff'">
                                        âœï¸ ìˆ˜ì •
                                    </button>
                                    <button onclick="deleteUser('${u.user_id}')" style="padding: 8px 15px; background: #ff6b6b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;" onmouseover="this.style.background='#ff4d4d'" onmouseout="this.style.background='#ff6b6b'">
                                        ğŸ—‘ ì‚­ì œ
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    usersList.innerHTML = '<p style="color: #999;">ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                }
            } catch (error) {
                console.error('[ADMIN] Load users error:', error);
                usersList.innerHTML = '<p style="color: red;">ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</p>';
            }
        }

        // ìƒˆ ì‚¬ìš©ì ìƒì„±
        async function createNewUser() {
            const userId = document.getElementById('newUserId').value.trim();
            const password = document.getElementById('newUserPassword').value;
            const fullName = document.getElementById('newUserFullName').value.trim();
            const role = document.getElementById('newUserRole').value;

            if (!userId || !password) {
                alert('ì‚¬ìš©ì IDì™€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await authFetch('/api/auth/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        password: password,
                        full_name: fullName,
                        role: role
                    })
                });

                const data = await response.json();

                if (data.success) {
                    alert('âœ… ì‚¬ìš©ìê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nUser ID: ' + userId);

                    // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                    document.getElementById('newUserId').value = '';
                    document.getElementById('newUserPassword').value = '';
                    document.getElementById('newUserFullName').value = '';
                    document.getElementById('newUserRole').value = 'user';

                    // ì‚¬ìš©ì ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    loadUsers();
                } else {
                    alert('âŒ ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Create user error:', error);
                alert('âŒ ì‚¬ìš©ì ìƒì„± ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ì‚¬ìš©ì ì‚­ì œ
        async function deleteUser(userId) {
            // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì í™•ì¸
            const currentUser = getCurrentUser();
            if (currentUser && currentUser.user_id === userId) {
                alert('âŒ í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìëŠ” ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // í™•ì¸ ëŒ€í™”ìƒì
            if (!confirm(`âš ï¸ ì •ë§ë¡œ ì‚¬ìš©ìë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nUser ID: ${userId}\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)) {
                return;
            }

            try {
                const response = await authFetch(`/api/auth/users/${userId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    alert('âœ… ì‚¬ìš©ìê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
                    loadUsers(); // ì‚¬ìš©ì ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    alert('âŒ ì‚¬ìš©ì ì‚­ì œ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Delete user error:', error);
                alert('âŒ ì‚¬ìš©ì ì‚­ì œ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ì‚¬ìš©ì ìˆ˜ì • ëª¨ë‹¬ ì—´ê¸°
        function editUser(userId, fullName, role) {
            // ì›ë˜ user_id ì €ì¥ (API endpointì— ì‚¬ìš©)
            document.getElementById('editUserOriginalId').value = userId;
            // í˜„ì¬ user_id (í¸ì§‘ ê°€ëŠ¥)
            document.getElementById('editUserId').value = userId;
            document.getElementById('editUserFullName').value = fullName;
            document.getElementById('editUserRole').value = role;
            document.getElementById('editUserPassword').value = '';  // ë¹„ë°€ë²ˆí˜¸ í•„ë“œ ì´ˆê¸°í™”

            // ëª¨ë‹¬ í‘œì‹œ
            const modal = document.getElementById('editUserModal');
            modal.style.display = 'flex';
        }

        // ì‚¬ìš©ì ìˆ˜ì • ëª¨ë‹¬ ë‹«ê¸°
        function closeEditUserModal() {
            const modal = document.getElementById('editUserModal');
            modal.style.display = 'none';
        }

        // ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
        async function updateUser() {
            const originalUserId = document.getElementById('editUserOriginalId').value;
            const newUserId = document.getElementById('editUserId').value.trim();
            const fullName = document.getElementById('editUserFullName').value.trim();
            const role = document.getElementById('editUserRole').value;
            const password = document.getElementById('editUserPassword').value;

            // user_id ê²€ì¦
            if (!newUserId) {
                alert('âŒ ì‚¬ìš©ì IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.');
                return;
            }

            try {
                const updateData = {
                    full_name: fullName,
                    role: role
                };

                // user_idê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ new_user_id ì¶”ê°€
                if (newUserId !== originalUserId) {
                    updateData.new_user_id = newUserId;
                }

                // ë¹„ë°€ë²ˆí˜¸ê°€ ì…ë ¥ë˜ì—ˆìœ¼ë©´ ì¶”ê°€
                if (password) {
                    updateData.password = password;
                }

                // ì›ë˜ user_idë¡œ API í˜¸ì¶œ (endpoint URLì— ì‚¬ìš©)
                const response = await authFetch(`/api/auth/users/${originalUserId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });

                const data = await response.json();

                if (data.success) {
                    const finalUserId = data.user_id || newUserId;
                    let message = 'âœ… ì‚¬ìš©ì ì •ë³´ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nUser ID: ' + finalUserId;

                    // user_idê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ì•Œë¦¼ ì¶”ê°€
                    if (newUserId !== originalUserId) {
                        message += '\n\nâš ï¸ ì‚¬ìš©ì IDê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n';
                        message += 'ì´ì „: ' + originalUserId + '\n';
                        message += 'ìƒˆë¡œìš´: ' + finalUserId;
                    }

                    alert(message);
                    closeEditUserModal();
                    loadUsers(); // ì‚¬ìš©ì ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    alert('âŒ ì‚¬ìš©ì ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:\n' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Update user error:', error);
                alert('âŒ ì‚¬ìš©ì ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:\n' + error.message);
            }
        }

        // ì‹œìŠ¤í…œ í†µê³„ ë¡œë“œ
        async function loadSystemStats() {
            const statsDiv = document.getElementById('systemStats');

            try {
                // GPU ì„œë²„ stats ê°€ì ¸ì˜¤ê¸°
                const response = await fetch(API_BASE_URL + '/api/stats');
                const data = await response.json();

                if (data.success) {
                    statsDiv.innerHTML = `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <h4 style="margin-top: 0;">ì¶”ë¡  í†µê³„</h4>
                                <p>ì´ ìš”ì²­: <strong>${data.inference.total_requests}</strong></p>
                                <p>í™œì„± ìš”ì²­: <strong>${data.inference.active_requests}</strong></p>
                                <p>ìµœëŒ€ ë™ì‹œ ìš”ì²­: <strong>${data.inference.max_concurrent}</strong></p>
                            </div>
                            <div>
                                <h4 style="margin-top: 0;">ì„œë²„ ìƒíƒœ</h4>
                                <p>CPU ì‚¬ìš©ëŸ‰: <strong>${data.server.cpu_percent.toFixed(1)}%</strong></p>
                                <p>ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: <strong>${data.server.memory_percent.toFixed(1)}%</strong></p>
                                <p>í™œì„± ìŠ¤ë ˆë“œ: <strong>${data.server.threads}</strong></p>
                            </div>
                            <div>
                                <h4 style="margin-top: 0;">AI ëª¨ë¸</h4>
                                <p>ì´ˆê¸°í™”: <strong>${data.ai_model.initialized ? 'âœ… Yes' : 'âŒ No'}</strong></p>
                                <p>ë””ë°”ì´ìŠ¤: <strong>${data.ai_model.device || 'N/A'}</strong></p>
                            </div>
                        </div>
                    `;
                } else {
                    statsDiv.innerHTML = '<p style="color: #999;">í†µê³„ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                }
            } catch (error) {
                console.error('[ADMIN] Load stats error:', error);
                statsDiv.innerHTML = '<p style="color: red;">í†µê³„ ë¡œë“œ ì‹¤íŒ¨</p>';
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë°±ì—”ë“œ í™•ì¸ ë° í”„ë¡œì íŠ¸ ëª©ë¡ ë¡œë“œ
        console.log('[SCRIPT END] Setting up load event listener...');
        window.addEventListener('load', async () => {
            console.log('[LOAD EVENT] Page loaded, validating session...');

            // ì„¸ì…˜ ê²€ì¦ ë¨¼ì € ìˆ˜í–‰
            const isValid = await validateSession();

            if (isValid) {
                // ì„¸ì…˜ì´ ìœ íš¨í•œ ê²½ìš°ì—ë§Œ ë°ì´í„° ë¡œë“œ
                // AI ìƒíƒœ ìë™ í™•ì¸
                setTimeout(() => {
                    checkAIStatus();
                }, 500);

                // ê´€ë¦¬ìì¸ ê²½ìš° ëŒ€ì‹œë³´ë“œ í‘œì‹œ
                const user = getCurrentUser();
                if (user && user.role === 'admin') {
                    const adminSection = document.getElementById('adminDashboardSection');
                    if (adminSection) {
                        adminSection.style.display = 'block';
                    }
                }
            }
        });

        // ========== ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ í•¨ìˆ˜ ==========
        let allAdminProjects = [];
        let allAdminClasses = {};  // í´ë˜ìŠ¤ë³„ ì–´ë…¸í…Œì´ì…˜ ìˆ˜
        let selectedAdminClass = "";  // ì„ íƒëœ í´ë˜ìŠ¤ í•„í„°
        let adminSortColumn = null;
        let adminSortDirection = 'asc';
        let selectedAdminProjects = new Set(); // ì„ íƒëœ í”„ë¡œì íŠ¸ ì¸ë±ìŠ¤ ì €ì¥

        async function loadAdminDashboard() {
            try {
                const response = await authFetch('/api/admin/dashboard');
                const data = await response.json();

                if (data.success) {
                    allAdminProjects = data.projects || [];
                    const summary = data.summary || {};

                    // ìš”ì•½ ì¹´ë“œ ì—…ë°ì´íŠ¸
                    const summaryCards = document.getElementById('adminSummaryCards');
                    summaryCards.innerHTML = `
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #4a9eff;">${summary.total_projects || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì´ í”„ë¡œì íŠ¸</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #28a745;">${summary.total_videos || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì´ ë¹„ë””ì˜¤</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #ffa500;">${summary.completed_videos || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì™„ë£Œëœ ë¹„ë””ì˜¤</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #ff6b6b;">${summary.total_annotations || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #9b59b6;">${summary.annotated_frames || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ì–´ë…¸í…Œì´ì…˜ í”„ë ˆì„</div>
                        </div>
                        <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #3498db;">${summary.unique_contributors || 0}</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">ê¸°ì—¬ì ìˆ˜</div>
                        </div>
                    `;

                    // í´ë˜ìŠ¤ ëª©ë¡ ë¡œë“œ
                    loadAdminClasses();
                    
                    // í”„ë¡œì íŠ¸ ëª©ë¡ ë Œë”ë§
                    renderAdminProjects();
                } else {
                    alert('ëŒ€ì‹œë³´ë“œ ë¡œë“œ ì‹¤íŒ¨: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('[ADMIN DASHBOARD] Error loading:', error);
                alert('ëŒ€ì‹œë³´ë“œ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            }
        }

        function renderAdminProjects(filterText = '', classFilter = '') {
            const projectsList = document.getElementById('adminProjectsList');

            let filtered = allAdminProjects;
            
            // í…ìŠ¤íŠ¸ í•„í„°
            if (filterText) {
                const lower = filterText.toLowerCase();
                filtered = filtered.filter(p =>
                    p.project_name.toLowerCase().includes(lower) ||
                    p.user_name.toLowerCase().includes(lower) ||
                    p.user_id.toLowerCase().includes(lower)
                );
            }
            
            // í´ë˜ìŠ¤ í•„í„°
            if (classFilter) {
                filtered = filtered.filter(p => {
                    const classDist = p.class_distribution || {};
                    return classDist[classFilter] && classDist[classFilter] > 0;
                });
            }

            if (filtered.length === 0) {
                projectsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            // ì •ë ¬ ì ìš©
            if (adminSortColumn) {
                filtered.sort((a, b) => {
                    let valA, valB;

                    switch(adminSortColumn) {
                        case 'user':
                            valA = a.user_name.toLowerCase();
                            valB = b.user_name.toLowerCase();
                            break;
                        case 'project':
                            valA = a.project_name.toLowerCase();
                            valB = b.project_name.toLowerCase();
                            break;
                        case 'videos':
                            valA = a.total_videos;
                            valB = b.total_videos;
                            break;
                        case 'completed':
                            valA = a.completed_videos;
                            valB = b.completed_videos;
                            break;
                        case 'annotations':
                            valA = a.total_annotations;
                            valB = b.total_annotations;
                            break;
                        case 'frames':
                            valA = a.annotated_frames;
                            valB = b.annotated_frames;
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return adminSortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    } else {
                        return adminSortDirection === 'asc' ? valA - valB : valB - valA;
                    }
                });
            }

            const getSortIcon = (column) => {
                if (adminSortColumn !== column) return '';
                return adminSortDirection === 'asc' ? ' â–²' : ' â–¼';
            };

            let html = `
                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead style="position: sticky; top: 0; background: #2d2d2d; z-index: 1;">
                        <tr>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: center; width: 40px;">
                                <input type="checkbox" id="selectAllProjects" onchange="toggleAllProjectSelection()" style="cursor: pointer;">
                            </th>
                            <th onclick="sortAdminProjects('user')" style="padding: 10px; border: 1px solid #404040; text-align: left; cursor: pointer; user-select: none;">ì‚¬ìš©ì${getSortIcon('user')}</th>
                            <th onclick="sortAdminProjects('project')" style="padding: 10px; border: 1px solid #404040; text-align: left; cursor: pointer; user-select: none;">í”„ë¡œì íŠ¸${getSortIcon('project')}</th>
                            <th onclick="sortAdminProjects('videos')" style="padding: 10px; border: 1px solid #404040; text-align: center; cursor: pointer; user-select: none;">ë¹„ë””ì˜¤${getSortIcon('videos')}</th>
                            <th onclick="sortAdminProjects('completed')" style="padding: 10px; border: 1px solid #404040; text-align: center; cursor: pointer; user-select: none;">ì™„ë£Œ${getSortIcon('completed')}</th>
                            <th onclick="sortAdminProjects('annotations')" style="padding: 10px; border: 1px solid #404040; text-align: center; cursor: pointer; user-select: none;">ì–´ë…¸í…Œì´ì…˜${getSortIcon('annotations')}</th>
                            <th onclick="sortAdminProjects('frames')" style="padding: 10px; border: 1px solid #404040; text-align: center; cursor: pointer; user-select: none;">í”„ë ˆì„${getSortIcon('frames')}</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: left;">í´ë˜ìŠ¤ ë¶„í¬</th>
                            <th style="padding: 10px; border: 1px solid #404040; text-align: left;">ê¸°ì—¬ì</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            filtered.forEach((project, index) => {
                const projectIndex = allAdminProjects.indexOf(project);
                const isChecked = selectedAdminProjects.has(projectIndex);

                const completionRate = project.total_videos > 0
                    ? Math.round(project.completed_videos / project.total_videos * 100)
                    : 0;

                // í´ë˜ìŠ¤ ë¶„í¬ ë¬¸ìì—´
                const classDistribution = Object.entries(project.class_distribution)
                    .map(([label, count]) => `${label}: ${count}`)
                    .join(', ') || '-';

                // ê¸°ì—¬ì ë¬¸ìì—´
                const contributors = project.contributors.join(', ') || '-';

                html += `
                    <tr style="border-bottom: 1px solid #404040;">
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">
                            <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="toggleProjectSelection(${projectIndex})" style="cursor: pointer;">
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040;">
                            <div style="font-weight: bold;">${project.user_name}</div>
                            <div style="font-size: 10px; color: #999;">${project.user_id}</div>
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040;">
                            <div style="font-weight: bold; color: #4a9eff; cursor: pointer; text-decoration: underline;" onclick="showProjectDetail(${projectIndex})">${project.project_name}</div>
                            <div style="font-size: 10px; color: #999;">${project.project_id}</div>
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">${project.total_videos}</td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">
                            <div>${project.completed_videos}</div>
                            <div style="font-size: 10px; color: ${completionRate === 100 ? '#28a745' : '#ffa500'};">${completionRate}%</div>
                        </td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center; font-weight: bold; color: #ff6b6b;">${project.total_annotations}</td>
                        <td style="padding: 8px; border: 1px solid #404040; text-align: center;">${project.annotated_frames}</td>
                        <td style="padding: 8px; border: 1px solid #404040; font-size: 10px; max-width: 200px; overflow: hidden; text-overflow: ellipsis;" title="${classDistribution}">${classDistribution}</td>
                        <td style="padding: 8px; border: 1px solid #404040; font-size: 10px;">${contributors}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            projectsList.innerHTML = html;
        }

        function filterAdminProjects() {
            const filterInput = document.getElementById('adminProjectFilter');
            const filterText = filterInput ? filterInput.value : '';
            const classFilter = document.getElementById('adminClassFilter');
            selectedAdminClass = classFilter ? classFilter.value : '';
            
            // í´ë˜ìŠ¤ ì–´ë…¸í…Œì´ì…˜ ë³´ê¸° ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
            const viewBtn = document.getElementById('viewClassAnnotationsBtn');
            if (viewBtn) {
                viewBtn.style.display = selectedAdminClass ? 'inline-block' : 'none';
            }
            
            // í•„í„° ì •ë³´ í‘œì‹œ
            const filterInfo = document.getElementById('adminFilterInfo');
            if (filterInfo && selectedAdminClass && allAdminClasses[selectedAdminClass]) {
                filterInfo.textContent = '"' + selectedAdminClass + '" í´ë˜ìŠ¤: ' + allAdminClasses[selectedAdminClass] + 'ê°œ ì–´ë…¸í…Œì´ì…˜';
            } else if (filterInfo) {
                filterInfo.textContent = '';
            }
            
            renderAdminProjects(filterText, selectedAdminClass);
        }
        
        // í´ë˜ìŠ¤ ëª©ë¡ ë¡œë“œ
        async function loadAdminClasses() {
            try {
                const response = await authFetch('/api/admin/classes/summary');
                const data = await response.json();
                
                if (data.success) {
                    allAdminClasses = data.classes || {};
                    
                    // ë“œë¡­ë‹¤ìš´ ì—…ë°ì´íŠ¸
                    const select = document.getElementById('adminClassFilter');
                    if (select) {
                        select.innerHTML = '<option value="">ğŸ·ï¸ ëª¨ë“  í´ë˜ìŠ¤</option>';
                        
                        Object.entries(allAdminClasses).forEach(([className, count]) => {
                            const option = document.createElement('option');
                            option.value = className;
                            option.textContent = className + ' (' + count + ')';
                            select.appendChild(option);
                        });
                    }
                }
            } catch (error) {
                console.error('[ADMIN] Error loading classes:', error);
            }
        }
        
        // í´ë˜ìŠ¤ ì–´ë…¸í…Œì´ì…˜ ë³´ê¸°
        async function viewClassAnnotations() {
            if (!selectedAdminClass) {
                alert('í´ë˜ìŠ¤ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }
            
            try {
                const response = await authFetch('/api/admin/annotations/by-class/' + encodeURIComponent(selectedAdminClass) + '?limit=50');
                const data = await response.json();
                
                if (data.success) {
                    showClassAnnotationsModal(data);
                } else {
                    alert('ì–´ë…¸í…Œì´ì…˜ ì¡°íšŒ ì‹¤íŒ¨: ' + data.error);
                }
            } catch (error) {
                console.error('[ADMIN] Error loading class annotations:', error);
                alert('ì–´ë…¸í…Œì´ì…˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜: ' + error.message);
            }
        }
        
        // í´ë˜ìŠ¤ ì–´ë…¸í…Œì´ì…˜ ëª¨ë‹¬ í‘œì‹œ
        function showClassAnnotationsModal(data) {
            // ê¸°ì¡´ ëª¨ë‹¬ì´ ìˆìœ¼ë©´ ì œê±°
            let modal = document.getElementById('classAnnotationsModal');
            if (modal) {
                modal.remove();
            }
            
            const annotations = data.annotations || [];
            const total = data.total || 0;
            const className = data.class_name || '';
            
            // ëª¨ë‹¬ ìƒì„±
            modal = document.createElement('div');
            modal.id = 'classAnnotationsModal';
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:10000;display:flex;justify-content:center;align-items:center;';
            
            let itemsHtml = '';
            annotations.forEach((item, idx) => {
                itemsHtml += '<div style="background:#2d2d2d;padding:12px;border-radius:4px;border-left:4px solid #9b59b6;cursor:pointer;" ' +
                    'onclick="goToAnnotation(\'' + item.project_id + '\',\'' + item.video_id + '\',\'' + item.frame + '\')">' +
                    '<div style="color:#4a9eff;font-weight:bold;margin-bottom:5px;">' + item.project_name + '</div>' +
                    '<div style="color:#aaa;font-size:11px;">ğŸ‘¤ ' + item.user_name + ' Â· ğŸ¬ ' + item.video_id.substring(0,20) + '... Â· ğŸ–¼ï¸ Frame ' + item.frame + '</div>' +
                    '</div>';
            });
            
            modal.innerHTML = '<div style="background:#1e1e1e;border-radius:8px;padding:25px;max-width:700px;width:90%;max-height:80vh;overflow-y:auto;">' +
                '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">' +
                '<h3 style="margin:0;color:#9b59b6;">ğŸ·ï¸ "' + className + '" í´ë˜ìŠ¤ ì–´ë…¸í…Œì´ì…˜</h3>' +
                '<button onclick="document.getElementById(\'classAnnotationsModal\').remove()" style="background:#ff4444;border:none;color:white;padding:8px 16px;border-radius:4px;cursor:pointer;">ë‹«ê¸°</button>' +
                '</div>' +
                '<div style="color:#888;margin-bottom:15px;">ì´ ' + total + 'ê°œ ì¤‘ ' + annotations.length + 'ê°œ í‘œì‹œ Â· í´ë¦­í•˜ë©´ í•´ë‹¹ ìœ„ì¹˜ë¡œ ì´ë™</div>' +
                '<div style="display:flex;flex-direction:column;gap:10px;">' + 
                (itemsHtml || '<div style="color:#666;text-align:center;padding:30px;">ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.</div>') +
                '</div></div>';
            
            document.body.appendChild(modal);
            
            // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // ì–´ë…¸í…Œì´ì…˜ ìœ„ì¹˜ë¡œ ì´ë™
        function goToAnnotation(projectId, videoId, frame) {
            // ëª¨ë‹¬ ë‹«ê¸°
            const modal = document.getElementById('classAnnotationsModal');
            if (modal) modal.remove();
            
            // Annotation íƒ­ìœ¼ë¡œ ì´ë™í•˜ê³  í•´ë‹¹ ìœ„ì¹˜ ë¡œë“œ
            showTab('annotation');
            
            // URL ì—…ë°ì´íŠ¸ ë° ë¹„ë””ì˜¤ ë¡œë“œ
            const url = '?tab=annotation&project=' + encodeURIComponent(projectId) + '&video=' + encodeURIComponent(videoId) + '&frame=' + frame;
            history.pushState({}, '', url);
            
            // í”„ë¡œì íŠ¸ì™€ ë¹„ë””ì˜¤ ë¡œë“œ
            setTimeout(async () => {
                try {
                    await openProject(projectId);
                    await loadVideo(videoId);
                    if (typeof seekToFrame === 'function') {
                        seekToFrame(parseInt(frame));
                    }
                } catch (error) {
                    console.error('Error navigating to annotation:', error);
                }
            }, 500);
        }

        function sortAdminProjects(column) {
            if (adminSortColumn === column) {
                // ê°™ì€ ì»¬ëŸ¼ í´ë¦­ ì‹œ ë°©í–¥ í† ê¸€
                adminSortDirection = adminSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // ë‹¤ë¥¸ ì»¬ëŸ¼ í´ë¦­ ì‹œ í•´ë‹¹ ì»¬ëŸ¼ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
                adminSortColumn = column;
                adminSortDirection = 'asc';
            }
            renderAdminProjects();
        }

        function showProjectDetail(projectIndex) {
            const project = allAdminProjects[projectIndex];
            if (!project) return;

            const modal = document.getElementById('projectDetailModal');
            const content = document.getElementById('projectDetailContent');

            const completionRate = project.total_videos > 0
                ? Math.round(project.completed_videos / project.total_videos * 100)
                : 0;

            // í´ë˜ìŠ¤ ë¶„í¬ ì°¨íŠ¸ ë°ì´í„°
            const classEntries = Object.entries(project.class_distribution)
                .sort((a, b) => b[1] - a[1]);

            let classChart = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            classEntries.forEach(([label, count]) => {
                const percentage = project.total_annotations > 0
                    ? Math.round(count / project.total_annotations * 100)
                    : 0;
                classChart += `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 100px; font-size: 12px; color: #ccc;">${label}</div>
                        <div style="flex: 1; background: #1e1e1e; height: 20px; border-radius: 4px; overflow: hidden;">
                            <div style="background: #4a9eff; height: 100%; width: ${percentage}%;"></div>
                        </div>
                        <div style="width: 80px; text-align: right; font-size: 12px; color: #ccc;">${count}ê°œ (${percentage}%)</div>
                    </div>
                `;
            });
            classChart += '</div>';

            content.innerHTML = `
                <h2 style="margin-top: 0; color: #4a9eff;">${project.project_name}</h2>

                <div style="margin-bottom: 20px;">
                    <div style="font-size: 12px; color: #999;">í”„ë¡œì íŠ¸ ID: ${project.project_id}</div>
                    <div style="font-size: 12px; color: #999;">ì†Œìœ ì: ${project.user_name} (${project.user_id})</div>
                </div>

                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 30px;">
                    <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 20px; font-weight: bold; color: #4a9eff;">${project.total_videos}</div>
                        <div style="font-size: 11px; color: #999;">ì´ ë¹„ë””ì˜¤</div>
                    </div>
                    <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 20px; font-weight: bold; color: #28a745;">${project.completed_videos}</div>
                        <div style="font-size: 11px; color: #999;">ì™„ë£Œ (${completionRate}%)</div>
                    </div>
                    <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 20px; font-weight: bold; color: #ff6b6b;">${project.total_annotations}</div>
                        <div style="font-size: 11px; color: #999;">ì´ ì–´ë…¸í…Œì´ì…˜</div>
                    </div>
                    <div style="background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 20px; font-weight: bold; color: #9b59b6;">${project.annotated_frames}</div>
                        <div style="font-size: 11px; color: #999;">ì–´ë…¸í…Œì´ì…˜ í”„ë ˆì„</div>
                    </div>
                </div>

                <h3 style="color: #4a9eff; margin-top: 30px;">ğŸ“Š í´ë˜ìŠ¤ ë¶„í¬</h3>
                <div style="background: #1e1e1e; padding: 20px; border-radius: 4px; margin-bottom: 30px;">
                    ${classChart || '<div style="color: #999;">í´ë˜ìŠ¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'}
                </div>

                <h3 style="color: #4a9eff;">ğŸ‘¥ ê¸°ì—¬ì (${project.contributors.length}ëª…)</h3>
                <div style="background: #1e1e1e; padding: 15px; border-radius: 4px;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        ${project.contributors.map(c => `<span style="background: #2d2d2d; padding: 6px 12px; border-radius: 4px; font-size: 12px;">${c}</span>`).join('')}
                    </div>
                </div>
            `;

            modal.style.display = 'block';
        }

        function closeProjectDetail() {
            const modal = document.getElementById('projectDetailModal');
            modal.style.display = 'none';
        }

        function toggleProjectSelection(projectIndex) {
            if (selectedAdminProjects.has(projectIndex)) {
                selectedAdminProjects.delete(projectIndex);
            } else {
                selectedAdminProjects.add(projectIndex);
            }
            updateSelectionUI();
        }

        function toggleAllProjectSelection() {
            const checkbox = document.getElementById('selectAllProjects');
            if (checkbox.checked) {
                // ëª¨ë“  í”„ë¡œì íŠ¸ ì„ íƒ
                allAdminProjects.forEach((_, index) => {
                    selectedAdminProjects.add(index);
                });
            } else {
                // ëª¨ë“  ì„ íƒ í•´ì œ
                selectedAdminProjects.clear();
            }
            updateSelectionUI();
            renderAdminProjects();
        }

        function updateSelectionUI() {
            const count = selectedAdminProjects.size;
            const createBtn = document.getElementById('createDatasetFromAdminBtn');
            const countSpan = document.getElementById('selectedProjectCount');

            if (count > 0) {
                createBtn.style.display = 'block';
                countSpan.textContent = count;
            } else {
                createBtn.style.display = 'none';
            }

            // "ì „ì²´ ì„ íƒ" ì²´í¬ë°•ìŠ¤ ìƒíƒœ ì—…ë°ì´íŠ¸
            const selectAllCheckbox = document.getElementById('selectAllProjects');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = (count === allAdminProjects.length && count > 0);
            }
        }

        async function createDatasetFromSelectedProjects() {
            if (selectedAdminProjects.size === 0) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì„ íƒëœ í”„ë¡œì íŠ¸ ì •ë³´ ìˆ˜ì§‘
            const selectedProjects = Array.from(selectedAdminProjects)
                .map(index => allAdminProjects[index])
                .filter(p => p);

            if (selectedProjects.length === 0) {
                alert('ìœ íš¨í•œ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            // ë°ì´í„°ì…‹ ë¹Œë” íƒ­ìœ¼ë¡œ ì „í™˜í•˜ê³  ì„ íƒëœ í”„ë¡œì íŠ¸ ì •ë³´ ì „ë‹¬
            showTab('dataset');

            // ë°ì´í„°ì…‹ ë¹Œë”ì— ì„ íƒëœ í”„ë¡œì íŠ¸ ì •ë³´ ì „ë‹¬
            setTimeout(() => {
                populateDatasetBuilderFromAdminSelection(selectedProjects);
            }, 100);
        }

        async function populateDatasetBuilderFromAdminSelection(selectedProjects) {
            console.log('[DATASET FROM ADMIN] ì„ íƒëœ í”„ë¡œì íŠ¸:', selectedProjects.length);

            // í”„ë¡œì íŠ¸ë³„ë¡œ ì‚¬ìš©ìì™€ í”„ë¡œì íŠ¸ ID ìˆ˜ì§‘
            const projectsToLoad = selectedProjects.map(p => ({
                user_id: p.user_id,
                user_name: p.user_name,
                project_id: p.project_id,
                project_name: p.project_name
            }));

            // ë°ì´í„°ì…‹ ë¹Œë” ì„¹ì…˜ì— ì •ë³´ í‘œì‹œ
            const builderInfo = document.getElementById('datasetBuilderInfo');
            if (builderInfo) {
                let html = `
                    <div style="background: #2d2d2d; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                        <h4 style="color: #9b59b6; margin: 0 0 10px 0;">ğŸ“¦ ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œì—ì„œ ì„ íƒí•œ í”„ë¡œì íŠ¸ (${projectsToLoad.length}ê°œ)</h4>
                        <div style="max-height: 200px; overflow-y: auto;">
                `;

                projectsToLoad.forEach(p => {
                    html += `
                        <div style="background: #1e1e1e; padding: 8px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-weight: bold; color: #4a9eff;">${p.project_name}</span>
                                <span style="font-size: 11px; color: #999; margin-left: 10px;">(${p.user_name})</span>
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #404040;">
                            <p style="color: #ccc; font-size: 13px; margin: 0;">
                                ì´ í”„ë¡œì íŠ¸ë“¤ì˜ ì–´ë…¸í…Œì´ì…˜ì„ ê²°í•©í•˜ì—¬ ë°ì´í„°ì…‹ì„ ìƒì„±í•©ë‹ˆë‹¤.<br>
                                ì•„ë˜ì—ì„œ ì¶œë ¥ í˜•ì‹ì„ ì„ íƒí•˜ê³  'ë°ì´í„°ì…‹ ë¹Œë“œ' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.
                            </p>
                        </div>
                    </div>
                `;

                builderInfo.innerHTML = html;
            }

            // ì „ì—­ ë³€ìˆ˜ì— ì €ì¥í•˜ì—¬ ë°ì´í„°ì…‹ ë¹Œë“œ ì‹œ ì‚¬ìš©
            window.adminSelectedProjects = projectsToLoad;

            // ìë™ìœ¼ë¡œ ë¹„ë””ì˜¤ ëª©ë¡ ë¡œë“œ
            await loadVideosForDataset();

            alert(`${projectsToLoad.length}ê°œ í”„ë¡œì íŠ¸ê°€ ë°ì´í„°ì…‹ ë¹Œë”ì— ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.\nì•„ë˜ì—ì„œ ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ê³  'ë°ì´í„°ì…‹ ë¹Œë“œ' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.`);
        }

        function exportAdminDashboardCSV() {
            if (allAdminProjects.length === 0) {
                alert('ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.');
                return;
            }

            // CSV í—¤ë”
            let csv = 'ì‚¬ìš©ìID,ì‚¬ìš©ìëª…,í”„ë¡œì íŠ¸ID,í”„ë¡œì íŠ¸ëª…,ì´ë¹„ë””ì˜¤,ì™„ë£Œë¹„ë””ì˜¤,ì™„ë£Œìœ¨(%),ì´ì–´ë…¸í…Œì´ì…˜,ì–´ë…¸í…Œì´ì…˜í”„ë ˆì„,í´ë˜ìŠ¤ë¶„í¬,ê¸°ì—¬ì\n';

            // ë°ì´í„° í–‰
            allAdminProjects.forEach(project => {
                const completionRate = project.total_videos > 0
                    ? Math.round(project.completed_videos / project.total_videos * 100)
                    : 0;

                const classDistribution = Object.entries(project.class_distribution)
                    .map(([label, count]) => `${label}:${count}`)
                    .join(';');

                const contributors = project.contributors.join(';');

                // CSV í–‰ ì¶”ê°€ (ë”°ì˜´í‘œë¡œ ê°ì‹¸ì„œ ì‰¼í‘œ ë¬¸ì œ ë°©ì§€)
                csv += `"${project.user_id}","${project.user_name}","${project.project_id}","${project.project_name}",`;
                csv += `${project.total_videos},${project.completed_videos},${completionRate},`;
                csv += `${project.total_annotations},${project.annotated_frames},"${classDistribution}","${contributors}"\n`;
            });

            // BOM ì¶”ê°€ (í•œê¸€ ì¸ì½”ë”© ë¬¸ì œ í•´ê²°)
            const BOM = '\uFEFF';
            const blob = new Blob([BOM + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            const now = new Date();
            const filename = `admin_dashboard_${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`[ADMIN DASHBOARD] CSV exported: ${filename}`);
        }

    </script>

    <!-- íŒŒì¼ ë¸Œë¼ìš°ì € ëª¨ë‹¬ (ì „ì—­) -->
    <div id="fileBrowserModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10002; justify-content: center; align-items: center;">
        <div style="background: #2d2d2d; padding: 20px; border-radius: 8px; width: 90%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0;">ëª¨ë¸ íŒŒì¼ ì„ íƒ</h3>
                <button onclick="closeFileBrowser()" style="background: none; border: none; color: #fff; font-size: 24px; cursor: pointer;">&times;</button>
            </div>

            <!-- í˜„ì¬ ê²½ë¡œ í‘œì‹œ -->
            <div style="background: #1e1e1e; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-family: monospace; font-size: 12px; color: #aaa; word-break: break-all;">
                <span id="fileBrowserCurrentPath">/</span>
            </div>

            <!-- íŒŒì¼ ëª©ë¡ -->
            <div id="fileBrowserList" style="flex: 1; overflow-y: auto; background: #1e1e1e; border-radius: 4px; min-height: 300px; max-height: 400px;">
                <div style="padding: 20px; color: #666; text-align: center;">ë¡œë”© ì¤‘...</div>
            </div>

            <!-- ì„ íƒëœ íŒŒì¼ -->
            <div style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 12px;">ì„ íƒëœ íŒŒì¼:</label>
                <input type="text" id="fileBrowserSelected" readonly style="width: 100%; padding: 8px; background: #1e1e1e; color: #fff; border: 1px solid #404040; border-radius: 4px;">
            </div>

            <!-- ë²„íŠ¼ -->
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                <button onclick="closeFileBrowser()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    ì·¨ì†Œ
                </button>
                <button onclick="confirmFileSelection()" style="padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    ì„ íƒ
                </button>
            </div>
        </div>
    </div>
</body>
</html>
